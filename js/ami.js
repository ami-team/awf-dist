/*!
 * AMI Web Framework (AWF) 2.0.0
 *
 * Copyright (c) 2014-2025 CNRS/LPSC
 *
 * Author: Jerome Odier (jerome.odier@lpsc.in2p3.fr)
 *
 * Repositories: https://gitlab.in2p3.fr/ami-team/AMIWebFramework/
 *               https://www.github.com/ami-team/AMIWebFramework/
 *
 * This software is a computer program whose purpose is to provide an
 * HTTP / JavaScript framework to the ATLAS Metadata Interface (AMI)
 * ecosystem.
 *
 * This software is governed by the CeCILL-C license under French law and
 * abiding by the rules of distribution of free software. You can use,
 * modify and/or redistribute the software under the terms of the CeCILL-C
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 *
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 93:
/***/ ((module) => {

function BitBuffer() {
  this.buffer = [];
  this.length = 0;
}
BitBuffer.prototype = {
  get: function (index) {
    const bufIndex = Math.floor(index / 8);
    return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
  },
  put: function (num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit((num >>> length - i - 1 & 1) === 1);
    }
  },
  getLengthInBits: function () {
    return this.length;
  },
  putBit: function (bit) {
    const bufIndex = Math.floor(this.length / 8);
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0);
    }
    if (bit) {
      this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
    }
    this.length++;
  }
};
module.exports = BitBuffer;

/***/ }),

/***/ 151:
/***/ ((__unused_webpack_module, exports) => {

exports.L = {
  bit: 1
};
exports.M = {
  bit: 0
};
exports.Q = {
  bit: 3
};
exports.H = {
  bit: 2
};
function fromString(string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string');
  }
  const lcStr = string.toLowerCase();
  switch (lcStr) {
    case 'l':
    case 'low':
      return exports.L;
    case 'm':
    case 'medium':
      return exports.M;
    case 'q':
    case 'quartile':
      return exports.Q;
    case 'h':
    case 'high':
      return exports.H;
    default:
      throw new Error('Unknown EC Level: ' + string);
  }
}
exports.isValid = function isValid(level) {
  return level && typeof level.bit !== 'undefined' && level.bit >= 0 && level.bit < 4;
};
exports.from = function from(value, defaultValue) {
  if (exports.isValid(value)) {
    return value;
  }
  try {
    return fromString(value);
  } catch (e) {
    return defaultValue;
  }
};

/***/ }),

/***/ 410:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/ami.woff2";

/***/ }),

/***/ 413:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $g: () => (/* binding */ parseMixed),
/* harmony export */   PH: () => (/* binding */ Tree),
/* harmony export */   Qj: () => (/* binding */ IterMode),
/* harmony export */   RY: () => (/* binding */ NodeWeakMap),
/* harmony export */   Z6: () => (/* binding */ NodeType),
/* harmony export */   cF: () => (/* binding */ DefaultBufferLength),
/* harmony export */   fI: () => (/* binding */ NodeSet),
/* harmony export */   iX: () => (/* binding */ Parser),
/* harmony export */   rr: () => (/* binding */ TreeFragment),
/* harmony export */   uY: () => (/* binding */ NodeProp)
/* harmony export */ });
/* unused harmony exports MountedTree, TreeBuffer, TreeCursor */
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
const DefaultBufferLength = 1024;
let nextPropID = 0;
class Range {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
class NodeProp {
  constructor(config) {
    if (config === void 0) {
      config = {};
    }
    this.id = nextPropID++;
    this.perNode = !!config.perNode;
    this.deserialize = config.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(match) {
    if (this.perNode) throw new RangeError("Can't add per-node props to node types");
    if (typeof match != "function") match = NodeType.match(match);
    return type => {
      let result = match(type);
      return result === undefined ? null : [this, result];
    };
  }
}
NodeProp.closedBy = new NodeProp({
  deserialize: str => str.split(" ")
});
NodeProp.openedBy = new NodeProp({
  deserialize: str => str.split(" ")
});
NodeProp.group = new NodeProp({
  deserialize: str => str.split(" ")
});
NodeProp.isolate = new NodeProp({
  deserialize: value => {
    if (value && value != "rtl" && value != "ltr" && value != "auto") throw new RangeError("Invalid value for isolate: " + value);
    return value || "auto";
  }
});
NodeProp.contextHash = new NodeProp({
  perNode: true
});
NodeProp.lookAhead = new NodeProp({
  perNode: true
});
NodeProp.mounted = new NodeProp({
  perNode: true
});
class MountedTree {
  constructor(tree, overlay, parser) {
    this.tree = tree;
    this.overlay = overlay;
    this.parser = parser;
  }
  static get(tree) {
    return tree && tree.props && tree.props[NodeProp.mounted.id];
  }
}
const noProps = Object.create(null);
class NodeType {
  constructor(name, props, id, flags) {
    if (flags === void 0) {
      flags = 0;
    }
    this.name = name;
    this.props = props;
    this.id = id;
    this.flags = flags;
  }
  static define(spec) {
    let props = spec.props && spec.props.length ? Object.create(null) : noProps;
    let flags = (spec.top ? 1 : 0) | (spec.skipped ? 2 : 0) | (spec.error ? 4 : 0) | (spec.name == null ? 8 : 0);
    let type = new NodeType(spec.name || "", props, spec.id, flags);
    if (spec.props) {
      for (var _iterator = _createForOfIteratorHelperLoose(spec.props), _step; !(_step = _iterator()).done;) {
        let src = _step.value;
        if (!Array.isArray(src)) src = src(type);
        if (src) {
          if (src[0].perNode) throw new RangeError("Can't store a per-node prop on a node type");
          props[src[0].id] = src[1];
        }
      }
    }
    return type;
  }
  prop(prop) {
    return this.props[prop.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(name) {
    if (typeof name == 'string') {
      if (this.name == name) return true;
      let group = this.prop(NodeProp.group);
      return group ? group.indexOf(name) > -1 : false;
    }
    return this.id == name;
  }
  static match(map) {
    let direct = Object.create(null);
    for (let prop in map) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(prop.split(" ")), _step2; !(_step2 = _iterator2()).done;) {
        let name = _step2.value;
        direct[name] = map[prop];
      }
    }
    return node => {
      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
        let found = direct[i < 0 ? node.name : groups[i]];
        if (found) return found;
      }
    };
  }
}
NodeType.none = new NodeType("", Object.create(null), 0, 8);
class NodeSet {
  constructor(types) {
    this.types = types;
    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend() {
    let newTypes = [];
    for (var _len = arguments.length, props = new Array(_len), _key = 0; _key < _len; _key++) {
      props[_key] = arguments[_key];
    }
    for (var _iterator3 = _createForOfIteratorHelperLoose(this.types), _step3; !(_step3 = _iterator3()).done;) {
      let type = _step3.value;
      let newProps = null;
      for (var _iterator4 = _createForOfIteratorHelperLoose(props), _step4; !(_step4 = _iterator4()).done;) {
        let source = _step4.value;
        let add = source(type);
        if (add) {
          if (!newProps) newProps = Object.assign({}, type.props);
          newProps[add[0].id] = add[1];
        }
      }
      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);
    }
    return new NodeSet(newTypes);
  }
}
const CachedNode = new WeakMap(),
  CachedInnerNode = new WeakMap();
var IterMode;
(function (IterMode) {
  IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
  IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
  IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
  IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
class Tree {
  constructor(type, children, positions, length, props) {
    this.type = type;
    this.children = children;
    this.positions = positions;
    this.length = length;
    this.props = null;
    if (props && props.length) {
      this.props = Object.create(null);
      for (var _iterator5 = _createForOfIteratorHelperLoose(props), _step5; !(_step5 = _iterator5()).done;) {
        let [prop, value] = _step5.value;
        this.props[typeof prop == "number" ? prop : prop.id] = value;
      }
    }
  }
  toString() {
    let mounted = MountedTree.get(this);
    if (mounted && !mounted.overlay) return mounted.tree.toString();
    let children = "";
    for (var _iterator6 = _createForOfIteratorHelperLoose(this.children), _step6; !(_step6 = _iterator6()).done;) {
      let ch = _step6.value;
      let str = ch.toString();
      if (str) {
        if (children) children += ",";
        children += str;
      }
    }
    return !this.type.name ? children : (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? "(" + children + ")" : "");
  }
  cursor(mode) {
    if (mode === void 0) {
      mode = 0;
    }
    return new TreeCursor(this.topNode, mode);
  }
  cursorAt(pos, side, mode) {
    if (side === void 0) {
      side = 0;
    }
    if (mode === void 0) {
      mode = 0;
    }
    let scope = CachedNode.get(this) || this.topNode;
    let cursor = new TreeCursor(scope);
    cursor.moveTo(pos, side);
    CachedNode.set(this, cursor._tree);
    return cursor;
  }
  get topNode() {
    return new TreeNode(this, 0, 0, null);
  }
  resolve(pos, side) {
    if (side === void 0) {
      side = 0;
    }
    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
    CachedNode.set(this, node);
    return node;
  }
  resolveInner(pos, side) {
    if (side === void 0) {
      side = 0;
    }
    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
    CachedInnerNode.set(this, node);
    return node;
  }
  resolveStack(pos, side) {
    if (side === void 0) {
      side = 0;
    }
    return stackIterator(this, pos, side);
  }
  iterate(spec) {
    let {
      enter,
      leave,
      from = 0,
      to = this.length
    } = spec;
    let mode = spec.mode || 0,
      anon = (mode & IterMode.IncludeAnonymous) > 0;
    for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {
      let entered = false;
      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
        if (c.firstChild()) continue;
        entered = true;
      }
      for (;;) {
        if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);
        if (c.nextSibling()) break;
        if (!c.parent()) return;
        entered = true;
      }
    }
  }
  prop(prop) {
    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
  }
  get propValues() {
    let result = [];
    if (this.props) for (let id in this.props) result.push([+id, this.props[id]]);
    return result;
  }
  balance(config) {
    if (config === void 0) {
      config = {};
    }
    return this.children.length <= 8 ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));
  }
  static build(data) {
    return buildTree(data);
  }
}
Tree.empty = new Tree(NodeType.none, [], [], 0);
class FlatBufferCursor {
  constructor(buffer, index) {
    this.buffer = buffer;
    this.index = index;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new FlatBufferCursor(this.buffer, this.index);
  }
}
class TreeBuffer {
  constructor(buffer, length, set) {
    this.buffer = buffer;
    this.length = length;
    this.set = set;
  }
  get type() {
    return NodeType.none;
  }
  toString() {
    let result = [];
    for (let index = 0; index < this.buffer.length;) {
      result.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result.join(",");
  }
  childString(index) {
    let id = this.buffer[index],
      endIndex = this.buffer[index + 3];
    let type = this.set.types[id],
      result = type.name;
    if (/\W/.test(result) && !type.isError) result = JSON.stringify(result);
    index += 4;
    if (endIndex == index) return result;
    let children = [];
    while (index < endIndex) {
      children.push(this.childString(index));
      index = this.buffer[index + 3];
    }
    return result + "(" + children.join(",") + ")";
  }
  findChild(startIndex, endIndex, dir, pos, side) {
    let {
        buffer
      } = this,
      pick = -1;
    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
        pick = i;
        if (dir > 0) break;
      }
    }
    return pick;
  }
  slice(startI, endI, from) {
    let b = this.buffer;
    let copy = new Uint16Array(endI - startI),
      len = 0;
    for (let i = startI, j = 0; i < endI;) {
      copy[j++] = b[i++];
      copy[j++] = b[i++] - from;
      let to = copy[j++] = b[i++] - from;
      copy[j++] = b[i++] - startI;
      len = Math.max(len, to);
    }
    return new TreeBuffer(copy, len, this.set);
  }
}
function checkSide(side, pos, from, to) {
  switch (side) {
    case -2:
      return from < pos;
    case -1:
      return to >= pos && from < pos;
    case 0:
      return from < pos && to > pos;
    case 1:
      return from <= pos && to > pos;
    case 2:
      return to > pos;
    case 4:
      return true;
  }
}
function resolveNode(node, pos, side, overlays) {
  var _a;
  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {
    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
    if (!parent) return node;
    node = parent;
  }
  let mode = overlays ? 0 : IterMode.IgnoreOverlays;
  if (overlays) for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
    if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;
  }
  for (;;) {
    let inner = node.enter(pos, side, mode);
    if (!inner) return node;
    node = inner;
  }
}
class BaseNode {
  cursor(mode) {
    if (mode === void 0) {
      mode = 0;
    }
    return new TreeCursor(this, mode);
  }
  getChild(type, before, after) {
    if (before === void 0) {
      before = null;
    }
    if (after === void 0) {
      after = null;
    }
    let r = getChildren(this, type, before, after);
    return r.length ? r[0] : null;
  }
  getChildren(type, before, after) {
    if (before === void 0) {
      before = null;
    }
    if (after === void 0) {
      after = null;
    }
    return getChildren(this, type, before, after);
  }
  resolve(pos, side) {
    if (side === void 0) {
      side = 0;
    }
    return resolveNode(this, pos, side, false);
  }
  resolveInner(pos, side) {
    if (side === void 0) {
      side = 0;
    }
    return resolveNode(this, pos, side, true);
  }
  matchContext(context) {
    return matchNodeContext(this.parent, context);
  }
  enterUnfinishedNodesBefore(pos) {
    let scan = this.childBefore(pos),
      node = this;
    while (scan) {
      let last = scan.lastChild;
      if (!last || last.to != scan.to) break;
      if (last.type.isError && last.from == last.to) {
        node = scan;
        scan = last.prevSibling;
      } else {
        scan = last;
      }
    }
    return node;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class TreeNode extends BaseNode {
  constructor(_tree, from, index, _parent) {
    super();
    this._tree = _tree;
    this.from = from;
    this.index = index;
    this._parent = _parent;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(i, dir, pos, side, mode) {
    if (mode === void 0) {
      mode = 0;
    }
    for (let parent = this;;) {
      for (let {
          children,
          positions
        } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
        let next = children[i],
          start = positions[i] + parent.from;
        if (!checkSide(side, pos, start, start + next.length)) continue;
        if (next instanceof TreeBuffer) {
          if (mode & IterMode.ExcludeBuffers) continue;
          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);
        } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {
          let mounted;
          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);
          let inner = new TreeNode(next, start, i, parent);
          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
        }
      }
      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;
      if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent._tree.children.length;
      parent = parent._parent;
      if (!parent) return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(pos) {
    return this.nextChild(0, 1, pos, 2);
  }
  childBefore(pos) {
    return this.nextChild(this._tree.children.length - 1, -1, pos, -2);
  }
  enter(pos, side, mode) {
    if (mode === void 0) {
      mode = 0;
    }
    let mounted;
    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
      let rPos = pos - this.from;
      for (var _iterator7 = _createForOfIteratorHelperLoose(mounted.overlay), _step7; !(_step7 = _iterator7()).done;) {
        let {
          from,
          to
        } = _step7.value;
        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
      }
    }
    return this.nextChild(0, 1, pos, side, mode);
  }
  nextSignificantParent() {
    let val = this;
    while (val.type.isAnonymous && val._parent) val = val._parent;
    return val;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  toString() {
    return this._tree.toString();
  }
}
function getChildren(node, type, before, after) {
  let cur = node.cursor(),
    result = [];
  if (!cur.firstChild()) return result;
  if (before != null) for (let found = false; !found;) {
    found = cur.type.is(before);
    if (!cur.nextSibling()) return result;
  }
  for (;;) {
    if (after != null && cur.type.is(after)) return result;
    if (cur.type.is(type)) result.push(cur.node);
    if (!cur.nextSibling()) return after == null ? result : [];
  }
}
function matchNodeContext(node, context, i) {
  if (i === void 0) {
    i = context.length - 1;
  }
  for (let p = node; i >= 0; p = p.parent) {
    if (!p) return false;
    if (!p.type.isAnonymous) {
      if (context[i] && context[i] != p.name) return false;
      i--;
    }
  }
  return true;
}
class BufferContext {
  constructor(parent, buffer, index, start) {
    this.parent = parent;
    this.buffer = buffer;
    this.index = index;
    this.start = start;
  }
}
class BufferNode extends BaseNode {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(context, _parent, index) {
    super();
    this.context = context;
    this._parent = _parent;
    this.index = index;
    this.type = context.buffer.set.types[context.buffer.buffer[index]];
  }
  child(dir, pos, side) {
    let {
      buffer
    } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(pos) {
    return this.child(1, pos, 2);
  }
  childBefore(pos) {
    return this.child(-1, pos, -2);
  }
  enter(pos, side, mode) {
    if (mode === void 0) {
      mode = 0;
    }
    if (mode & IterMode.ExcludeBuffers) return null;
    let {
      buffer
    } = this.context;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
    return index < 0 ? null : new BufferNode(this.context, this, index);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(dir) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4);
  }
  get nextSibling() {
    let {
      buffer
    } = this.context;
    let after = buffer.buffer[this.index + 3];
    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);
    return this.externalSibling(1);
  }
  get prevSibling() {
    let {
      buffer
    } = this.context;
    let parentStart = this._parent ? this._parent.index + 4 : 0;
    if (this.index == parentStart) return this.externalSibling(-1);
    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4));
  }
  get tree() {
    return null;
  }
  toTree() {
    let children = [],
      positions = [];
    let {
      buffer
    } = this.context;
    let startI = this.index + 4,
      endI = buffer.buffer[this.index + 3];
    if (endI > startI) {
      let from = buffer.buffer[this.index + 1];
      children.push(buffer.slice(startI, endI, from));
      positions.push(0);
    }
    return new Tree(this.type, children, positions, this.to - this.from);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function iterStack(heads) {
  if (!heads.length) return null;
  let pick = 0,
    picked = heads[0];
  for (let i = 1; i < heads.length; i++) {
    let node = heads[i];
    if (node.from > picked.from || node.to < picked.to) {
      picked = node;
      pick = i;
    }
  }
  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
  let newHeads = heads.slice();
  if (next) newHeads[pick] = next;else newHeads.splice(pick, 1);
  return new StackIterator(newHeads, picked);
}
class StackIterator {
  constructor(heads, node) {
    this.heads = heads;
    this.node = node;
  }
  get next() {
    return iterStack(this.heads);
  }
}
function stackIterator(tree, pos, side) {
  let inner = tree.resolveInner(pos, side),
    layers = null;
  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
    if (scan.index < 0) {
      let parent = scan.parent;
      (layers || (layers = [inner])).push(parent.resolve(pos, side));
      scan = parent;
    } else {
      let mount = MountedTree.get(scan.tree);
      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
      }
    }
  }
  return layers ? iterStack(layers) : inner;
}
class TreeCursor {
  get name() {
    return this.type.name;
  }
  constructor(node, mode) {
    if (mode === void 0) {
      mode = 0;
    }
    this.mode = mode;
    this.buffer = null;
    this.stack = [];
    this.index = 0;
    this.bufferNode = null;
    if (node instanceof TreeNode) {
      this.yieldNode(node);
    } else {
      this._tree = node.context.parent;
      this.buffer = node.context;
      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);
      this.bufferNode = node;
      this.yieldBuf(node.index);
    }
  }
  yieldNode(node) {
    if (!node) return false;
    this._tree = node;
    this.type = node.type;
    this.from = node.from;
    this.to = node.to;
    return true;
  }
  yieldBuf(index, type) {
    this.index = index;
    let {
      start,
      buffer
    } = this.buffer;
    this.type = type || buffer.set.types[buffer.buffer[index]];
    this.from = start + buffer.buffer[index + 1];
    this.to = start + buffer.buffer[index + 2];
    return true;
  }
  yield(node) {
    if (!node) return false;
    if (node instanceof TreeNode) {
      this.buffer = null;
      return this.yieldNode(node);
    }
    this.buffer = node.context;
    return this.yieldBuf(node.index, node.type);
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(dir, pos, side) {
    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
    let {
      buffer
    } = this.buffer;
    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
    if (index < 0) return false;
    this.stack.push(this.index);
    return this.yieldBuf(index);
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(pos) {
    return this.enterChild(1, pos, 2);
  }
  childBefore(pos) {
    return this.enterChild(-1, pos, -2);
  }
  enter(pos, side, mode) {
    if (mode === void 0) {
      mode = this.mode;
    }
    if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));
    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
  }
  parent() {
    if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length) return this.yieldBuf(this.stack.pop());
    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    this.buffer = null;
    return this.yieldNode(parent);
  }
  sibling(dir) {
    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4, this.mode));
    let {
        buffer
      } = this.buffer,
      d = this.stack.length - 1;
    if (dir < 0) {
      let parentStart = d < 0 ? 0 : this.stack[d] + 4;
      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4));
    } else {
      let after = buffer.buffer[this.index + 3];
      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);
    }
    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4, this.mode)) : false;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(dir) {
    let index,
      parent,
      {
        buffer
      } = this;
    if (buffer) {
      if (dir > 0) {
        if (this.index < buffer.buffer.buffer.length) return false;
      } else {
        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;
      }
      ({
        index,
        parent
      } = buffer);
    } else {
      ({
        index,
        _parent: parent
      } = this._tree);
    }
    for (; parent; {
      index,
      _parent: parent
    } = parent) {
      if (index > -1) for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
        let child = parent._tree.children[i];
        if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;
      }
    }
    return true;
  }
  move(dir, enter) {
    if (enter && this.enterChild(dir, 0, 4)) return true;
    for (;;) {
      if (this.sibling(dir)) return true;
      if (this.atLastNode(dir) || !this.parent()) return false;
    }
  }
  next(enter) {
    if (enter === void 0) {
      enter = true;
    }
    return this.move(1, enter);
  }
  prev(enter) {
    if (enter === void 0) {
      enter = true;
    }
    return this.move(-1, enter);
  }
  moveTo(pos, side) {
    if (side === void 0) {
      side = 0;
    }
    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;
    while (this.enterChild(1, pos, side)) {}
    return this;
  }
  get node() {
    if (!this.buffer) return this._tree;
    let cache = this.bufferNode,
      result = null,
      depth = 0;
    if (cache && cache.context == this.buffer) {
      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
        for (let c = cache; c; c = c._parent) if (c.index == index) {
          if (index == this.index) return c;
          result = c;
          depth = d + 1;
          break scan;
        }
        index = this.stack[--d];
      }
    }
    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);
    return this.bufferNode = new BufferNode(this.buffer, result, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(enter, leave) {
    for (let depth = 0;;) {
      let mustLeave = false;
      if (this.type.isAnonymous || enter(this) !== false) {
        if (this.firstChild()) {
          depth++;
          continue;
        }
        if (!this.type.isAnonymous) mustLeave = true;
      }
      for (;;) {
        if (mustLeave && leave) leave(this);
        mustLeave = this.type.isAnonymous;
        if (!depth) return;
        if (this.nextSibling()) break;
        this.parent();
        depth--;
        mustLeave = true;
      }
    }
  }
  matchContext(context) {
    if (!this.buffer) return matchNodeContext(this.node.parent, context);
    let {
        buffer
      } = this.buffer,
      {
        types
      } = buffer.set;
    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
      if (d < 0) return matchNodeContext(this._tree, context, i);
      let type = types[buffer.buffer[this.stack[d]]];
      if (!type.isAnonymous) {
        if (context[i] && context[i] != type.name) return false;
        i--;
      }
    }
    return true;
  }
}
function hasChild(tree) {
  return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
  var _a;
  let {
    buffer,
    nodeSet,
    maxBufferLength = DefaultBufferLength,
    reused = [],
    minRepeatType = nodeSet.types.length
  } = data;
  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
  let types = nodeSet.types;
  let contextHash = 0,
    lookAhead = 0;
  function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {
    let {
      id,
      start,
      end,
      size
    } = cursor;
    let lookAheadAtStart = lookAhead,
      contextAtStart = contextHash;
    while (size < 0) {
      cursor.next();
      if (size == -1) {
        let node = reused[id];
        children.push(node);
        positions.push(start - parentStart);
        return;
      } else if (size == -3) {
        contextHash = id;
        return;
      } else if (size == -4) {
        lookAhead = id;
        return;
      } else {
        throw new RangeError(`Unrecognized record size: ${size}`);
      }
    }
    let type = types[id],
      node,
      buffer;
    let startPos = start - parentStart;
    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
      let data = new Uint16Array(buffer.size - buffer.skip);
      let endPos = cursor.pos - buffer.size,
        index = data.length;
      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index);
      node = new TreeBuffer(data, end - buffer.start, nodeSet);
      startPos = buffer.start - parentStart;
    } else {
      let endPos = cursor.pos - size;
      cursor.next();
      let localChildren = [],
        localPositions = [];
      let localInRepeat = id >= minRepeatType ? id : -1;
      let lastGroup = 0,
        lastEnd = end;
      while (cursor.pos > endPos) {
        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
          if (cursor.end <= lastEnd - maxBufferLength) {
            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
            lastGroup = localChildren.length;
            lastEnd = cursor.end;
          }
          cursor.next();
        } else if (depth > 2500) {
          takeFlatNode(start, endPos, localChildren, localPositions);
        } else {
          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
        }
      }
      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart, contextAtStart);
      localChildren.reverse();
      localPositions.reverse();
      if (localInRepeat > -1 && lastGroup > 0) {
        let make = makeBalanced(type, contextAtStart);
        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
      } else {
        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end, contextAtStart);
      }
    }
    children.push(node);
    positions.push(startPos);
  }
  function takeFlatNode(parentStart, minPos, children, positions) {
    let nodes = [];
    let nodeCount = 0,
      stopAt = -1;
    while (cursor.pos > minPos) {
      let {
        id,
        start,
        end,
        size
      } = cursor;
      if (size > 4) {
        cursor.next();
      } else if (stopAt > -1 && start < stopAt) {
        break;
      } else {
        if (stopAt < 0) stopAt = end - maxBufferLength;
        nodes.push(id, start, end);
        nodeCount++;
        cursor.next();
      }
    }
    if (nodeCount) {
      let buffer = new Uint16Array(nodeCount * 4);
      let start = nodes[nodes.length - 2];
      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
        buffer[j++] = nodes[i];
        buffer[j++] = nodes[i + 1] - start;
        buffer[j++] = nodes[i + 2] - start;
        buffer[j++] = j;
      }
      children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));
      positions.push(start - parentStart);
    }
  }
  function makeBalanced(type, contextHash) {
    return (children, positions, length) => {
      let lookAhead = 0,
        lastI = children.length - 1,
        last,
        lookAheadProp;
      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {
        if (!lastI && last.type == type && last.length == length) return last;
        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;
      }
      return makeTree(type, children, positions, length, lookAhead, contextHash);
    };
  }
  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead, contextHash) {
    let localChildren = [],
      localPositions = [];
    while (children.length > i) {
      localChildren.push(children.pop());
      localPositions.push(positions.pop() + base - from);
    }
    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to, contextHash));
    positions.push(from - base);
  }
  function makeTree(type, children, positions, length, lookAhead, contextHash, props) {
    if (contextHash) {
      let pair = [NodeProp.contextHash, contextHash];
      props = props ? [pair].concat(props) : [pair];
    }
    if (lookAhead > 25) {
      let pair = [NodeProp.lookAhead, lookAhead];
      props = props ? [pair].concat(props) : [pair];
    }
    return new Tree(type, children, positions, length, props);
  }
  function findBufferSize(maxSize, inRepeat) {
    let fork = cursor.fork();
    let size = 0,
      start = 0,
      skip = 0,
      minStart = fork.end - maxBufferLength;
    let result = {
      size: 0,
      start: 0,
      skip: 0
    };
    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
      let nodeSize = fork.size;
      if (fork.id == inRepeat && nodeSize >= 0) {
        result.size = size;
        result.start = start;
        result.skip = skip;
        skip += 4;
        size += 4;
        fork.next();
        continue;
      }
      let startPos = fork.pos - nodeSize;
      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;
      let localSkipped = fork.id >= minRepeatType ? 4 : 0;
      let nodeStart = fork.start;
      fork.next();
      while (fork.pos > startPos) {
        if (fork.size < 0) {
          if (fork.size == -3) localSkipped += 4;else break scan;
        } else if (fork.id >= minRepeatType) {
          localSkipped += 4;
        }
        fork.next();
      }
      start = nodeStart;
      size += nodeSize;
      skip += localSkipped;
    }
    if (inRepeat < 0 || size == maxSize) {
      result.size = size;
      result.start = start;
      result.skip = skip;
    }
    return result.size > 4 ? result : undefined;
  }
  function copyToBuffer(bufferStart, buffer, index) {
    let {
      id,
      start,
      end,
      size
    } = cursor;
    cursor.next();
    if (size >= 0 && id < minRepeatType) {
      let startIndex = index;
      if (size > 4) {
        let endPos = cursor.pos - (size - 4);
        while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);
      }
      buffer[--index] = startIndex;
      buffer[--index] = end - bufferStart;
      buffer[--index] = start - bufferStart;
      buffer[--index] = id;
    } else if (size == -3) {
      contextHash = id;
    } else if (size == -4) {
      lookAhead = id;
    }
    return index;
  }
  let children = [],
    positions = [];
  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;
  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap();
function nodeSize(balanceType, node) {
  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;
  let size = nodeSizeCache.get(node);
  if (size == null) {
    size = 1;
    for (var _iterator8 = _createForOfIteratorHelperLoose(node.children), _step8; !(_step8 = _iterator8()).done;) {
      let child = _step8.value;
      if (child.type != balanceType || !(child instanceof Tree)) {
        size = 1;
        break;
      }
      size += nodeSize(balanceType, child);
    }
    nodeSizeCache.set(node, size);
  }
  return size;
}
function balanceRange(balanceType, children, positions, from, to, start, length, mkTop, mkTree) {
  let total = 0;
  for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i]);
  let maxChild = Math.ceil(total * 1.5 / 8);
  let localChildren = [],
    localPositions = [];
  function divide(children, positions, from, to, offset) {
    for (let i = from; i < to;) {
      let groupFrom = i,
        groupStart = positions[i],
        groupSize = nodeSize(balanceType, children[i]);
      i++;
      for (; i < to; i++) {
        let nextSize = nodeSize(balanceType, children[i]);
        if (groupSize + nextSize >= maxChild) break;
        groupSize += nextSize;
      }
      if (i == groupFrom + 1) {
        if (groupSize > maxChild) {
          let only = children[groupFrom];
          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
          continue;
        }
        localChildren.push(children[groupFrom]);
      } else {
        let length = positions[i - 1] + children[i - 1].length - groupStart;
        localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
      }
      localPositions.push(groupStart + offset - start);
    }
  }
  divide(children, positions, from, to, 0);
  return (mkTop || mkTree)(localChildren, localPositions, length);
}
class NodeWeakMap {
  constructor() {
    this.map = new WeakMap();
  }
  setBuffer(buffer, index, value) {
    let inner = this.map.get(buffer);
    if (!inner) this.map.set(buffer, inner = new Map());
    inner.set(index, value);
  }
  getBuffer(buffer, index) {
    let inner = this.map.get(buffer);
    return inner && inner.get(index);
  }
  set(node, value) {
    if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);else if (node instanceof TreeNode) this.map.set(node.tree, value);
  }
  get(node) {
    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
  }
  cursorSet(cursor, value) {
    if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);else this.map.set(cursor.tree, value);
  }
  cursorGet(cursor) {
    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
  }
}
class TreeFragment {
  constructor(from, to, tree, offset, openStart, openEnd) {
    if (openStart === void 0) {
      openStart = false;
    }
    if (openEnd === void 0) {
      openEnd = false;
    }
    this.from = from;
    this.to = to;
    this.tree = tree;
    this.offset = offset;
    this.open = (openStart ? 1 : 0) | (openEnd ? 2 : 0);
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(tree, fragments, partial) {
    if (fragments === void 0) {
      fragments = [];
    }
    if (partial === void 0) {
      partial = false;
    }
    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
    for (var _iterator9 = _createForOfIteratorHelperLoose(fragments), _step9; !(_step9 = _iterator9()).done;) {
      let f = _step9.value;
      if (f.to > tree.length) result.push(f);
    }
    return result;
  }
  static applyChanges(fragments, changes, minGap) {
    if (minGap === void 0) {
      minGap = 128;
    }
    if (!changes.length) return fragments;
    let result = [];
    let fI = 1,
      nextF = fragments.length ? fragments[0] : null;
    for (let cI = 0, pos = 0, off = 0;; cI++) {
      let nextC = cI < changes.length ? changes[cI] : null;
      let nextPos = nextC ? nextC.fromA : 1e9;
      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {
        let cut = nextF;
        if (pos >= cut.from || nextPos <= cut.to || off) {
          let fFrom = Math.max(cut.from, pos) - off,
            fTo = Math.min(cut.to, nextPos) - off;
          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
        }
        if (cut) result.push(cut);
        if (nextF.to > nextPos) break;
        nextF = fI < fragments.length ? fragments[fI++] : null;
      }
      if (!nextC) break;
      pos = nextC.toA;
      off = nextC.toA - nextC.toB;
    }
    return result;
  }
}
class Parser {
  startParse(input, fragments, ranges) {
    if (typeof input == "string") input = new StringInput(input);
    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];
    return this.createParse(input, fragments || [], ranges);
  }
  parse(input, fragments, ranges) {
    let parse = this.startParse(input, fragments, ranges);
    for (;;) {
      let done = parse.advance();
      if (done) return done;
    }
  }
}
class StringInput {
  constructor(string) {
    this.string = string;
  }
  get length() {
    return this.string.length;
  }
  chunk(from) {
    return this.string.slice(from);
  }
  get lineChunks() {
    return false;
  }
  read(from, to) {
    return this.string.slice(from, to);
  }
}
function parseMixed(nest) {
  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
  constructor(parser, parse, overlay, target, from) {
    this.parser = parser;
    this.parse = parse;
    this.overlay = overlay;
    this.target = target;
    this.from = from;
  }
}
function checkRanges(ranges) {
  if (!ranges.length || ranges.some(r => r.from >= r.to)) throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
class ActiveOverlay {
  constructor(parser, predicate, mounts, index, start, target, prev) {
    this.parser = parser;
    this.predicate = predicate;
    this.mounts = mounts;
    this.index = index;
    this.start = start;
    this.target = target;
    this.prev = prev;
    this.depth = 0;
    this.ranges = [];
  }
}
const stoppedInner = new NodeProp({
  perNode: true
});
class MixedParse {
  constructor(base, nest, input, fragments, ranges) {
    this.nest = nest;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges;
    this.inner = [];
    this.innerDone = 0;
    this.baseTree = null;
    this.stoppedAt = null;
    this.baseParse = base;
  }
  advance() {
    if (this.baseParse) {
      let done = this.baseParse.advance();
      if (!done) return null;
      this.baseParse = null;
      this.baseTree = done;
      this.startInner();
      if (this.stoppedAt != null) {
        for (var _iterator10 = _createForOfIteratorHelperLoose(this.inner), _step10; !(_step10 = _iterator10()).done;) {
          let inner = _step10.value;
          inner.parse.stopAt(this.stoppedAt);
        }
      }
    }
    if (this.innerDone == this.inner.length) {
      let result = this.baseTree;
      if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
      return result;
    }
    let inner = this.inner[this.innerDone],
      done = inner.parse.advance();
    if (done) {
      this.innerDone++;
      let props = Object.assign(Object.create(null), inner.target.props);
      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
      inner.target.props = props;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse) return 0;
    let pos = this.input.length;
    for (let i = this.innerDone; i < this.inner.length; i++) {
      if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);
    }
    return pos;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
    if (this.baseParse) this.baseParse.stopAt(pos);else for (let i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos);
  }
  startInner() {
    let fragmentCursor = new FragmentCursor(this.fragments);
    let overlay = null;
    let covered = null;
    let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    scan: for (let nest, isCovered;;) {
      let enter = true,
        range;
      if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {
        enter = false;
      } else if (fragmentCursor.hasNode(cursor)) {
        if (overlay) {
          let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
          if (match) {
            for (var _iterator11 = _createForOfIteratorHelperLoose(match.mount.overlay), _step11; !(_step11 = _iterator11()).done;) {
              let r = _step11.value;
              let from = r.from + match.pos,
                to = r.to + match.pos;
              if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from)) overlay.ranges.push({
                from,
                to
              });
            }
          }
        }
        enter = false;
      } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
        enter = isCovered != 2;
      } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {
        if (!cursor.tree) materialize(cursor);
        let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
        if (typeof nest.overlay == "function") {
          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
        } else {
          let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));
          if (ranges.length) checkRanges(ranges);
          if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(""), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));
          if (!nest.overlay) enter = false;else if (ranges.length) covered = {
            ranges,
            depth: 0,
            prev: covered
          };
        }
      } else if (overlay && (range = overlay.predicate(cursor))) {
        if (range === true) range = new Range(cursor.from, cursor.to);
        if (range.from < range.to) {
          let last = overlay.ranges.length - 1;
          if (last >= 0 && overlay.ranges[last].to == range.from) overlay.ranges[last] = {
            from: overlay.ranges[last].from,
            to: range.to
          };else overlay.ranges.push(range);
        }
      }
      if (enter && cursor.firstChild()) {
        if (overlay) overlay.depth++;
        if (covered) covered.depth++;
      } else {
        for (;;) {
          if (cursor.nextSibling()) break;
          if (!cursor.parent()) break scan;
          if (overlay && ! --overlay.depth) {
            let ranges = punchRanges(this.ranges, overlay.ranges);
            if (ranges.length) {
              checkRanges(ranges);
              this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));
            }
            overlay = overlay.prev;
          }
          if (covered && ! --covered.depth) covered = covered.prev;
        }
      }
    }
  }
}
function checkCover(covered, from, to) {
  for (var _iterator12 = _createForOfIteratorHelperLoose(covered), _step12; !(_step12 = _iterator12()).done;) {
    let range = _step12.value;
    if (range.from >= to) break;
    if (range.to > from) return range.from <= from && range.to >= to ? 2 : 1;
  }
  return 0;
}
function sliceBuf(buf, startI, endI, nodes, positions, off) {
  if (startI < endI) {
    let from = buf.buffer[startI + 1];
    nodes.push(buf.slice(startI, endI, from));
    positions.push(from - off);
  }
}
function materialize(cursor) {
  let {
      node
    } = cursor,
    stack = [];
  let buffer = node.context.buffer;
  do {
    stack.push(cursor.index);
    cursor.parent();
  } while (!cursor.tree);
  let base = cursor.tree,
    i = base.children.indexOf(buffer);
  let buf = base.children[i],
    b = buf.buffer,
    newStack = [i];
  function split(startI, endI, type, innerOffset, length, stackPos) {
    let targetI = stack[stackPos];
    let children = [],
      positions = [];
    sliceBuf(buf, startI, targetI, children, positions, innerOffset);
    let from = b[targetI + 1],
      to = b[targetI + 2];
    newStack.push(children.length);
    let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();
    children.push(child);
    positions.push(from - innerOffset);
    sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
    return new Tree(type, children, positions, length);
  }
  base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);
  for (var _i = 0, _newStack = newStack; _i < _newStack.length; _i++) {
    let index = _newStack[_i];
    let tree = cursor.tree.children[index],
      pos = cursor.tree.positions[index];
    cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));
  }
}
class StructureCursor {
  constructor(root, offset) {
    this.offset = offset;
    this.done = false;
    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
  }
  moveTo(pos) {
    let {
        cursor
      } = this,
      p = pos - this.offset;
    while (!this.done && cursor.from < p) {
      if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;else if (!cursor.next(false)) this.done = true;
    }
  }
  hasNode(cursor) {
    this.moveTo(cursor.from);
    if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
      for (let tree = this.cursor.tree;;) {
        if (tree == cursor.tree) return true;
        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;
      }
    }
    return false;
  }
}
class FragmentCursor {
  constructor(fragments) {
    var _a;
    this.fragments = fragments;
    this.curTo = 0;
    this.fragI = 0;
    if (fragments.length) {
      let first = this.curFrag = fragments[0];
      this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
      this.inner = new StructureCursor(first.tree, -first.offset);
    } else {
      this.curFrag = this.inner = null;
    }
  }
  hasNode(node) {
    while (this.curFrag && node.from >= this.curTo) this.nextFrag();
    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
  }
  nextFrag() {
    var _a;
    this.fragI++;
    if (this.fragI == this.fragments.length) {
      this.curFrag = this.inner = null;
    } else {
      let frag = this.curFrag = this.fragments[this.fragI];
      this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
      this.inner = new StructureCursor(frag.tree, -frag.offset);
    }
  }
  findMounts(pos, parser) {
    var _a;
    let result = [];
    if (this.inner) {
      this.inner.cursor.moveTo(pos, 1);
      for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
        let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);
        if (mount && mount.parser == parser) {
          for (let i = this.fragI; i < this.fragments.length; i++) {
            let frag = this.fragments[i];
            if (frag.from >= pos.to) break;
            if (frag.tree == this.curFrag.tree) result.push({
              frag,
              pos: pos.from - frag.offset,
              mount
            });
          }
        }
      }
    }
    return result;
  }
}
function punchRanges(outer, ranges) {
  let copy = null,
    current = ranges;
  for (let i = 1, j = 0; i < outer.length; i++) {
    let gapFrom = outer[i - 1].to,
      gapTo = outer[i].from;
    for (; j < current.length; j++) {
      let r = current[j];
      if (r.from >= gapTo) break;
      if (r.to <= gapFrom) continue;
      if (!copy) current = copy = ranges.slice();
      if (r.from < gapFrom) {
        copy[j] = new Range(r.from, gapFrom);
        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));
      } else if (r.to > gapTo) {
        copy[j--] = new Range(gapTo, r.to);
      } else {
        copy.splice(j--, 1);
      }
    }
  }
  return current;
}
function findCoverChanges(a, b, from, to) {
  let iA = 0,
    iB = 0,
    inA = false,
    inB = false,
    pos = -1e9;
  let result = [];
  for (;;) {
    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
    if (inA != inB) {
      let start = Math.max(pos, from),
        end = Math.min(nextA, nextB, to);
      if (start < end) result.push(new Range(start, end));
    }
    pos = Math.min(nextA, nextB);
    if (pos == 1e9) break;
    if (nextA == pos) {
      if (!inA) inA = true;else {
        inA = false;
        iA++;
      }
    }
    if (nextB == pos) {
      if (!inB) inB = true;else {
        inB = false;
        iB++;
      }
    }
  }
  return result;
}
function enterFragments(mounts, ranges) {
  let result = [];
  for (var _iterator13 = _createForOfIteratorHelperLoose(mounts), _step13; !(_step13 = _iterator13()).done;) {
    let {
      pos,
      mount,
      frag
    } = _step13.value;
    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),
      endPos = startPos + mount.tree.length;
    let from = Math.max(frag.from, startPos),
      to = Math.min(frag.to, endPos);
    if (mount.overlay) {
      let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));
      let changes = findCoverChanges(ranges, overlay, from, to);
      for (let i = 0, pos = from;; i++) {
        let last = i == changes.length,
          end = last ? to : changes[i].from;
        if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));
        if (last) break;
        pos = changes[i].to;
      }
    } else {
      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
    }
  }
  return result;
}


/***/ }),

/***/ 540:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ 805:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Light-webfont.ttf";

/***/ }),

/***/ 850:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5072);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7825);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7659);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5056);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(540);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1113);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_sass_loader_dist_cjs_js_ami_scss__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7399);

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_sass_loader_dist_cjs_js_ami_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A, options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_sass_loader_dist_cjs_js_ami_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A && _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_sass_loader_dist_cjs_js_ami_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals ? _node_modules_css_loader_dist_cjs_js_node_modules_postcss_loader_dist_cjs_js_ruleSet_1_rules_5_use_2_node_modules_sass_loader_dist_cjs_js_ami_scss__WEBPACK_IMPORTED_MODULE_6__/* ["default"] */ .A.locals : undefined);


/***/ }),

/***/ 1001:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  YH: () => (/* binding */ Annotation),
  Gu: () => (/* binding */ ChangeDesc),
  VR: () => (/* binding */ ChangeSet),
  Je: () => (/* binding */ CharCategory),
  xx: () => (/* binding */ Compartment),
  OF: () => (/* binding */ EditorSelection),
  $t: () => (/* binding */ EditorState),
  sj: () => (/* binding */ Facet),
  iR: () => (/* binding */ MapMode),
  Nb: () => (/* binding */ Prec),
  om: () => (/* binding */ RangeSet),
  vB: () => (/* binding */ RangeSetBuilder),
  FB: () => (/* binding */ RangeValue),
  Pe: () => (/* binding */ StateEffect),
  sU: () => (/* binding */ StateField),
  EY: () => (/* binding */ Text),
  ZX: () => (/* binding */ Transaction),
  vS: () => (/* binding */ dist_codePointAt),
  Fh: () => (/* binding */ dist_codePointSize),
  QR: () => (/* binding */ combineConfig),
  y$: () => (/* binding */ countColumn),
  zK: () => (/* binding */ dist_findClusterBreak),
  kn: () => (/* binding */ findColumn),
  MK: () => (/* binding */ fromCodePoint)
});

// UNUSED EXPORTS: AnnotationType, Line, Range, SelectionRange, StateEffectType

;// ./node_modules/@marijn/find-cluster-break/src/index.js
let rangeFrom = [],
  rangeTo = [];
(() => {
  let numbers = "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
  for (let i = 0, n = 0; i < numbers.length; i++) (i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i]);
})();
function isExtendingChar(code) {
  if (code < 768) return false;
  for (let from = 0, to = rangeFrom.length;;) {
    let mid = from + to >> 1;
    if (code < rangeFrom[mid]) to = mid;else if (code >= rangeTo[mid]) from = mid + 1;else return true;
    if (from == to) return false;
  }
}
function isRegionalIndicator(code) {
  return code >= 0x1F1E6 && code <= 0x1F1FF;
}
function check(code) {
  for (let i = 0; i < rangeFrom.length; i++) {
    if (rangeTo[i] > code) return rangeFrom[i] <= code;
  }
  return false;
}
const ZWJ = 0x200d;
function findClusterBreak(str, pos, forward, includeExtending) {
  if (forward === void 0) {
    forward = true;
  }
  if (includeExtending === void 0) {
    includeExtending = true;
  }
  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
  if (pos == str.length) return pos;
  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;
  let prev = codePointAt(str, pos);
  pos += codePointSize(prev);
  while (pos < str.length) {
    let next = codePointAt(str, pos);
    if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
      pos += codePointSize(next);
      prev = next;
    } else if (isRegionalIndicator(next)) {
      let countBefore = 0,
        i = pos - 2;
      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
        countBefore++;
        i -= 2;
      }
      if (countBefore % 2 == 0) break;else pos += 2;
    } else {
      break;
    }
  }
  return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
  while (pos > 0) {
    let found = nextClusterBreak(str, pos - 2, includeExtending);
    if (found < pos) return found;
    pos--;
  }
  return 0;
}
function codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!surrogateLow(code1)) return code0;
  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;
}
function surrogateLow(ch) {
  return ch >= 0xDC00 && ch < 0xE000;
}
function surrogateHigh(ch) {
  return ch >= 0xD800 && ch < 0xDC00;
}
function codePointSize(code) {
  return code < 0x10000 ? 1 : 2;
}
;// ./node_modules/@codemirror/state/dist/index.js
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

class Text {
  lineAt(pos) {
    if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
    return this.lineInner(pos, false, 1, 0);
  }
  line(n) {
    if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
    return this.lineInner(n, true, 1, 0);
  }
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(0, from, parts, 2);
    if (text.length) text.decompose(0, text.length, parts, 1 | 2);
    this.decompose(to, this.length, parts, 1);
    return TextNode.from(parts, this.length - (to - from) + text.length);
  }
  append(other) {
    return this.replace(this.length, this.length, other);
  }
  slice(from, to) {
    if (to === void 0) {
      to = this.length;
    }
    [from, to] = clip(this, from, to);
    let parts = [];
    this.decompose(from, to, parts, 0);
    return TextNode.from(parts, to - from);
  }
  eq(other) {
    if (other == this) return true;
    if (other.length != this.length || other.lines != this.lines) return false;
    let start = this.scanIdentical(other, 1),
      end = this.length - this.scanIdentical(other, -1);
    let a = new RawTextCursor(this),
      b = new RawTextCursor(other);
    for (let skip = start, pos = start;;) {
      a.next(skip);
      b.next(skip);
      skip = 0;
      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;
      pos += a.value.length;
      if (a.done || pos >= end) return true;
    }
  }
  iter(dir) {
    if (dir === void 0) {
      dir = 1;
    }
    return new RawTextCursor(this, dir);
  }
  iterRange(from, to) {
    if (to === void 0) {
      to = this.length;
    }
    return new PartialTextCursor(this, from, to);
  }
  iterLines(from, to) {
    let inner;
    if (from == null) {
      inner = this.iter();
    } else {
      if (to == null) to = this.lines + 1;
      let start = this.line(from).from;
      inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
    }
    return new LineCursor(inner);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let lines = [];
    this.flatten(lines);
    return lines;
  }
  constructor() {}
  static of(text) {
    if (text.length == 0) throw new RangeError("A document must have at least one line");
    if (text.length == 1 && !text[0]) return Text.empty;
    return text.length <= 32 ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
  }
}
class TextLeaf extends Text {
  constructor(text, length) {
    if (length === void 0) {
      length = textLength(text);
    }
    super();
    this.text = text;
    this.length = length;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0;; i++) {
      let string = this.text[i],
        end = offset + string.length;
      if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);
      offset = end + 1;
      line++;
    }
  }
  decompose(from, to, target, open) {
    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
    if (open & 1) {
      let prev = target.pop();
      let joined = appendText(text.text, prev.text.slice(), 0, text.length);
      if (joined.length <= 32) {
        target.push(new TextLeaf(joined, prev.length + text.length));
      } else {
        let mid = joined.length >> 1;
        target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
      }
    } else {
      target.push(text);
    }
  }
  replace(from, to, text) {
    if (!(text instanceof TextLeaf)) return super.replace(from, to, text);
    [from, to] = clip(this, from, to);
    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
    let newLen = this.length + text.length - (to - from);
    if (lines.length <= 32) return new TextLeaf(lines, newLen);
    return TextNode.from(TextLeaf.split(lines, []), newLen);
  }
  sliceString(from, to, lineSep) {
    if (to === void 0) {
      to = this.length;
    }
    if (lineSep === void 0) {
      lineSep = "\n";
    }
    [from, to] = clip(this, from, to);
    let result = "";
    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
      let line = this.text[i],
        end = pos + line.length;
      if (pos > from && i) result += lineSep;
      if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (var _iterator = _createForOfIteratorHelperLoose(this.text), _step; !(_step = _iterator()).done;) {
      let line = _step.value;
      target.push(line);
    }
  }
  scanIdentical() {
    return 0;
  }
  static split(text, target) {
    let part = [],
      len = -1;
    for (var _iterator2 = _createForOfIteratorHelperLoose(text), _step2; !(_step2 = _iterator2()).done;) {
      let line = _step2.value;
      part.push(line);
      len += line.length + 1;
      if (part.length == 32) {
        target.push(new TextLeaf(part, len));
        part = [];
        len = -1;
      }
    }
    if (len > -1) target.push(new TextLeaf(part, len));
    return target;
  }
}
class TextNode extends Text {
  constructor(children, length) {
    super();
    this.children = children;
    this.length = length;
    this.lines = 0;
    for (var _iterator3 = _createForOfIteratorHelperLoose(children), _step3; !(_step3 = _iterator3()).done;) {
      let child = _step3.value;
      this.lines += child.lines;
    }
  }
  lineInner(target, isLine, line, offset) {
    for (let i = 0;; i++) {
      let child = this.children[i],
        end = offset + child.length,
        endLine = line + child.lines - 1;
      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);
      offset = end + 1;
      line = endLine + 1;
    }
  }
  decompose(from, to, target, open) {
    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
      let child = this.children[i],
        end = pos + child.length;
      if (from <= end && to >= pos) {
        let childOpen = open & ((pos <= from ? 1 : 0) | (end >= to ? 2 : 0));
        if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);
      }
      pos = end + 1;
    }
  }
  replace(from, to, text) {
    [from, to] = clip(this, from, to);
    if (text.lines < this.lines) for (let i = 0, pos = 0; i < this.children.length; i++) {
      let child = this.children[i],
        end = pos + child.length;
      if (from >= pos && to <= end) {
        let updated = child.replace(from - pos, to - pos, text);
        let totalLines = this.lines - child.lines + updated.lines;
        if (updated.lines < totalLines >> 5 - 1 && updated.lines > totalLines >> 5 + 1) {
          let copy = this.children.slice();
          copy[i] = updated;
          return new TextNode(copy, this.length - (to - from) + text.length);
        }
        return super.replace(pos, end, updated);
      }
      pos = end + 1;
    }
    return super.replace(from, to, text);
  }
  sliceString(from, to, lineSep) {
    if (to === void 0) {
      to = this.length;
    }
    if (lineSep === void 0) {
      lineSep = "\n";
    }
    [from, to] = clip(this, from, to);
    let result = "";
    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
      let child = this.children[i],
        end = pos + child.length;
      if (pos > from && i) result += lineSep;
      if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);
      pos = end + 1;
    }
    return result;
  }
  flatten(target) {
    for (var _iterator4 = _createForOfIteratorHelperLoose(this.children), _step4; !(_step4 = _iterator4()).done;) {
      let child = _step4.value;
      child.flatten(target);
    }
  }
  scanIdentical(other, dir) {
    if (!(other instanceof TextNode)) return 0;
    let length = 0;
    let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length] : [this.children.length - 1, other.children.length - 1, -1, -1];
    for (;; iA += dir, iB += dir) {
      if (iA == eA || iB == eB) return length;
      let chA = this.children[iA],
        chB = other.children[iB];
      if (chA != chB) return length + chA.scanIdentical(chB, dir);
      length += chA.length + 1;
    }
  }
  static from(children, length) {
    if (length === void 0) {
      length = children.reduce((l, ch) => l + ch.length + 1, -1);
    }
    let lines = 0;
    for (var _iterator5 = _createForOfIteratorHelperLoose(children), _step5; !(_step5 = _iterator5()).done;) {
      let ch = _step5.value;
      lines += ch.lines;
    }
    if (lines < 32) {
      let flat = [];
      for (var _iterator6 = _createForOfIteratorHelperLoose(children), _step6; !(_step6 = _iterator6()).done;) {
        let ch = _step6.value;
        ch.flatten(flat);
      }
      return new TextLeaf(flat, length);
    }
    let chunk = Math.max(32, lines >> 5),
      maxChunk = chunk << 1,
      minChunk = chunk >> 1;
    let chunked = [],
      currentLines = 0,
      currentLen = -1,
      currentChunk = [];
    function add(child) {
      let last;
      if (child.lines > maxChunk && child instanceof TextNode) {
        for (var _iterator7 = _createForOfIteratorHelperLoose(child.children), _step7; !(_step7 = _iterator7()).done;) {
          let node = _step7.value;
          add(node);
        }
      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
        flush();
        chunked.push(child);
      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32) {
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
      } else {
        if (currentLines + child.lines > chunk) flush();
        currentLines += child.lines;
        currentLen += child.length + 1;
        currentChunk.push(child);
      }
    }
    function flush() {
      if (currentLines == 0) return;
      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
      currentLen = -1;
      currentLines = currentChunk.length = 0;
    }
    for (var _iterator8 = _createForOfIteratorHelperLoose(children), _step8; !(_step8 = _iterator8()).done;) {
      let child = _step8.value;
      add(child);
    }
    flush();
    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
  }
}
Text.empty = new TextLeaf([""], 0);
function textLength(text) {
  let length = -1;
  for (var _iterator9 = _createForOfIteratorHelperLoose(text), _step9; !(_step9 = _iterator9()).done;) {
    let line = _step9.value;
    length += line.length + 1;
  }
  return length;
}
function appendText(text, target, from, to) {
  if (from === void 0) {
    from = 0;
  }
  if (to === void 0) {
    to = 1e9;
  }
  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
    let line = text[i],
      end = pos + line.length;
    if (end >= from) {
      if (end > to) line = line.slice(0, to - pos);
      if (pos < from) line = line.slice(from - pos);
      if (first) {
        target[target.length - 1] += line;
        first = false;
      } else target.push(line);
    }
    pos = end + 1;
  }
  return target;
}
function sliceText(text, from, to) {
  return appendText(text, [""], from, to);
}
class RawTextCursor {
  constructor(text, dir) {
    if (dir === void 0) {
      dir = 1;
    }
    this.dir = dir;
    this.done = false;
    this.lineBreak = false;
    this.value = "";
    this.nodes = [text];
    this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
  }
  nextInner(skip, dir) {
    this.done = this.lineBreak = false;
    for (;;) {
      let last = this.nodes.length - 1;
      let top = this.nodes[last],
        offsetValue = this.offsets[last],
        offset = offsetValue >> 1;
      let size = top instanceof TextLeaf ? top.text.length : top.children.length;
      if (offset == (dir > 0 ? size : 0)) {
        if (last == 0) {
          this.done = true;
          this.value = "";
          return this;
        }
        if (dir > 0) this.offsets[last - 1]++;
        this.nodes.pop();
        this.offsets.pop();
      } else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
        this.offsets[last] += dir;
        if (skip == 0) {
          this.lineBreak = true;
          this.value = "\n";
          return this;
        }
        skip--;
      } else if (top instanceof TextLeaf) {
        let next = top.text[offset + (dir < 0 ? -1 : 0)];
        this.offsets[last] += dir;
        if (next.length > Math.max(0, skip)) {
          this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
          return this;
        }
        skip -= next.length;
      } else {
        let next = top.children[offset + (dir < 0 ? -1 : 0)];
        if (skip > next.length) {
          skip -= next.length;
          this.offsets[last] += dir;
        } else {
          if (dir < 0) this.offsets[last]--;
          this.nodes.push(next);
          this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
        }
      }
    }
  }
  next(skip) {
    if (skip === void 0) {
      skip = 0;
    }
    if (skip < 0) {
      this.nextInner(-skip, -this.dir);
      skip = this.value.length;
    }
    return this.nextInner(skip, this.dir);
  }
}
class PartialTextCursor {
  constructor(text, start, end) {
    this.value = "";
    this.done = false;
    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
    this.pos = start > end ? text.length : 0;
    this.from = Math.min(start, end);
    this.to = Math.max(start, end);
  }
  nextInner(skip, dir) {
    if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
      this.value = "";
      this.done = true;
      return this;
    }
    skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
    let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
    if (skip > limit) skip = limit;
    limit -= skip;
    let {
      value
    } = this.cursor.next(skip);
    this.pos += (value.length + skip) * dir;
    this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
    this.done = !this.value;
    return this;
  }
  next(skip) {
    if (skip === void 0) {
      skip = 0;
    }
    if (skip < 0) skip = Math.max(skip, this.from - this.pos);else if (skip > 0) skip = Math.min(skip, this.to - this.pos);
    return this.nextInner(skip, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class LineCursor {
  constructor(inner) {
    this.inner = inner;
    this.afterBreak = true;
    this.value = "";
    this.done = false;
  }
  next(skip) {
    if (skip === void 0) {
      skip = 0;
    }
    let {
      done,
      lineBreak,
      value
    } = this.inner.next(skip);
    if (done && this.afterBreak) {
      this.value = "";
      this.afterBreak = false;
    } else if (done) {
      this.done = true;
      this.value = "";
    } else if (lineBreak) {
      if (this.afterBreak) {
        this.value = "";
      } else {
        this.afterBreak = true;
        this.next();
      }
    } else {
      this.value = value;
      this.afterBreak = false;
    }
    return this;
  }
  get lineBreak() {
    return false;
  }
}
if (typeof Symbol != "undefined") {
  Text.prototype[Symbol.iterator] = function () {
    return this.iter();
  };
  RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] = LineCursor.prototype[Symbol.iterator] = function () {
    return this;
  };
}
class Line {
  constructor(from, to, number, text) {
    this.from = from;
    this.to = to;
    this.number = number;
    this.text = text;
  }
  get length() {
    return this.to - this.from;
  }
}
function clip(text, from, to) {
  from = Math.max(0, Math.min(text.length, from));
  return [from, Math.max(from, Math.min(text.length, to))];
}
function dist_findClusterBreak(str, pos, forward, includeExtending) {
  if (forward === void 0) {
    forward = true;
  }
  if (includeExtending === void 0) {
    includeExtending = true;
  }
  return findClusterBreak(str, pos, forward, includeExtending);
}
function dist_surrogateLow(ch) {
  return ch >= 0xDC00 && ch < 0xE000;
}
function dist_surrogateHigh(ch) {
  return ch >= 0xD800 && ch < 0xDC00;
}
function dist_codePointAt(str, pos) {
  let code0 = str.charCodeAt(pos);
  if (!dist_surrogateHigh(code0) || pos + 1 == str.length) return code0;
  let code1 = str.charCodeAt(pos + 1);
  if (!dist_surrogateLow(code1)) return code0;
  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;
}
function fromCodePoint(code) {
  if (code <= 0xffff) return String.fromCharCode(code);
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
function dist_codePointSize(code) {
  return code < 0x10000 ? 1 : 2;
}
const DefaultSplit = /\r\n?|\n/;
var MapMode = function (MapMode) {
  MapMode[MapMode["Simple"] = 0] = "Simple";
  MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
  MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
  MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
  return MapMode;
}(MapMode || (MapMode = {}));
class ChangeDesc {
  constructor(sections) {
    this.sections = sections;
  }
  get length() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) result += this.sections[i];
    return result;
  }
  get newLength() {
    let result = 0;
    for (let i = 0; i < this.sections.length; i += 2) {
      let ins = this.sections[i + 1];
      result += ins < 0 ? this.sections[i] : ins;
    }
    return result;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(f) {
    for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
      let len = this.sections[i++],
        ins = this.sections[i++];
      if (ins < 0) {
        f(posA, posB, len);
        posB += len;
      } else {
        posB += ins;
      }
      posA += len;
    }
  }
  iterChangedRanges(f, individual) {
    if (individual === void 0) {
      individual = false;
    }
    iterChanges(this, f, individual);
  }
  get invertedDesc() {
    let sections = [];
    for (let i = 0; i < this.sections.length;) {
      let len = this.sections[i++],
        ins = this.sections[i++];
      if (ins < 0) sections.push(len, ins);else sections.push(ins, len);
    }
    return new ChangeDesc(sections);
  }
  composeDesc(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other);
  }
  mapDesc(other, before) {
    if (before === void 0) {
      before = false;
    }
    return other.empty ? this : mapSet(this, other, before);
  }
  mapPos(pos, assoc, mode) {
    if (assoc === void 0) {
      assoc = -1;
    }
    if (mode === void 0) {
      mode = MapMode.Simple;
    }
    let posA = 0,
      posB = 0;
    for (let i = 0; i < this.sections.length;) {
      let len = this.sections[i++],
        ins = this.sections[i++],
        endA = posA + len;
      if (ins < 0) {
        if (endA > pos) return posB + (pos - posA);
        posB += len;
      } else {
        if (mode != MapMode.Simple && endA >= pos && (mode == MapMode.TrackDel && posA < pos && endA > pos || mode == MapMode.TrackBefore && posA < pos || mode == MapMode.TrackAfter && endA > pos)) return null;
        if (endA > pos || endA == pos && assoc < 0 && !len) return pos == posA || assoc < 0 ? posB : posB + ins;
        posB += ins;
      }
      posA = endA;
    }
    if (pos > posA) throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
    return posB;
  }
  touchesRange(from, to) {
    if (to === void 0) {
      to = from;
    }
    for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
      let len = this.sections[i++],
        ins = this.sections[i++],
        end = pos + len;
      if (ins >= 0 && pos <= to && end >= from) return pos < from && end > to ? "cover" : true;
      pos = end;
    }
    return false;
  }
  toString() {
    let result = "";
    for (let i = 0; i < this.sections.length;) {
      let len = this.sections[i++],
        ins = this.sections[i++];
      result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
    }
    return result;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(json) {
    if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number")) throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new ChangeDesc(json);
  }
  static create(sections) {
    return new ChangeDesc(sections);
  }
}
class ChangeSet extends ChangeDesc {
  constructor(sections, inserted) {
    super(sections);
    this.inserted = inserted;
  }
  apply(doc) {
    if (this.length != doc.length) throw new RangeError("Applying change set to a document with the wrong length");
    iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
    return doc;
  }
  mapDesc(other, before) {
    if (before === void 0) {
      before = false;
    }
    return mapSet(this, other, before, true);
  }
  invert(doc) {
    let sections = this.sections.slice(),
      inserted = [];
    for (let i = 0, pos = 0; i < sections.length; i += 2) {
      let len = sections[i],
        ins = sections[i + 1];
      if (ins >= 0) {
        sections[i] = ins;
        sections[i + 1] = len;
        let index = i >> 1;
        while (inserted.length < index) inserted.push(Text.empty);
        inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
      }
      pos += len;
    }
    return new ChangeSet(sections, inserted);
  }
  compose(other) {
    return this.empty ? other : other.empty ? this : composeSets(this, other, true);
  }
  map(other, before) {
    if (before === void 0) {
      before = false;
    }
    return other.empty ? this : mapSet(this, other, before, true);
  }
  iterChanges(f, individual) {
    if (individual === void 0) {
      individual = false;
    }
    iterChanges(this, f, individual);
  }
  get desc() {
    return ChangeDesc.create(this.sections);
  }
  filter(ranges) {
    let resultSections = [],
      resultInserted = [],
      filteredSections = [];
    let iter = new SectionIter(this);
    done: for (let i = 0, pos = 0;;) {
      let next = i == ranges.length ? 1e9 : ranges[i++];
      while (pos < next || pos == next && iter.len == 0) {
        if (iter.done) break done;
        let len = Math.min(iter.len, next - pos);
        addSection(filteredSections, len, -1);
        let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
        addSection(resultSections, len, ins);
        if (ins > 0) addInsert(resultInserted, resultSections, iter.text);
        iter.forward(len);
        pos += len;
      }
      let end = ranges[i++];
      while (pos < end) {
        if (iter.done) break done;
        let len = Math.min(iter.len, end - pos);
        addSection(resultSections, len, -1);
        addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
        iter.forward(len);
        pos += len;
      }
    }
    return {
      changes: new ChangeSet(resultSections, resultInserted),
      filtered: ChangeDesc.create(filteredSections)
    };
  }
  toJSON() {
    let parts = [];
    for (let i = 0; i < this.sections.length; i += 2) {
      let len = this.sections[i],
        ins = this.sections[i + 1];
      if (ins < 0) parts.push(len);else if (ins == 0) parts.push([len]);else parts.push([len].concat(this.inserted[i >> 1].toJSON()));
    }
    return parts;
  }
  static of(changes, length, lineSep) {
    let sections = [],
      inserted = [],
      pos = 0;
    let total = null;
    function flush(force) {
      if (force === void 0) {
        force = false;
      }
      if (!force && !sections.length) return;
      if (pos < length) addSection(sections, length - pos, -1);
      let set = new ChangeSet(sections, inserted);
      total = total ? total.compose(set.map(total)) : set;
      sections = [];
      inserted = [];
      pos = 0;
    }
    function process(spec) {
      if (Array.isArray(spec)) {
        for (var _iterator10 = _createForOfIteratorHelperLoose(spec), _step10; !(_step10 = _iterator10()).done;) {
          let sub = _step10.value;
          process(sub);
        }
      } else if (spec instanceof ChangeSet) {
        if (spec.length != length) throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
        flush();
        total = total ? total.compose(spec.map(total)) : spec;
      } else {
        let {
          from,
          to = from,
          insert
        } = spec;
        if (from > to || from < 0 || to > length) throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
        let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
        let insLen = insText.length;
        if (from == to && insLen == 0) return;
        if (from < pos) flush();
        if (from > pos) addSection(sections, from - pos, -1);
        addSection(sections, to - from, insLen);
        addInsert(inserted, sections, insText);
        pos = to;
      }
    }
    process(changes);
    flush(!total);
    return total;
  }
  static empty(length) {
    return new ChangeSet(length ? [length, -1] : [], []);
  }
  static fromJSON(json) {
    if (!Array.isArray(json)) throw new RangeError("Invalid JSON representation of ChangeSet");
    let sections = [],
      inserted = [];
    for (let i = 0; i < json.length; i++) {
      let part = json[i];
      if (typeof part == "number") {
        sections.push(part, -1);
      } else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
        throw new RangeError("Invalid JSON representation of ChangeSet");
      } else if (part.length == 1) {
        sections.push(part[0], 0);
      } else {
        while (inserted.length < i) inserted.push(Text.empty);
        inserted[i] = Text.of(part.slice(1));
        sections.push(part[0], inserted[i].length);
      }
    }
    return new ChangeSet(sections, inserted);
  }
  static createSet(sections, inserted) {
    return new ChangeSet(sections, inserted);
  }
}
function addSection(sections, len, ins, forceJoin) {
  if (forceJoin === void 0) {
    forceJoin = false;
  }
  if (len == 0 && ins <= 0) return;
  let last = sections.length - 2;
  if (last >= 0 && ins <= 0 && ins == sections[last + 1]) sections[last] += len;else if (last >= 0 && len == 0 && sections[last] == 0) sections[last + 1] += ins;else if (forceJoin) {
    sections[last] += len;
    sections[last + 1] += ins;
  } else sections.push(len, ins);
}
function addInsert(values, sections, value) {
  if (value.length == 0) return;
  let index = sections.length - 2 >> 1;
  if (index < values.length) {
    values[values.length - 1] = values[values.length - 1].append(value);
  } else {
    while (values.length < index) values.push(Text.empty);
    values.push(value);
  }
}
function iterChanges(desc, f, individual) {
  let inserted = desc.inserted;
  for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
    let len = desc.sections[i++],
      ins = desc.sections[i++];
    if (ins < 0) {
      posA += len;
      posB += len;
    } else {
      let endA = posA,
        endB = posB,
        text = Text.empty;
      for (;;) {
        endA += len;
        endB += ins;
        if (ins && inserted) text = text.append(inserted[i - 2 >> 1]);
        if (individual || i == desc.sections.length || desc.sections[i + 1] < 0) break;
        len = desc.sections[i++];
        ins = desc.sections[i++];
      }
      f(posA, endA, posB, endB, text);
      posA = endA;
      posB = endB;
    }
  }
}
function mapSet(setA, setB, before, mkSet) {
  if (mkSet === void 0) {
    mkSet = false;
  }
  let sections = [],
    insert = mkSet ? [] : null;
  let a = new SectionIter(setA),
    b = new SectionIter(setB);
  for (let inserted = -1;;) {
    if (a.done && b.len || b.done && a.len) {
      throw new Error("Mismatched change set lengths");
    } else if (a.ins == -1 && b.ins == -1) {
      let len = Math.min(a.len, b.len);
      addSection(sections, len, -1);
      a.forward(len);
      b.forward(len);
    } else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
      let len = b.len;
      addSection(sections, b.ins, -1);
      while (len) {
        let piece = Math.min(a.len, len);
        if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
          addSection(sections, 0, a.ins);
          if (insert) addInsert(insert, sections, a.text);
          inserted = a.i;
        }
        a.forward(piece);
        len -= piece;
      }
      b.next();
    } else if (a.ins >= 0) {
      let len = 0,
        left = a.len;
      while (left) {
        if (b.ins == -1) {
          let piece = Math.min(left, b.len);
          len += piece;
          left -= piece;
          b.forward(piece);
        } else if (b.ins == 0 && b.len < left) {
          left -= b.len;
          b.next();
        } else {
          break;
        }
      }
      addSection(sections, len, inserted < a.i ? a.ins : 0);
      if (insert && inserted < a.i) addInsert(insert, sections, a.text);
      inserted = a.i;
      a.forward(a.len - left);
    } else if (a.done && b.done) {
      return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
    } else {
      throw new Error("Mismatched change set lengths");
    }
  }
}
function composeSets(setA, setB, mkSet) {
  if (mkSet === void 0) {
    mkSet = false;
  }
  let sections = [];
  let insert = mkSet ? [] : null;
  let a = new SectionIter(setA),
    b = new SectionIter(setB);
  for (let open = false;;) {
    if (a.done && b.done) {
      return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
    } else if (a.ins == 0) {
      addSection(sections, a.len, 0, open);
      a.next();
    } else if (b.len == 0 && !b.done) {
      addSection(sections, 0, b.ins, open);
      if (insert) addInsert(insert, sections, b.text);
      b.next();
    } else if (a.done || b.done) {
      throw new Error("Mismatched change set lengths");
    } else {
      let len = Math.min(a.len2, b.len),
        sectionLen = sections.length;
      if (a.ins == -1) {
        let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
        addSection(sections, len, insB, open);
        if (insert && insB) addInsert(insert, sections, b.text);
      } else if (b.ins == -1) {
        addSection(sections, a.off ? 0 : a.len, len, open);
        if (insert) addInsert(insert, sections, a.textBit(len));
      } else {
        addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
        if (insert && !b.off) addInsert(insert, sections, b.text);
      }
      open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
      a.forward2(len);
      b.forward(len);
    }
  }
}
class SectionIter {
  constructor(set) {
    this.set = set;
    this.i = 0;
    this.next();
  }
  next() {
    let {
      sections
    } = this.set;
    if (this.i < sections.length) {
      this.len = sections[this.i++];
      this.ins = sections[this.i++];
    } else {
      this.len = 0;
      this.ins = -2;
    }
    this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let {
        inserted
      } = this.set,
      index = this.i - 2 >> 1;
    return index >= inserted.length ? Text.empty : inserted[index];
  }
  textBit(len) {
    let {
        inserted
      } = this.set,
      index = this.i - 2 >> 1;
    return index >= inserted.length && !len ? Text.empty : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
  }
  forward(len) {
    if (len == this.len) this.next();else {
      this.len -= len;
      this.off += len;
    }
  }
  forward2(len) {
    if (this.ins == -1) this.forward(len);else if (len == this.ins) this.next();else {
      this.ins -= len;
      this.off += len;
    }
  }
}
class SelectionRange {
  constructor(from, to, flags) {
    this.from = from;
    this.to = to;
    this.flags = flags;
  }
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  get bidiLevel() {
    let level = this.flags & 7;
    return level == 7 ? null : level;
  }
  get goalColumn() {
    let value = this.flags >> 6;
    return value == 16777215 ? undefined : value;
  }
  map(change, assoc) {
    if (assoc === void 0) {
      assoc = -1;
    }
    let from, to;
    if (this.empty) {
      from = to = change.mapPos(this.from, assoc);
    } else {
      from = change.mapPos(this.from, 1);
      to = change.mapPos(this.to, -1);
    }
    return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
  }
  extend(from, to) {
    if (to === void 0) {
      to = from;
    }
    if (from <= this.anchor && to >= this.anchor) return EditorSelection.range(from, to);
    let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
    return EditorSelection.range(this.anchor, head);
  }
  eq(other, includeAssoc) {
    if (includeAssoc === void 0) {
      includeAssoc = false;
    }
    return this.anchor == other.anchor && this.head == other.head && (!includeAssoc || !this.empty || this.assoc == other.assoc);
  }
  toJSON() {
    return {
      anchor: this.anchor,
      head: this.head
    };
  }
  static fromJSON(json) {
    if (!json || typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid JSON representation for SelectionRange");
    return EditorSelection.range(json.anchor, json.head);
  }
  static create(from, to, flags) {
    return new SelectionRange(from, to, flags);
  }
}
class EditorSelection {
  constructor(ranges, mainIndex) {
    this.ranges = ranges;
    this.mainIndex = mainIndex;
  }
  map(change, assoc) {
    if (assoc === void 0) {
      assoc = -1;
    }
    if (change.empty) return this;
    return EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
  }
  eq(other, includeAssoc) {
    if (includeAssoc === void 0) {
      includeAssoc = false;
    }
    if (this.ranges.length != other.ranges.length || this.mainIndex != other.mainIndex) return false;
    for (let i = 0; i < this.ranges.length; i++) if (!this.ranges[i].eq(other.ranges[i], includeAssoc)) return false;
    return true;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);
  }
  addRange(range, main) {
    if (main === void 0) {
      main = true;
    }
    return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
  }
  replaceRange(range, which) {
    if (which === void 0) {
      which = this.mainIndex;
    }
    let ranges = this.ranges.slice();
    ranges[which] = range;
    return EditorSelection.create(ranges, this.mainIndex);
  }
  toJSON() {
    return {
      ranges: this.ranges.map(r => r.toJSON()),
      main: this.mainIndex
    };
  }
  static fromJSON(json) {
    if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length) throw new RangeError("Invalid JSON representation for EditorSelection");
    return new EditorSelection(json.ranges.map(r => SelectionRange.fromJSON(r)), json.main);
  }
  static single(anchor, head) {
    if (head === void 0) {
      head = anchor;
    }
    return new EditorSelection([EditorSelection.range(anchor, head)], 0);
  }
  static create(ranges, mainIndex) {
    if (mainIndex === void 0) {
      mainIndex = 0;
    }
    if (ranges.length == 0) throw new RangeError("A selection needs at least one range");
    for (let pos = 0, i = 0; i < ranges.length; i++) {
      let range = ranges[i];
      if (range.empty ? range.from <= pos : range.from < pos) return EditorSelection.normalized(ranges.slice(), mainIndex);
      pos = range.to;
    }
    return new EditorSelection(ranges, mainIndex);
  }
  static cursor(pos, assoc, bidiLevel, goalColumn) {
    if (assoc === void 0) {
      assoc = 0;
    }
    return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 : 16) | (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) | (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6);
  }
  static range(anchor, head, goalColumn, bidiLevel) {
    let flags = (goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215) << 6 | (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
    return head < anchor ? SelectionRange.create(head, anchor, 32 | 16 | flags) : SelectionRange.create(anchor, head, (head > anchor ? 8 : 0) | flags);
  }
  static normalized(ranges, mainIndex) {
    if (mainIndex === void 0) {
      mainIndex = 0;
    }
    let main = ranges[mainIndex];
    ranges.sort((a, b) => a.from - b.from);
    mainIndex = ranges.indexOf(main);
    for (let i = 1; i < ranges.length; i++) {
      let range = ranges[i],
        prev = ranges[i - 1];
      if (range.empty ? range.from <= prev.to : range.from < prev.to) {
        let from = prev.from,
          to = Math.max(range.to, prev.to);
        if (i <= mainIndex) mainIndex--;
        ranges.splice(--i, 2, range.anchor > range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));
      }
    }
    return new EditorSelection(ranges, mainIndex);
  }
}
function checkSelection(selection, docLength) {
  for (var _iterator11 = _createForOfIteratorHelperLoose(selection.ranges), _step11; !(_step11 = _iterator11()).done;) {
    let range = _step11.value;
    if (range.to > docLength) throw new RangeError("Selection points outside of document");
  }
}
let nextID = 0;
class Facet {
  constructor(combine, compareInput, compare, isStatic, enables) {
    this.combine = combine;
    this.compareInput = compareInput;
    this.compare = compare;
    this.isStatic = isStatic;
    this.id = nextID++;
    this.default = combine([]);
    this.extensions = typeof enables == "function" ? enables(this) : enables;
  }
  get reader() {
    return this;
  }
  static define(config) {
    if (config === void 0) {
      config = {};
    }
    return new Facet(config.combine || (a => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
  }
  of(value) {
    return new FacetProvider([], this, 0, value);
  }
  compute(deps, get) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 1, get);
  }
  computeN(deps, get) {
    if (this.isStatic) throw new Error("Can't compute a static facet");
    return new FacetProvider(deps, this, 2, get);
  }
  from(field, get) {
    if (!get) get = x => x;
    return this.compute([field], state => get(state.field(field)));
  }
}
function sameArray(a, b) {
  return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
  constructor(dependencies, facet, type, value) {
    this.dependencies = dependencies;
    this.facet = facet;
    this.type = type;
    this.value = value;
    this.id = nextID++;
  }
  dynamicSlot(addresses) {
    var _a;
    let getter = this.value;
    let compare = this.facet.compareInput;
    let id = this.id,
      idx = addresses[id] >> 1,
      multi = this.type == 2;
    let depDoc = false,
      depSel = false,
      depAddrs = [];
    for (var _iterator12 = _createForOfIteratorHelperLoose(this.dependencies), _step12; !(_step12 = _iterator12()).done;) {
      let dep = _step12.value;
      if (dep == "doc") depDoc = true;else if (dep == "selection") depSel = true;else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0) depAddrs.push(addresses[dep.id]);
    }
    return {
      create(state) {
        state.values[idx] = getter(state);
        return 1;
      },
      update(state, tr) {
        if (depDoc && tr.docChanged || depSel && (tr.docChanged || tr.selection) || ensureAll(state, depAddrs)) {
          let newVal = getter(state);
          if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
            state.values[idx] = newVal;
            return 1;
          }
        }
        return 0;
      },
      reconfigure: (state, oldState) => {
        let newVal,
          oldAddr = oldState.config.address[id];
        if (oldAddr != null) {
          let oldVal = getAddr(oldState, oldAddr);
          if (this.dependencies.every(dep => {
            return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) : dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
          }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
            state.values[idx] = oldVal;
            return 0;
          }
        } else {
          newVal = getter(state);
        }
        state.values[idx] = newVal;
        return 1;
      }
    };
  }
}
function compareArray(a, b, compare) {
  if (a.length != b.length) return false;
  for (let i = 0; i < a.length; i++) if (!compare(a[i], b[i])) return false;
  return true;
}
function ensureAll(state, addrs) {
  let changed = false;
  for (var _iterator13 = _createForOfIteratorHelperLoose(addrs), _step13; !(_step13 = _iterator13()).done;) {
    let addr = _step13.value;
    if (ensureAddr(state, addr) & 1) changed = true;
  }
  return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
  let providerAddrs = providers.map(p => addresses[p.id]);
  let providerTypes = providers.map(p => p.type);
  let dynamic = providerAddrs.filter(p => !(p & 1));
  let idx = addresses[facet.id] >> 1;
  function get(state) {
    let values = [];
    for (let i = 0; i < providerAddrs.length; i++) {
      let value = getAddr(state, providerAddrs[i]);
      if (providerTypes[i] == 2) {
        for (var _iterator14 = _createForOfIteratorHelperLoose(value), _step14; !(_step14 = _iterator14()).done;) {
          let val = _step14.value;
          values.push(val);
        }
      } else values.push(value);
    }
    return facet.combine(values);
  }
  return {
    create(state) {
      for (var _iterator15 = _createForOfIteratorHelperLoose(providerAddrs), _step15; !(_step15 = _iterator15()).done;) {
        let addr = _step15.value;
        ensureAddr(state, addr);
      }
      state.values[idx] = get(state);
      return 1;
    },
    update(state, tr) {
      if (!ensureAll(state, dynamic)) return 0;
      let value = get(state);
      if (facet.compare(value, state.values[idx])) return 0;
      state.values[idx] = value;
      return 1;
    },
    reconfigure(state, oldState) {
      let depChanged = ensureAll(state, providerAddrs);
      let oldProviders = oldState.config.facets[facet.id],
        oldValue = oldState.facet(facet);
      if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
        state.values[idx] = oldValue;
        return 0;
      }
      let value = get(state);
      if (facet.compare(value, oldValue)) {
        state.values[idx] = oldValue;
        return 0;
      }
      state.values[idx] = value;
      return 1;
    }
  };
}
const initField = Facet.define({
  static: true
});
class StateField {
  constructor(id, createF, updateF, compareF, spec) {
    this.id = id;
    this.createF = createF;
    this.updateF = updateF;
    this.compareF = compareF;
    this.spec = spec;
    this.provides = undefined;
  }
  static define(config) {
    let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
    if (config.provide) field.provides = config.provide(field);
    return field;
  }
  create(state) {
    let init = state.facet(initField).find(i => i.field == this);
    return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
  }
  slot(addresses) {
    let idx = addresses[this.id] >> 1;
    return {
      create: state => {
        state.values[idx] = this.create(state);
        return 1;
      },
      update: (state, tr) => {
        let oldVal = state.values[idx];
        let value = this.updateF(oldVal, tr);
        if (this.compareF(oldVal, value)) return 0;
        state.values[idx] = value;
        return 1;
      },
      reconfigure: (state, oldState) => {
        let init = state.facet(initField),
          oldInit = oldState.facet(initField),
          reInit;
        if ((reInit = init.find(i => i.field == this)) && reInit != oldInit.find(i => i.field == this)) {
          state.values[idx] = reInit.create(state);
          return 1;
        }
        if (oldState.config.address[this.id] != null) {
          state.values[idx] = oldState.field(this);
          return 0;
        }
        state.values[idx] = this.create(state);
        return 1;
      }
    };
  }
  init(create) {
    return [this, initField.of({
      field: this,
      create
    })];
  }
  get extension() {
    return this;
  }
}
const Prec_ = {
  lowest: 4,
  low: 3,
  default: 2,
  high: 1,
  highest: 0
};
function prec(value) {
  return ext => new PrecExtension(ext, value);
}
const Prec = {
  highest: prec(Prec_.highest),
  high: prec(Prec_.high),
  default: prec(Prec_.default),
  low: prec(Prec_.low),
  lowest: prec(Prec_.lowest)
};
class PrecExtension {
  constructor(inner, prec) {
    this.inner = inner;
    this.prec = prec;
  }
}
class Compartment {
  of(ext) {
    return new CompartmentInstance(this, ext);
  }
  reconfigure(content) {
    return Compartment.reconfigure.of({
      compartment: this,
      extension: content
    });
  }
  get(state) {
    return state.config.compartments.get(this);
  }
}
class CompartmentInstance {
  constructor(compartment, inner) {
    this.compartment = compartment;
    this.inner = inner;
  }
}
class Configuration {
  constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
    this.base = base;
    this.compartments = compartments;
    this.dynamicSlots = dynamicSlots;
    this.address = address;
    this.staticValues = staticValues;
    this.facets = facets;
    this.statusTemplate = [];
    while (this.statusTemplate.length < dynamicSlots.length) this.statusTemplate.push(0);
  }
  staticFacet(facet) {
    let addr = this.address[facet.id];
    return addr == null ? facet.default : this.staticValues[addr >> 1];
  }
  static resolve(base, compartments, oldState) {
    let fields = [];
    let facets = Object.create(null);
    let newCompartments = new Map();
    for (var _iterator16 = _createForOfIteratorHelperLoose(flatten(base, compartments, newCompartments)), _step16; !(_step16 = _iterator16()).done;) {
      let ext = _step16.value;
      if (ext instanceof StateField) fields.push(ext);else (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
    }
    let address = Object.create(null);
    let staticValues = [];
    let dynamicSlots = [];
    for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
      let field = _fields[_i];
      address[field.id] = dynamicSlots.length << 1;
      dynamicSlots.push(a => field.slot(a));
    }
    let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
    for (let id in facets) {
      let providers = facets[id],
        facet = providers[0].facet;
      let oldProviders = oldFacets && oldFacets[id] || [];
      if (providers.every(p => p.type == 0)) {
        address[facet.id] = staticValues.length << 1 | 1;
        if (sameArray(oldProviders, providers)) {
          staticValues.push(oldState.facet(facet));
        } else {
          let value = facet.combine(providers.map(p => p.value));
          staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
        }
      } else {
        for (var _iterator17 = _createForOfIteratorHelperLoose(providers), _step17; !(_step17 = _iterator17()).done;) {
          let p = _step17.value;
          if (p.type == 0) {
            address[p.id] = staticValues.length << 1 | 1;
            staticValues.push(p.value);
          } else {
            address[p.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => p.dynamicSlot(a));
          }
        }
        address[facet.id] = dynamicSlots.length << 1;
        dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
      }
    }
    let dynamic = dynamicSlots.map(f => f(address));
    return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
  }
}
function flatten(extension, compartments, newCompartments) {
  let result = [[], [], [], [], []];
  let seen = new Map();
  function inner(ext, prec) {
    let known = seen.get(ext);
    if (known != null) {
      if (known <= prec) return;
      let found = result[known].indexOf(ext);
      if (found > -1) result[known].splice(found, 1);
      if (ext instanceof CompartmentInstance) newCompartments.delete(ext.compartment);
    }
    seen.set(ext, prec);
    if (Array.isArray(ext)) {
      for (var _iterator18 = _createForOfIteratorHelperLoose(ext), _step18; !(_step18 = _iterator18()).done;) {
        let e = _step18.value;
        inner(e, prec);
      }
    } else if (ext instanceof CompartmentInstance) {
      if (newCompartments.has(ext.compartment)) throw new RangeError(`Duplicate use of compartment in extensions`);
      let content = compartments.get(ext.compartment) || ext.inner;
      newCompartments.set(ext.compartment, content);
      inner(content, prec);
    } else if (ext instanceof PrecExtension) {
      inner(ext.inner, ext.prec);
    } else if (ext instanceof StateField) {
      result[prec].push(ext);
      if (ext.provides) inner(ext.provides, prec);
    } else if (ext instanceof FacetProvider) {
      result[prec].push(ext);
      if (ext.facet.extensions) inner(ext.facet.extensions, Prec_.default);
    } else {
      let content = ext.extension;
      if (!content) throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      inner(content, prec);
    }
  }
  inner(extension, Prec_.default);
  return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
  if (addr & 1) return 2;
  let idx = addr >> 1;
  let status = state.status[idx];
  if (status == 4) throw new Error("Cyclic dependency between fields and/or facets");
  if (status & 2) return status;
  state.status[idx] = 4;
  let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
  return state.status[idx] = 2 | changed;
}
function getAddr(state, addr) {
  return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}
const languageData = Facet.define();
const allowMultipleSelections = Facet.define({
  combine: values => values.some(v => v),
  static: true
});
const lineSeparator = Facet.define({
  combine: values => values.length ? values[0] : undefined,
  static: true
});
const changeFilter = Facet.define();
const transactionFilter = Facet.define();
const transactionExtender = Facet.define();
const readOnly = Facet.define({
  combine: values => values.length ? values[0] : false
});
class Annotation {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static define() {
    return new AnnotationType();
  }
}
class AnnotationType {
  of(value) {
    return new Annotation(this, value);
  }
}
class StateEffectType {
  constructor(map) {
    this.map = map;
  }
  of(value) {
    return new StateEffect(this, value);
  }
}
class StateEffect {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  map(mapping) {
    let mapped = this.type.map(this.value, mapping);
    return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
  }
  is(type) {
    return this.type == type;
  }
  static define(spec) {
    if (spec === void 0) {
      spec = {};
    }
    return new StateEffectType(spec.map || (v => v));
  }
  static mapEffects(effects, mapping) {
    if (!effects.length) return effects;
    let result = [];
    for (var _iterator19 = _createForOfIteratorHelperLoose(effects), _step19; !(_step19 = _iterator19()).done;) {
      let effect = _step19.value;
      let mapped = effect.map(mapping);
      if (mapped) result.push(mapped);
    }
    return result;
  }
}
StateEffect.reconfigure = StateEffect.define();
StateEffect.appendConfig = StateEffect.define();
class Transaction {
  constructor(startState, changes, selection, effects, annotations, scrollIntoView) {
    this.startState = startState;
    this.changes = changes;
    this.selection = selection;
    this.effects = effects;
    this.annotations = annotations;
    this.scrollIntoView = scrollIntoView;
    this._doc = null;
    this._state = null;
    if (selection) checkSelection(selection, changes.newLength);
    if (!annotations.some(a => a.type == Transaction.time)) this.annotations = annotations.concat(Transaction.time.of(Date.now()));
  }
  static create(startState, changes, selection, effects, annotations, scrollIntoView) {
    return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    if (!this._state) this.startState.applyTransaction(this);
    return this._state;
  }
  annotation(type) {
    for (var _iterator20 = _createForOfIteratorHelperLoose(this.annotations), _step20; !(_step20 = _iterator20()).done;) {
      let ann = _step20.value;
      if (ann.type == type) return ann.value;
    }
    return undefined;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(event) {
    let e = this.annotation(Transaction.userEvent);
    return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
  }
}
Transaction.time = Annotation.define();
Transaction.userEvent = Annotation.define();
Transaction.addToHistory = Annotation.define();
Transaction.remote = Annotation.define();
function joinRanges(a, b) {
  let result = [];
  for (let iA = 0, iB = 0;;) {
    let from, to;
    if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
      from = a[iA++];
      to = a[iA++];
    } else if (iB < b.length) {
      from = b[iB++];
      to = b[iB++];
    } else return result;
    if (!result.length || result[result.length - 1] < from) result.push(from, to);else if (result[result.length - 1] < to) result[result.length - 1] = to;
  }
}
function mergeTransaction(a, b, sequential) {
  var _a;
  let mapForA, mapForB, changes;
  if (sequential) {
    mapForA = b.changes;
    mapForB = ChangeSet.empty(b.changes.length);
    changes = a.changes.compose(b.changes);
  } else {
    mapForA = b.changes.map(a.changes);
    mapForB = a.changes.mapDesc(b.changes, true);
    changes = a.changes.compose(mapForA);
  }
  return {
    changes,
    selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
    effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
    annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
    scrollIntoView: a.scrollIntoView || b.scrollIntoView
  };
}
function resolveTransactionInner(state, spec, docSize) {
  let sel = spec.selection,
    annotations = asArray(spec.annotations);
  if (spec.userEvent) annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
  return {
    changes: spec.changes instanceof ChangeSet ? spec.changes : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
    selection: sel && (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),
    effects: asArray(spec.effects),
    annotations,
    scrollIntoView: !!spec.scrollIntoView
  };
}
function resolveTransaction(state, specs, filter) {
  let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
  if (specs.length && specs[0].filter === false) filter = false;
  for (let i = 1; i < specs.length; i++) {
    if (specs[i].filter === false) filter = false;
    let seq = !!specs[i].sequential;
    s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
  }
  let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
  return extendTransaction(filter ? filterTransaction(tr) : tr);
}
function filterTransaction(tr) {
  let state = tr.startState;
  let result = true;
  for (var _iterator21 = _createForOfIteratorHelperLoose(state.facet(changeFilter)), _step21; !(_step21 = _iterator21()).done;) {
    let filter = _step21.value;
    let value = filter(tr);
    if (value === false) {
      result = false;
      break;
    }
    if (Array.isArray(value)) result = result === true ? value : joinRanges(result, value);
  }
  if (result !== true) {
    let changes, back;
    if (result === false) {
      back = tr.changes.invertedDesc;
      changes = ChangeSet.empty(state.doc.length);
    } else {
      let filtered = tr.changes.filter(result);
      changes = filtered.changes;
      back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
    }
    tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
  }
  let filters = state.facet(transactionFilter);
  for (let i = filters.length - 1; i >= 0; i--) {
    let filtered = filters[i](tr);
    if (filtered instanceof Transaction) tr = filtered;else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction) tr = filtered[0];else tr = resolveTransaction(state, asArray(filtered), false);
  }
  return tr;
}
function extendTransaction(tr) {
  let state = tr.startState,
    extenders = state.facet(transactionExtender),
    spec = tr;
  for (let i = extenders.length - 1; i >= 0; i--) {
    let extension = extenders[i](tr);
    if (extension && Object.keys(extension).length) spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
  }
  return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
  return value == null ? none : Array.isArray(value) ? value : [value];
}
var CharCategory = function (CharCategory) {
  CharCategory[CharCategory["Word"] = 0] = "Word";
  CharCategory[CharCategory["Space"] = 1] = "Space";
  CharCategory[CharCategory["Other"] = 2] = "Other";
  return CharCategory;
}(CharCategory || (CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
  wordChar = new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch (_) {}
function hasWordChar(str) {
  if (wordChar) return wordChar.test(str);
  for (let i = 0; i < str.length; i++) {
    let ch = str[i];
    if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))) return true;
  }
  return false;
}
function makeCategorizer(wordChars) {
  return char => {
    if (!/\S/.test(char)) return CharCategory.Space;
    if (hasWordChar(char)) return CharCategory.Word;
    for (let i = 0; i < wordChars.length; i++) if (char.indexOf(wordChars[i]) > -1) return CharCategory.Word;
    return CharCategory.Other;
  };
}
class EditorState {
  constructor(config, doc, selection, values, computeSlot, tr) {
    this.config = config;
    this.doc = doc;
    this.selection = selection;
    this.values = values;
    this.status = config.statusTemplate.slice();
    this.computeSlot = computeSlot;
    if (tr) tr._state = this;
    for (let i = 0; i < this.config.dynamicSlots.length; i++) ensureAddr(this, i << 1);
    this.computeSlot = null;
  }
  field(field, require) {
    if (require === void 0) {
      require = true;
    }
    let addr = this.config.address[field.id];
    if (addr == null) {
      if (require) throw new RangeError("Field is not present in this state");
      return undefined;
    }
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  update() {
    for (var _len = arguments.length, specs = new Array(_len), _key = 0; _key < _len; _key++) {
      specs[_key] = arguments[_key];
    }
    return resolveTransaction(this, specs, true);
  }
  applyTransaction(tr) {
    let conf = this.config,
      {
        base,
        compartments
      } = conf;
    for (var _iterator22 = _createForOfIteratorHelperLoose(tr.effects), _step22; !(_step22 = _iterator22()).done;) {
      let effect = _step22.value;
      if (effect.is(Compartment.reconfigure)) {
        if (conf) {
          compartments = new Map();
          conf.compartments.forEach((val, key) => compartments.set(key, val));
          conf = null;
        }
        compartments.set(effect.value.compartment, effect.value.extension);
      } else if (effect.is(StateEffect.reconfigure)) {
        conf = null;
        base = effect.value;
      } else if (effect.is(StateEffect.appendConfig)) {
        conf = null;
        base = asArray(base).concat(effect.value);
      }
    }
    let startValues;
    if (!conf) {
      conf = Configuration.resolve(base, compartments, this);
      let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
      startValues = intermediateState.values;
    } else {
      startValues = tr.startState.values.slice();
    }
    let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
    new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
  }
  replaceSelection(text) {
    if (typeof text == "string") text = this.toText(text);
    return this.changeByRange(range => ({
      changes: {
        from: range.from,
        to: range.to,
        insert: text
      },
      range: EditorSelection.cursor(range.from + text.length)
    }));
  }
  changeByRange(f) {
    let sel = this.selection;
    let result1 = f(sel.ranges[0]);
    let changes = this.changes(result1.changes),
      ranges = [result1.range];
    let effects = asArray(result1.effects);
    for (let i = 1; i < sel.ranges.length; i++) {
      let result = f(sel.ranges[i]);
      let newChanges = this.changes(result.changes),
        newMapped = newChanges.map(changes);
      for (let j = 0; j < i; j++) ranges[j] = ranges[j].map(newMapped);
      let mapBy = changes.mapDesc(newChanges, true);
      ranges.push(result.range.map(mapBy));
      changes = changes.compose(newMapped);
      effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
    }
    return {
      changes,
      selection: EditorSelection.create(ranges, sel.mainIndex),
      effects
    };
  }
  changes(spec) {
    if (spec === void 0) {
      spec = [];
    }
    if (spec instanceof ChangeSet) return spec;
    return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
  }
  toText(string) {
    return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
  }
  sliceDoc(from, to) {
    if (from === void 0) {
      from = 0;
    }
    if (to === void 0) {
      to = this.doc.length;
    }
    return this.doc.sliceString(from, to, this.lineBreak);
  }
  facet(facet) {
    let addr = this.config.address[facet.id];
    if (addr == null) return facet.default;
    ensureAddr(this, addr);
    return getAddr(this, addr);
  }
  toJSON(fields) {
    let result = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (fields) for (let prop in fields) {
      let value = fields[prop];
      if (value instanceof StateField && this.config.address[value.id] != null) result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
    }
    return result;
  }
  static fromJSON(json, config, fields) {
    if (config === void 0) {
      config = {};
    }
    if (!json || typeof json.doc != "string") throw new RangeError("Invalid JSON representation for EditorState");
    let fieldInit = [];
    if (fields) for (let prop in fields) {
      if (Object.prototype.hasOwnProperty.call(json, prop)) {
        let field = fields[prop],
          value = json[prop];
        fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
      }
    }
    return EditorState.create({
      doc: json.doc,
      selection: EditorSelection.fromJSON(json.selection),
      extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
    });
  }
  static create(config) {
    if (config === void 0) {
      config = {};
    }
    let configuration = Configuration.resolve(config.extensions || [], new Map());
    let doc = config.doc instanceof Text ? config.doc : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
    let selection = !config.selection ? EditorSelection.single(0) : config.selection instanceof EditorSelection ? config.selection : EditorSelection.single(config.selection.anchor, config.selection.head);
    checkSelection(selection, doc.length);
    if (!configuration.staticFacet(allowMultipleSelections)) selection = selection.asSingle();
    return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
  }
  get tabSize() {
    return this.facet(EditorState.tabSize);
  }
  get lineBreak() {
    return this.facet(EditorState.lineSeparator) || "\n";
  }
  get readOnly() {
    return this.facet(readOnly);
  }
  phrase(phrase) {
    for (var _len2 = arguments.length, insert = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      insert[_key2 - 1] = arguments[_key2];
    }
    for (var _iterator23 = _createForOfIteratorHelperLoose(this.facet(EditorState.phrases)), _step23; !(_step23 = _iterator23()).done;) {
      let map = _step23.value;
      if (Object.prototype.hasOwnProperty.call(map, phrase)) {
        phrase = map[phrase];
        break;
      }
    }
    if (insert.length) phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
      if (i == "$") return "$";
      let n = +(i || 1);
      return !n || n > insert.length ? m : insert[n - 1];
    });
    return phrase;
  }
  languageDataAt(name, pos, side) {
    if (side === void 0) {
      side = -1;
    }
    let values = [];
    for (var _iterator24 = _createForOfIteratorHelperLoose(this.facet(languageData)), _step24; !(_step24 = _iterator24()).done;) {
      let provider = _step24.value;
      for (var _iterator25 = _createForOfIteratorHelperLoose(provider(this, pos, side)), _step25; !(_step25 = _iterator25()).done;) {
        let result = _step25.value;
        if (Object.prototype.hasOwnProperty.call(result, name)) values.push(result[name]);
      }
    }
    return values;
  }
  charCategorizer(at) {
    return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
  }
  wordAt(pos) {
    let {
      text,
      from,
      length
    } = this.doc.lineAt(pos);
    let cat = this.charCategorizer(pos);
    let start = pos - from,
      end = pos - from;
    while (start > 0) {
      let prev = dist_findClusterBreak(text, start, false);
      if (cat(text.slice(prev, start)) != CharCategory.Word) break;
      start = prev;
    }
    while (end < length) {
      let next = dist_findClusterBreak(text, end);
      if (cat(text.slice(end, next)) != CharCategory.Word) break;
      end = next;
    }
    return start == end ? null : EditorSelection.range(start + from, end + from);
  }
}
EditorState.allowMultipleSelections = allowMultipleSelections;
EditorState.tabSize = Facet.define({
  combine: values => values.length ? values[0] : 4
});
EditorState.lineSeparator = lineSeparator;
EditorState.readOnly = readOnly;
EditorState.phrases = Facet.define({
  compare(a, b) {
    let kA = Object.keys(a),
      kB = Object.keys(b);
    return kA.length == kB.length && kA.every(k => a[k] == b[k]);
  }
});
EditorState.languageData = languageData;
EditorState.changeFilter = changeFilter;
EditorState.transactionFilter = transactionFilter;
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = StateEffect.define();
function combineConfig(configs, defaults, combine) {
  if (combine === void 0) {
    combine = {};
  }
  let result = {};
  for (var _iterator26 = _createForOfIteratorHelperLoose(configs), _step26; !(_step26 = _iterator26()).done;) {
    let config = _step26.value;
    for (var _i2 = 0, _Object$keys = Object.keys(config); _i2 < _Object$keys.length; _i2++) {
      let key = _Object$keys[_i2];
      let value = config[key],
        current = result[key];
      if (current === undefined) result[key] = value;else if (current === value || value === undefined) ;else if (Object.hasOwnProperty.call(combine, key)) result[key] = combine[key](current, value);else throw new Error("Config merge conflict for field " + key);
    }
  }
  for (let key in defaults) if (result[key] === undefined) result[key] = defaults[key];
  return result;
}
class RangeValue {
  eq(other) {
    return this == other;
  }
  range(from, to) {
    if (to === void 0) {
      to = from;
    }
    return Range.create(from, to, this);
  }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
class Range {
  constructor(from, to, value) {
    this.from = from;
    this.to = to;
    this.value = value;
  }
  static create(from, to, value) {
    return new Range(from, to, value);
  }
}
function cmpRange(a, b) {
  return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
  constructor(from, to, value, maxPoint) {
    this.from = from;
    this.to = to;
    this.value = value;
    this.maxPoint = maxPoint;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(pos, side, end, startAt) {
    if (startAt === void 0) {
      startAt = 0;
    }
    let arr = end ? this.to : this.from;
    for (let lo = startAt, hi = arr.length;;) {
      if (lo == hi) return lo;
      let mid = lo + hi >> 1;
      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
      if (mid == lo) return diff >= 0 ? lo : hi;
      if (diff >= 0) hi = mid;else lo = mid + 1;
    }
  }
  between(offset, from, to, f) {
    for (let i = this.findIndex(from, -1000000000, true), e = this.findIndex(to, 1000000000, false, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;
  }
  map(offset, changes) {
    let value = [],
      from = [],
      to = [],
      newPos = -1,
      maxPoint = -1;
    for (let i = 0; i < this.value.length; i++) {
      let val = this.value[i],
        curFrom = this.from[i] + offset,
        curTo = this.to[i] + offset,
        newFrom,
        newTo;
      if (curFrom == curTo) {
        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
        if (mapped == null) continue;
        newFrom = newTo = mapped;
        if (val.startSide != val.endSide) {
          newTo = changes.mapPos(curFrom, val.endSide);
          if (newTo < newFrom) continue;
        }
      } else {
        newFrom = changes.mapPos(curFrom, val.startSide);
        newTo = changes.mapPos(curTo, val.endSide);
        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;
      }
      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;
      if (newPos < 0) newPos = newFrom;
      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);
      value.push(val);
      from.push(newFrom - newPos);
      to.push(newTo - newPos);
    }
    return {
      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,
      pos: newPos
    };
  }
}
class RangeSet {
  constructor(chunkPos, chunk, nextLayer, maxPoint) {
    this.chunkPos = chunkPos;
    this.chunk = chunk;
    this.nextLayer = nextLayer;
    this.maxPoint = maxPoint;
  }
  static create(chunkPos, chunk, nextLayer, maxPoint) {
    return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);
  }
  get length() {
    let last = this.chunk.length - 1;
    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty) return 0;
    let size = this.nextLayer.size;
    for (var _iterator27 = _createForOfIteratorHelperLoose(this.chunk), _step27; !(_step27 = _iterator27()).done;) {
      let chunk = _step27.value;
      size += chunk.value.length;
    }
    return size;
  }
  chunkEnd(index) {
    return this.chunkPos[index] + this.chunk[index].length;
  }
  update(updateSpec) {
    let {
      add = [],
      sort = false,
      filterFrom = 0,
      filterTo = this.length
    } = updateSpec;
    let filter = updateSpec.filter;
    if (add.length == 0 && !filter) return this;
    if (sort) add = add.slice().sort(cmpRange);
    if (this.isEmpty) return add.length ? RangeSet.of(add) : this;
    let cur = new LayerCursor(this, null, -1).goto(0),
      i = 0,
      spill = [];
    let builder = new RangeSetBuilder();
    while (cur.value || i < add.length) {
      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
        let range = add[i++];
        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);
      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
        cur.nextChunk();
      } else {
        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(Range.create(cur.from, cur.to, cur.value));
        }
        cur.next();
      }
    }
    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({
      add: spill,
      filter,
      filterFrom,
      filterTo
    }));
  }
  map(changes) {
    if (changes.empty || this.isEmpty) return this;
    let chunks = [],
      chunkPos = [],
      maxPoint = -1;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i],
        chunk = this.chunk[i];
      let touch = changes.touchesRange(start, start + chunk.length);
      if (touch === false) {
        maxPoint = Math.max(maxPoint, chunk.maxPoint);
        chunks.push(chunk);
        chunkPos.push(changes.mapPos(start));
      } else if (touch === true) {
        let {
          mapped,
          pos
        } = chunk.map(start, changes);
        if (mapped) {
          maxPoint = Math.max(maxPoint, mapped.maxPoint);
          chunks.push(mapped);
          chunkPos.push(pos);
        }
      }
    }
    let next = this.nextLayer.map(changes);
    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);
  }
  between(from, to, f) {
    if (this.isEmpty) return;
    for (let i = 0; i < this.chunk.length; i++) {
      let start = this.chunkPos[i],
        chunk = this.chunk[i];
      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;
    }
    this.nextLayer.between(from, to, f);
  }
  iter(from) {
    if (from === void 0) {
      from = 0;
    }
    return HeapCursor.from([this]).goto(from);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(sets, from) {
    if (from === void 0) {
      from = 0;
    }
    return HeapCursor.from(sets).goto(from);
  }
  static compare(oldSets, newSets, textDiff, comparator, minPointSize) {
    if (minPointSize === void 0) {
      minPointSize = -1;
    }
    let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
    let sharedChunks = findSharedChunks(a, b, textDiff);
    let sideA = new SpanCursor(a, sharedChunks, minPointSize);
    let sideB = new SpanCursor(b, sharedChunks, minPointSize);
    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);
  }
  static eq(oldSets, newSets, from, to) {
    if (from === void 0) {
      from = 0;
    }
    if (to == null) to = 1000000000 - 1;
    let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
    let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
    if (a.length != b.length) return false;
    if (!a.length) return true;
    let sharedChunks = findSharedChunks(a, b);
    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),
      sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
    for (;;) {
      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;
      if (sideA.to > to) return true;
      sideA.next();
      sideB.next();
    }
  }
  static spans(sets, from, to, iterator, minPointSize) {
    if (minPointSize === void 0) {
      minPointSize = -1;
    }
    let cursor = new SpanCursor(sets, null, minPointSize).goto(from),
      pos = from;
    let openRanges = cursor.openStart;
    for (;;) {
      let curTo = Math.min(cursor.to, to);
      if (cursor.point) {
        let active = cursor.activeForPoint(cursor.to);
        let openCount = cursor.pointFrom < from ? active.length + 1 : cursor.point.startSide < 0 ? active.length : Math.min(active.length, openRanges);
        iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
        openRanges = Math.min(cursor.openEnd(curTo), active.length);
      } else if (curTo > pos) {
        iterator.span(pos, curTo, cursor.active, openRanges);
        openRanges = cursor.openEnd(curTo);
      }
      if (cursor.to > to) return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
      pos = cursor.to;
      cursor.next();
    }
  }
  static of(ranges, sort) {
    if (sort === void 0) {
      sort = false;
    }
    let build = new RangeSetBuilder();
    for (var _iterator28 = _createForOfIteratorHelperLoose(ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges), _step28; !(_step28 = _iterator28()).done;) {
      let range = _step28.value;
      build.add(range.from, range.to, range.value);
    }
    return build.finish();
  }
  static join(sets) {
    if (!sets.length) return RangeSet.empty;
    let result = sets[sets.length - 1];
    for (let i = sets.length - 2; i >= 0; i--) {
      for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer) result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));
    }
    return result;
  }
}
RangeSet.empty = new RangeSet([], [], null, -1);
function lazySort(ranges) {
  if (ranges.length > 1) for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
    let cur = ranges[i];
    if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);
    prev = cur;
  }
  return ranges;
}
RangeSet.empty.nextLayer = RangeSet.empty;
class RangeSetBuilder {
  finishChunk(newArrays) {
    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
    this.chunkPos.push(this.chunkStart);
    this.chunkStart = -1;
    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
    this.maxPoint = -1;
    if (newArrays) {
      this.from = [];
      this.to = [];
      this.value = [];
    }
  }
  constructor() {
    this.chunks = [];
    this.chunkPos = [];
    this.chunkStart = -1;
    this.last = null;
    this.lastFrom = -1000000000;
    this.lastTo = -1000000000;
    this.from = [];
    this.to = [];
    this.value = [];
    this.maxPoint = -1;
    this.setMaxPoint = -1;
    this.nextLayer = null;
  }
  add(from, to, value) {
    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);
  }
  addInner(from, to, value) {
    let diff = from - this.lastTo || value.startSide - this.last.endSide;
    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    if (diff < 0) return false;
    if (this.from.length == 250) this.finishChunk(true);
    if (this.chunkStart < 0) this.chunkStart = from;
    this.from.push(from - this.chunkStart);
    this.to.push(to - this.chunkStart);
    this.last = value;
    this.lastFrom = from;
    this.lastTo = to;
    this.value.push(value);
    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);
    return true;
  }
  addChunk(from, chunk) {
    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;
    if (this.from.length) this.finishChunk(true);
    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
    this.chunks.push(chunk);
    this.chunkPos.push(from);
    let last = chunk.value.length - 1;
    this.last = chunk.value[last];
    this.lastFrom = chunk.from[last] + from;
    this.lastTo = chunk.to[last] + from;
    return true;
  }
  finish() {
    return this.finishInner(RangeSet.empty);
  }
  finishInner(next) {
    if (this.from.length) this.finishChunk(false);
    if (this.chunks.length == 0) return next;
    let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
    this.from = null;
    return result;
  }
}
function findSharedChunks(a, b, textDiff) {
  let inA = new Map();
  for (var _iterator29 = _createForOfIteratorHelperLoose(a), _step29; !(_step29 = _iterator29()).done;) {
    let set = _step29.value;
    for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);
  }
  let shared = new Set();
  for (var _iterator30 = _createForOfIteratorHelperLoose(b), _step30; !(_step30 = _iterator30()).done;) {
    let set = _step30.value;
    for (let i = 0; i < set.chunk.length; i++) {
      let known = inA.get(set.chunk[i]);
      if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);
    }
  }
  return shared;
}
class LayerCursor {
  constructor(layer, skip, minPoint, rank) {
    if (rank === void 0) {
      rank = 0;
    }
    this.layer = layer;
    this.skip = skip;
    this.minPoint = minPoint;
    this.rank = rank;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(pos, side) {
    if (side === void 0) {
      side = -1000000000;
    }
    this.chunkIndex = this.rangeIndex = 0;
    this.gotoInner(pos, side, false);
    return this;
  }
  gotoInner(pos, side, forward) {
    while (this.chunkIndex < this.layer.chunk.length) {
      let next = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;
      this.chunkIndex++;
      forward = false;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);
    }
    this.next();
  }
  forward(pos, side) {
    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);
  }
  next() {
    for (;;) {
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1000000000;
        this.value = null;
        break;
      } else {
        let chunkPos = this.layer.chunkPos[this.chunkIndex],
          chunk = this.layer.chunk[this.chunkIndex];
        let from = chunkPos + chunk.from[this.rangeIndex];
        this.from = from;
        this.to = chunkPos + chunk.to[this.rangeIndex];
        this.value = chunk.value[this.rangeIndex];
        this.setRangeIndex(this.rangeIndex + 1);
        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;
      }
    }
  }
  setRangeIndex(index) {
    if (index == this.layer.chunk[this.chunkIndex].value.length) {
      this.chunkIndex++;
      if (this.skip) {
        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;
      }
      this.rangeIndex = 0;
    } else {
      this.rangeIndex = index;
    }
  }
  nextChunk() {
    this.chunkIndex++;
    this.rangeIndex = 0;
    this.next();
  }
  compare(other) {
    return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank || this.to - other.to || this.endSide - other.endSide;
  }
}
class HeapCursor {
  constructor(heap) {
    this.heap = heap;
  }
  static from(sets, skip, minPoint) {
    if (skip === void 0) {
      skip = null;
    }
    if (minPoint === void 0) {
      minPoint = -1;
    }
    let heap = [];
    for (let i = 0; i < sets.length; i++) {
      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));
      }
    }
    return heap.length == 1 ? heap[0] : new HeapCursor(heap);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(pos, side) {
    if (side === void 0) {
      side = -1000000000;
    }
    for (var _iterator31 = _createForOfIteratorHelperLoose(this.heap), _step31; !(_step31 = _iterator31()).done;) {
      let cur = _step31.value;
      cur.goto(pos, side);
    }
    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);
    this.next();
    return this;
  }
  forward(pos, side) {
    for (var _iterator32 = _createForOfIteratorHelperLoose(this.heap), _step32; !(_step32 = _iterator32()).done;) {
      let cur = _step32.value;
      cur.forward(pos, side);
    }
    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);
    if ((this.to - pos || this.value.endSide - side) < 0) this.next();
  }
  next() {
    if (this.heap.length == 0) {
      this.from = this.to = 1000000000;
      this.value = null;
      this.rank = -1;
    } else {
      let top = this.heap[0];
      this.from = top.from;
      this.to = top.to;
      this.value = top.value;
      this.rank = top.rank;
      if (top.value) top.next();
      heapBubble(this.heap, 0);
    }
  }
}
function heapBubble(heap, index) {
  for (let cur = heap[index];;) {
    let childIndex = (index << 1) + 1;
    if (childIndex >= heap.length) break;
    let child = heap[childIndex];
    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
      child = heap[childIndex + 1];
      childIndex++;
    }
    if (cur.compare(child) < 0) break;
    heap[childIndex] = cur;
    heap[index] = child;
    index = childIndex;
  }
}
class SpanCursor {
  constructor(sets, skip, minPoint) {
    this.minPoint = minPoint;
    this.active = [];
    this.activeTo = [];
    this.activeRank = [];
    this.minActive = -1;
    this.point = null;
    this.pointFrom = 0;
    this.pointRank = 0;
    this.to = -1000000000;
    this.endSide = 0;
    this.openStart = -1;
    this.cursor = HeapCursor.from(sets, skip, minPoint);
  }
  goto(pos, side) {
    if (side === void 0) {
      side = -1000000000;
    }
    this.cursor.goto(pos, side);
    this.active.length = this.activeTo.length = this.activeRank.length = 0;
    this.minActive = -1;
    this.to = pos;
    this.endSide = side;
    this.openStart = -1;
    this.next();
    return this;
  }
  forward(pos, side) {
    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);
    this.cursor.forward(pos, side);
  }
  removeActive(index) {
    remove(this.active, index);
    remove(this.activeTo, index);
    remove(this.activeRank, index);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  addActive(trackOpen) {
    let i = 0,
      {
        value,
        to,
        rank
      } = this.cursor;
    while (i < this.activeRank.length && (rank - this.activeRank[i] || to - this.activeTo[i]) > 0) i++;
    insert(this.active, i, value);
    insert(this.activeTo, i, to);
    insert(this.activeRank, i, rank);
    if (trackOpen) insert(trackOpen, i, this.cursor.from);
    this.minActive = findMinIndex(this.active, this.activeTo);
  }
  next() {
    let from = this.to,
      wasPoint = this.point;
    this.point = null;
    let trackOpen = this.openStart < 0 ? [] : null;
    for (;;) {
      let a = this.minActive;
      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[a] > from) {
          this.to = this.activeTo[a];
          this.endSide = this.active[a].endSide;
          break;
        }
        this.removeActive(a);
        if (trackOpen) remove(trackOpen, a);
      } else if (!this.cursor.value) {
        this.to = this.endSide = 1000000000;
        break;
      } else if (this.cursor.from > from) {
        this.to = this.cursor.from;
        this.endSide = this.cursor.startSide;
        break;
      } else {
        let nextVal = this.cursor.value;
        if (!nextVal.point) {
          this.addActive(trackOpen);
          this.cursor.next();
        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
          this.cursor.next();
        } else {
          this.point = nextVal;
          this.pointFrom = this.cursor.from;
          this.pointRank = this.cursor.rank;
          this.to = this.cursor.to;
          this.endSide = nextVal.endSide;
          this.cursor.next();
          this.forward(this.to, this.endSide);
          break;
        }
      }
    }
    if (trackOpen) {
      this.openStart = 0;
      for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--) this.openStart++;
    }
  }
  activeForPoint(to) {
    if (!this.active.length) return this.active;
    let active = [];
    for (let i = this.active.length - 1; i >= 0; i--) {
      if (this.activeRank[i] < this.pointRank) break;
      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);
    }
    return active.reverse();
  }
  openEnd(to) {
    let open = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++;
    return open;
  }
}
function compare(a, startA, b, startB, length, comparator) {
  a.goto(startA);
  b.goto(startB);
  let endB = startB + length;
  let pos = startB,
    dPos = startB - startA;
  for (;;) {
    let dEnd = a.to + dPos - b.to,
      diff = dEnd || a.endSide - b.endSide;
    let end = diff < 0 ? a.to + dPos : b.to,
      clipEnd = Math.min(end, endB);
    if (a.point || b.point) {
      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);
    } else {
      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);
    }
    if (end > endB) break;
    if ((dEnd || a.openEnd != b.openEnd) && comparator.boundChange) comparator.boundChange(end);
    pos = end;
    if (diff <= 0) a.next();
    if (diff >= 0) b.next();
  }
}
function sameValues(a, b) {
  if (a.length != b.length) return false;
  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;
  return true;
}
function remove(array, index) {
  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];
  array.pop();
}
function insert(array, index, value) {
  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];
  array[index] = value;
}
function findMinIndex(value, array) {
  let found = -1,
    foundPos = 1000000000;
  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
    found = i;
    foundPos = array[i];
  }
  return found;
}
function countColumn(string, tabSize, to) {
  if (to === void 0) {
    to = string.length;
  }
  let n = 0;
  for (let i = 0; i < to && i < string.length;) {
    if (string.charCodeAt(i) == 9) {
      n += tabSize - n % tabSize;
      i++;
    } else {
      n++;
      i = dist_findClusterBreak(string, i);
    }
  }
  return n;
}
function findColumn(string, col, tabSize, strict) {
  for (let i = 0, n = 0;;) {
    if (n >= col) return i;
    if (i == string.length) break;
    n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;
    i = dist_findClusterBreak(string, i);
  }
  return strict === true ? -1 : string.length;
}


/***/ }),

/***/ 1113:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ 1195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/images/stripe2.png";

/***/ }),

/***/ 1683:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Light-webfont.eot";

/***/ }),

/***/ 1712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/images/blueprint-dark.png";

/***/ }),

/***/ 1785:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ StyleModule)
/* harmony export */ });
const C = "\u037c";
const COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
const SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
const top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};
class StyleModule {
  constructor(spec, options) {
    this.rules = [];
    let {
      finish
    } = options || {};
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec, target, isKeyframes) {
      let local = [],
        isAt = /^@(\w+)\b/.exec(selectors[0]),
        keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec == null) return target.push(selectors[0] + ";");
      for (let prop in spec) {
        let value = spec[prop];
        if (/&/.test(prop)) {
          render(prop.split(/,\s*/).map(part => selectors.map(sel => part.replace(/&/, sel))).reduce((a, b) => a.concat(b)), value, target);
        } else if (value && typeof value == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, l => "-" + l.toLowerCase()) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }
  getRules() {
    return this.rules.join("\n");
  }
  static newName() {
    let id = top[COUNT] || 1;
    top[COUNT] = id + 1;
    return C + id.toString(36);
  }
  static mount(root, modules, options) {
    let set = root[SET],
      nonce = options && options.nonce;
    if (!set) set = new StyleSet(root, nonce);else if (nonce) set.setNonce(nonce);
    set.mount(Array.isArray(modules) ? modules : [modules], root);
  }
}
let adoptedSet = new Map();
class StyleSet {
  constructor(root, nonce) {
    let doc = root.ownerDocument || root,
      win = doc.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      let adopted = adoptedSet.get(doc);
      if (adopted) return root[SET] = adopted;
      this.sheet = new win.CSSStyleSheet();
      adoptedSet.set(doc, this);
    } else {
      this.styleTag = doc.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
    }
    this.modules = [];
    root[SET] = this;
  }
  mount(modules, root) {
    let sheet = this.sheet;
    let pos = 0,
      j = 0;
    for (let i = 0; i < modules.length; i++) {
      let mod = modules[i],
        index = this.modules.indexOf(mod);
      if (index < j && index > -1) {
        this.modules.splice(index, 1);
        j--;
        index = -1;
      }
      if (index == -1) {
        this.modules.splice(j++, 0, mod);
        if (sheet) for (let k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);
      } else {
        while (j < index) pos += this.modules[j++].rules.length;
        pos += mod.rules.length;
        j++;
      }
    }
    if (sheet) {
      if (root.adoptedStyleSheets.indexOf(this.sheet) < 0) root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets];
    } else {
      let text = "";
      for (let i = 0; i < this.modules.length; i++) text += this.modules[i].getRules() + "\n";
      this.styleTag.textContent = text;
      let target = root.head || root;
      if (this.styleTag.parentNode != target) target.insertBefore(this.styleTag, target.firstChild);
    }
  }
  setNonce(nonce) {
    if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce) this.styleTag.setAttribute("nonce", nonce);
  }
}

/***/ }),

/***/ 2045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Regular-webfont.svg";

/***/ }),

/***/ 2063:
/***/ ((module) => {

module.exports = function () {
  return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;
};

/***/ }),

/***/ 2127:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Mode = __webpack_require__(8674);
function NumericData(data) {
  this.mode = Mode.NUMERIC;
  this.data = data.toString();
}
NumericData.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
};
NumericData.prototype.getLength = function getLength() {
  return this.data.length;
};
NumericData.prototype.getBitsLength = function getBitsLength() {
  return NumericData.getBitsLength(this.data.length);
};
NumericData.prototype.write = function write(bitBuffer) {
  let i, group, value;
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3);
    value = parseInt(group, 10);
    bitBuffer.put(value, 10);
  }
  const remainingNum = this.data.length - i;
  if (remainingNum > 0) {
    group = this.data.substr(i);
    value = parseInt(group, 10);
    bitBuffer.put(value, remainingNum * 3 + 1);
  }
};
module.exports = NumericData;

/***/ }),

/***/ 2187:
/***/ ((module) => {

"use strict";


module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ 2211:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8095);
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7968);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `.flatpickr-calendar{background:transparent;opacity:0;display:none;text-align:center;visibility:hidden;padding:0;-webkit-animation:none;animation:none;direction:ltr;border:0;font-size:14px;line-height:24px;border-radius:5px;position:absolute;width:307.875px;-webkit-box-sizing:border-box;box-sizing:border-box;-ms-touch-action:manipulation;touch-action:manipulation;background:#fff;-webkit-box-shadow:1px 0 0 #e6e6e6,-1px 0 0 #e6e6e6,0 1px 0 #e6e6e6,0 -1px 0 #e6e6e6,0 3px 13px rgba(0,0,0,0.08);box-shadow:1px 0 0 #e6e6e6,-1px 0 0 #e6e6e6,0 1px 0 #e6e6e6,0 -1px 0 #e6e6e6,0 3px 13px rgba(0,0,0,0.08)}.flatpickr-calendar.open,.flatpickr-calendar.inline{opacity:1;max-height:640px;visibility:visible}.flatpickr-calendar.open{display:inline-block;z-index:99999}.flatpickr-calendar.animate.open{-webkit-animation:fpFadeInDown 300ms cubic-bezier(.23,1,.32,1);animation:fpFadeInDown 300ms cubic-bezier(.23,1,.32,1)}.flatpickr-calendar.inline{display:block;position:relative;top:2px}.flatpickr-calendar.static{position:absolute;top:calc(100% + 2px)}.flatpickr-calendar.static.open{z-index:999;display:block}.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+1) .flatpickr-day.inRange:nth-child(7n+7){-webkit-box-shadow:none !important;box-shadow:none !important}.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+2) .flatpickr-day.inRange:nth-child(7n+1){-webkit-box-shadow:-2px 0 0 #e6e6e6,5px 0 0 #e6e6e6;box-shadow:-2px 0 0 #e6e6e6,5px 0 0 #e6e6e6}.flatpickr-calendar .hasWeeks .dayContainer,.flatpickr-calendar .hasTime .dayContainer{border-bottom:0;border-bottom-right-radius:0;border-bottom-left-radius:0}.flatpickr-calendar .hasWeeks .dayContainer{border-left:0}.flatpickr-calendar.hasTime .flatpickr-time{height:40px;border-top:1px solid #e6e6e6}.flatpickr-calendar.noCalendar.hasTime .flatpickr-time{height:auto}.flatpickr-calendar:before,.flatpickr-calendar:after{position:absolute;display:block;pointer-events:none;border:solid transparent;content:'';height:0;width:0;left:22px}.flatpickr-calendar.rightMost:before,.flatpickr-calendar.arrowRight:before,.flatpickr-calendar.rightMost:after,.flatpickr-calendar.arrowRight:after{left:auto;right:22px}.flatpickr-calendar.arrowCenter:before,.flatpickr-calendar.arrowCenter:after{left:50%;right:50%}.flatpickr-calendar:before{border-width:5px;margin:0 -5px}.flatpickr-calendar:after{border-width:4px;margin:0 -4px}.flatpickr-calendar.arrowTop:before,.flatpickr-calendar.arrowTop:after{bottom:100%}.flatpickr-calendar.arrowTop:before{border-bottom-color:#e6e6e6}.flatpickr-calendar.arrowTop:after{border-bottom-color:#fff}.flatpickr-calendar.arrowBottom:before,.flatpickr-calendar.arrowBottom:after{top:100%}.flatpickr-calendar.arrowBottom:before{border-top-color:#e6e6e6}.flatpickr-calendar.arrowBottom:after{border-top-color:#fff}.flatpickr-calendar:focus{outline:0}.flatpickr-wrapper{position:relative;display:inline-block}.flatpickr-months{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.flatpickr-months .flatpickr-month{background:transparent;color:rgba(0,0,0,0.9);fill:rgba(0,0,0,0.9);height:34px;line-height:1;text-align:center;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;overflow:hidden;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.flatpickr-months .flatpickr-prev-month,.flatpickr-months .flatpickr-next-month{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;text-decoration:none;cursor:pointer;position:absolute;top:0;height:34px;padding:10px;z-index:3;color:rgba(0,0,0,0.9);fill:rgba(0,0,0,0.9)}.flatpickr-months .flatpickr-prev-month.flatpickr-disabled,.flatpickr-months .flatpickr-next-month.flatpickr-disabled{display:none}.flatpickr-months .flatpickr-prev-month i,.flatpickr-months .flatpickr-next-month i{position:relative}.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,.flatpickr-months .flatpickr-next-month.flatpickr-prev-month{/*
      /*rtl:begin:ignore*/left:0/*
      /*rtl:end:ignore*/}/*
      /*rtl:begin:ignore*/
/*
      /*rtl:end:ignore*/
.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,.flatpickr-months .flatpickr-next-month.flatpickr-next-month{/*
      /*rtl:begin:ignore*/right:0/*
      /*rtl:end:ignore*/}/*
      /*rtl:begin:ignore*/
/*
      /*rtl:end:ignore*/
.flatpickr-months .flatpickr-prev-month:hover,.flatpickr-months .flatpickr-next-month:hover{color:#959ea9}.flatpickr-months .flatpickr-prev-month:hover svg,.flatpickr-months .flatpickr-next-month:hover svg{fill:#f64747}.flatpickr-months .flatpickr-prev-month svg,.flatpickr-months .flatpickr-next-month svg{width:14px;height:14px}.flatpickr-months .flatpickr-prev-month svg path,.flatpickr-months .flatpickr-next-month svg path{-webkit-transition:fill .1s;transition:fill .1s;fill:inherit}.numInputWrapper{position:relative;height:auto}.numInputWrapper input,.numInputWrapper span{display:inline-block}.numInputWrapper input{width:100%}.numInputWrapper input::-ms-clear{display:none}.numInputWrapper input::-webkit-outer-spin-button,.numInputWrapper input::-webkit-inner-spin-button{margin:0;-webkit-appearance:none}.numInputWrapper span{position:absolute;right:0;width:14px;padding:0 4px 0 2px;height:50%;line-height:50%;opacity:0;cursor:pointer;border:1px solid rgba(57,57,57,0.15);-webkit-box-sizing:border-box;box-sizing:border-box}.numInputWrapper span:hover{background:rgba(0,0,0,0.1)}.numInputWrapper span:active{background:rgba(0,0,0,0.2)}.numInputWrapper span:after{display:block;content:"";position:absolute}.numInputWrapper span.arrowUp{top:0;border-bottom:0}.numInputWrapper span.arrowUp:after{border-left:4px solid transparent;border-right:4px solid transparent;border-bottom:4px solid rgba(57,57,57,0.6);top:26%}.numInputWrapper span.arrowDown{top:50%}.numInputWrapper span.arrowDown:after{border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid rgba(57,57,57,0.6);top:40%}.numInputWrapper span svg{width:inherit;height:auto}.numInputWrapper span svg path{fill:rgba(0,0,0,0.5)}.numInputWrapper:hover{background:rgba(0,0,0,0.05)}.numInputWrapper:hover span{opacity:1}.flatpickr-current-month{font-size:135%;line-height:inherit;font-weight:300;color:inherit;position:absolute;width:75%;left:12.5%;padding:7.48px 0 0 0;line-height:1;height:34px;display:inline-block;text-align:center;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}.flatpickr-current-month span.cur-month{font-family:inherit;font-weight:700;color:inherit;display:inline-block;margin-left:.5ch;padding:0}.flatpickr-current-month span.cur-month:hover{background:rgba(0,0,0,0.05)}.flatpickr-current-month .numInputWrapper{width:6ch;width:7ch\\0;display:inline-block}.flatpickr-current-month .numInputWrapper span.arrowUp:after{border-bottom-color:rgba(0,0,0,0.9)}.flatpickr-current-month .numInputWrapper span.arrowDown:after{border-top-color:rgba(0,0,0,0.9)}.flatpickr-current-month input.cur-year{background:transparent;-webkit-box-sizing:border-box;box-sizing:border-box;color:inherit;cursor:text;padding:0 0 0 .5ch;margin:0;display:inline-block;font-size:inherit;font-family:inherit;font-weight:300;line-height:inherit;height:auto;border:0;border-radius:0;vertical-align:initial;-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield}.flatpickr-current-month input.cur-year:focus{outline:0}.flatpickr-current-month input.cur-year[disabled],.flatpickr-current-month input.cur-year[disabled]:hover{font-size:100%;color:rgba(0,0,0,0.5);background:transparent;pointer-events:none}.flatpickr-current-month .flatpickr-monthDropdown-months{appearance:menulist;background:transparent;border:none;border-radius:0;box-sizing:border-box;color:inherit;cursor:pointer;font-size:inherit;font-family:inherit;font-weight:300;height:auto;line-height:inherit;margin:-1px 0 0 0;outline:none;padding:0 0 0 .5ch;position:relative;vertical-align:initial;-webkit-box-sizing:border-box;-webkit-appearance:menulist;-moz-appearance:menulist;width:auto}.flatpickr-current-month .flatpickr-monthDropdown-months:focus,.flatpickr-current-month .flatpickr-monthDropdown-months:active{outline:none}.flatpickr-current-month .flatpickr-monthDropdown-months:hover{background:rgba(0,0,0,0.05)}.flatpickr-current-month .flatpickr-monthDropdown-months .flatpickr-monthDropdown-month{background-color:transparent;outline:none;padding:0}.flatpickr-weekdays{background:transparent;text-align:center;overflow:hidden;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;height:28px}.flatpickr-weekdays .flatpickr-weekdaycontainer{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}span.flatpickr-weekday{cursor:default;font-size:90%;background:transparent;color:rgba(0,0,0,0.54);line-height:1;margin:0;text-align:center;display:block;-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;font-weight:bolder}.dayContainer,.flatpickr-weeks{padding:1px 0 0 0}.flatpickr-days{position:relative;overflow:hidden;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;width:307.875px}.flatpickr-days:focus{outline:0}.dayContainer{padding:0;outline:0;text-align:left;width:307.875px;min-width:307.875px;max-width:307.875px;-webkit-box-sizing:border-box;box-sizing:border-box;display:inline-block;display:-ms-flexbox;display:-webkit-box;display:-webkit-flex;display:flex;-webkit-flex-wrap:wrap;flex-wrap:wrap;-ms-flex-wrap:wrap;-ms-flex-pack:justify;-webkit-justify-content:space-around;justify-content:space-around;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0);opacity:1}.dayContainer + .dayContainer{-webkit-box-shadow:-1px 0 0 #e6e6e6;box-shadow:-1px 0 0 #e6e6e6}.flatpickr-day{background:none;border:1px solid transparent;border-radius:150px;-webkit-box-sizing:border-box;box-sizing:border-box;color:#393939;cursor:pointer;font-weight:400;width:14.2857143%;-webkit-flex-basis:14.2857143%;-ms-flex-preferred-size:14.2857143%;flex-basis:14.2857143%;max-width:39px;height:39px;line-height:39px;margin:0;display:inline-block;position:relative;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;text-align:center}.flatpickr-day.inRange,.flatpickr-day.prevMonthDay.inRange,.flatpickr-day.nextMonthDay.inRange,.flatpickr-day.today.inRange,.flatpickr-day.prevMonthDay.today.inRange,.flatpickr-day.nextMonthDay.today.inRange,.flatpickr-day:hover,.flatpickr-day.prevMonthDay:hover,.flatpickr-day.nextMonthDay:hover,.flatpickr-day:focus,.flatpickr-day.prevMonthDay:focus,.flatpickr-day.nextMonthDay:focus{cursor:pointer;outline:0;background:#e6e6e6;border-color:#e6e6e6}.flatpickr-day.today{border-color:#959ea9}.flatpickr-day.today:hover,.flatpickr-day.today:focus{border-color:#959ea9;background:#959ea9;color:#fff}.flatpickr-day.selected,.flatpickr-day.startRange,.flatpickr-day.endRange,.flatpickr-day.selected.inRange,.flatpickr-day.startRange.inRange,.flatpickr-day.endRange.inRange,.flatpickr-day.selected:focus,.flatpickr-day.startRange:focus,.flatpickr-day.endRange:focus,.flatpickr-day.selected:hover,.flatpickr-day.startRange:hover,.flatpickr-day.endRange:hover,.flatpickr-day.selected.prevMonthDay,.flatpickr-day.startRange.prevMonthDay,.flatpickr-day.endRange.prevMonthDay,.flatpickr-day.selected.nextMonthDay,.flatpickr-day.startRange.nextMonthDay,.flatpickr-day.endRange.nextMonthDay{background:#569ff7;-webkit-box-shadow:none;box-shadow:none;color:#fff;border-color:#569ff7}.flatpickr-day.selected.startRange,.flatpickr-day.startRange.startRange,.flatpickr-day.endRange.startRange{border-radius:50px 0 0 50px}.flatpickr-day.selected.endRange,.flatpickr-day.startRange.endRange,.flatpickr-day.endRange.endRange{border-radius:0 50px 50px 0}.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n+1)),.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n+1)),.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n+1)){-webkit-box-shadow:-10px 0 0 #569ff7;box-shadow:-10px 0 0 #569ff7}.flatpickr-day.selected.startRange.endRange,.flatpickr-day.startRange.startRange.endRange,.flatpickr-day.endRange.startRange.endRange{border-radius:50px}.flatpickr-day.inRange{border-radius:0;-webkit-box-shadow:-5px 0 0 #e6e6e6,5px 0 0 #e6e6e6;box-shadow:-5px 0 0 #e6e6e6,5px 0 0 #e6e6e6}.flatpickr-day.flatpickr-disabled,.flatpickr-day.flatpickr-disabled:hover,.flatpickr-day.prevMonthDay,.flatpickr-day.nextMonthDay,.flatpickr-day.notAllowed,.flatpickr-day.notAllowed.prevMonthDay,.flatpickr-day.notAllowed.nextMonthDay{color:rgba(57,57,57,0.3);background:transparent;border-color:transparent;cursor:default}.flatpickr-day.flatpickr-disabled,.flatpickr-day.flatpickr-disabled:hover{cursor:not-allowed;color:rgba(57,57,57,0.1)}.flatpickr-day.week.selected{border-radius:0;-webkit-box-shadow:-5px 0 0 #569ff7,5px 0 0 #569ff7;box-shadow:-5px 0 0 #569ff7,5px 0 0 #569ff7}.flatpickr-day.hidden{visibility:hidden}.rangeMode .flatpickr-day{margin-top:1px}.flatpickr-weekwrapper{float:left}.flatpickr-weekwrapper .flatpickr-weeks{padding:0 12px;-webkit-box-shadow:1px 0 0 #e6e6e6;box-shadow:1px 0 0 #e6e6e6}.flatpickr-weekwrapper .flatpickr-weekday{float:none;width:100%;line-height:28px}.flatpickr-weekwrapper span.flatpickr-day,.flatpickr-weekwrapper span.flatpickr-day:hover{display:block;width:100%;max-width:none;color:rgba(57,57,57,0.3);background:transparent;cursor:default;border:none}.flatpickr-innerContainer{display:block;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden}.flatpickr-rContainer{display:inline-block;padding:0;-webkit-box-sizing:border-box;box-sizing:border-box}.flatpickr-time{text-align:center;outline:0;display:block;height:0;line-height:40px;max-height:40px;-webkit-box-sizing:border-box;box-sizing:border-box;overflow:hidden;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex}.flatpickr-time:after{content:"";display:table;clear:both}.flatpickr-time .numInputWrapper{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1;width:40%;height:40px;float:left}.flatpickr-time .numInputWrapper span.arrowUp:after{border-bottom-color:#393939}.flatpickr-time .numInputWrapper span.arrowDown:after{border-top-color:#393939}.flatpickr-time.hasSeconds .numInputWrapper{width:26%}.flatpickr-time.time24hr .numInputWrapper{width:49%}.flatpickr-time input{background:transparent;-webkit-box-shadow:none;box-shadow:none;border:0;border-radius:0;text-align:center;margin:0;padding:0;height:inherit;line-height:inherit;color:#393939;font-size:14px;position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield}.flatpickr-time input.flatpickr-hour{font-weight:bold}.flatpickr-time input.flatpickr-minute,.flatpickr-time input.flatpickr-second{font-weight:400}.flatpickr-time input:focus{outline:0;border:0}.flatpickr-time .flatpickr-time-separator,.flatpickr-time .flatpickr-am-pm{height:inherit;float:left;line-height:inherit;color:#393939;font-weight:bold;width:2%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-align-self:center;-ms-flex-item-align:center;align-self:center}.flatpickr-time .flatpickr-am-pm{outline:0;width:18%;cursor:pointer;text-align:center;font-weight:400}.flatpickr-time input:hover,.flatpickr-time .flatpickr-am-pm:hover,.flatpickr-time input:focus,.flatpickr-time .flatpickr-am-pm:focus{background:#eee}.flatpickr-input[readonly]{cursor:pointer}@-webkit-keyframes fpFadeInDown{from{opacity:0;-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0)}to{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}@keyframes fpFadeInDown{from{opacity:0;-webkit-transform:translate3d(0,-20px,0);transform:translate3d(0,-20px,0)}to{opacity:1;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 2213:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Light-webfont.svg";

/***/ }),

/***/ 2221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Regular-webfont.ttf";

/***/ }),

/***/ 2612:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Aj: () => (/* binding */ ContextTracker),
/* harmony export */   Lu: () => (/* binding */ ExternalTokenizer),
/* harmony export */   U1: () => (/* binding */ LRParser),
/* harmony export */   uC: () => (/* binding */ LocalTokenGroup)
/* harmony export */ });
/* unused harmony exports InputStream, Stack */
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

class Stack {
  constructor(p, stack, state, reducePos, pos, score, buffer, bufferBase, curContext, lookAhead, parent) {
    if (lookAhead === void 0) {
      lookAhead = 0;
    }
    this.p = p;
    this.stack = stack;
    this.state = state;
    this.reducePos = reducePos;
    this.pos = pos;
    this.score = score;
    this.buffer = buffer;
    this.bufferBase = bufferBase;
    this.curContext = curContext;
    this.lookAhead = lookAhead;
    this.parent = parent;
  }
  toString() {
    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(p, state, pos) {
    if (pos === void 0) {
      pos = 0;
    }
    let cx = p.parser.context;
    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(state, start) {
    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
    this.state = state;
  }
  reduce(action) {
    var _a;
    let depth = action >> 19,
      type = action & 65535;
    let {
      parser
    } = this.p;
    let lookaheadRecord = this.reducePos < this.pos - 25;
    if (lookaheadRecord) this.setLookAhead(this.pos);
    let dPrec = parser.dynamicPrecedence(type);
    if (dPrec) this.score += dPrec;
    if (depth == 0) {
      this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, lookaheadRecord ? 8 : 4, true);
      this.reduceContext(type, this.reducePos);
      return;
    }
    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 ? 6 : 0);
    let start = base ? this.stack[base - 2] : this.p.ranges[0].from,
      size = this.reducePos - start;
    if (size >= 2000 && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
      if (start == this.p.lastBigReductionStart) {
        this.p.bigReductionCount++;
        this.p.lastBigReductionSize = size;
      } else if (this.p.lastBigReductionSize < size) {
        this.p.bigReductionCount = 1;
        this.p.lastBigReductionStart = start;
        this.p.lastBigReductionSize = size;
      }
    }
    let bufferBase = base ? this.stack[base - 1] : 0,
      count = this.bufferBase + this.buffer.length - bufferBase;
    if (type < parser.minRepeatTerm || action & 131072) {
      let pos = parser.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(type, start, pos, count + 4, true);
    }
    if (action & 262144) {
      this.state = this.stack[base];
    } else {
      let baseStateID = this.stack[base - 3];
      this.state = parser.getGoto(baseStateID, type, true);
    }
    while (this.stack.length > base) this.stack.pop();
    this.reduceContext(type, start);
  }
  storeNode(term, start, end, size, mustSink) {
    if (size === void 0) {
      size = 4;
    }
    if (mustSink === void 0) {
      mustSink = false;
    }
    if (term == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let cur = this,
        top = this.buffer.length;
      if (top == 0 && cur.parent) {
        top = cur.bufferBase - cur.parent.bufferBase;
        cur = cur.parent;
      }
      if (top > 0 && cur.buffer[top - 4] == 0 && cur.buffer[top - 1] > -1) {
        if (start == end) return;
        if (cur.buffer[top - 2] >= start) {
          cur.buffer[top - 2] = end;
          return;
        }
      }
    }
    if (!mustSink || this.pos == end) {
      this.buffer.push(term, start, end, size);
    } else {
      let index = this.buffer.length;
      if (index > 0 && this.buffer[index - 4] != 0) {
        let mustMove = false;
        for (let scan = index; scan > 0 && this.buffer[scan - 2] > end; scan -= 4) {
          if (this.buffer[scan - 1] >= 0) {
            mustMove = true;
            break;
          }
        }
        if (mustMove) while (index > 0 && this.buffer[index - 2] > end) {
          this.buffer[index] = this.buffer[index - 4];
          this.buffer[index + 1] = this.buffer[index - 3];
          this.buffer[index + 2] = this.buffer[index - 2];
          this.buffer[index + 3] = this.buffer[index - 1];
          index -= 4;
          if (size > 4) size -= 4;
        }
      }
      this.buffer[index] = term;
      this.buffer[index + 1] = start;
      this.buffer[index + 2] = end;
      this.buffer[index + 3] = size;
    }
  }
  shift(action, type, start, end) {
    if (action & 131072) {
      this.pushState(action & 65535, this.pos);
    } else if ((action & 262144) == 0) {
      let nextState = action,
        {
          parser
        } = this.p;
      if (end > this.pos || type <= parser.maxNode) {
        this.pos = end;
        if (!parser.stateFlag(nextState, 1)) this.reducePos = end;
      }
      this.pushState(nextState, start);
      this.shiftContext(type, start);
      if (type <= parser.maxNode) this.buffer.push(type, start, end, 4);
    } else {
      this.pos = end;
      this.shiftContext(type, start);
      if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);
    }
  }
  apply(action, next, nextStart, nextEnd) {
    if (action & 65536) this.reduce(action);else this.shift(action, next, nextStart, nextEnd);
  }
  useNode(value, next) {
    let index = this.p.reused.length - 1;
    if (index < 0 || this.p.reused[index] != value) {
      this.p.reused.push(value);
      index++;
    }
    let start = this.pos;
    this.reducePos = this.pos = start + value.length;
    this.pushState(next, start);
    this.buffer.push(index, start, this.reducePos, -1);
    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
  }
  split() {
    let parent = this;
    let off = parent.buffer.length;
    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4;
    let buffer = parent.buffer.slice(off),
      base = parent.bufferBase + off;
    while (parent && base == parent.bufferBase) parent = parent.parent;
    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
  }
  recoverByDelete(next, nextEnd) {
    let isNode = next <= this.p.parser.maxNode;
    if (isNode) this.storeNode(next, this.pos, nextEnd, 4);
    this.storeNode(0, this.pos, nextEnd, isNode ? 8 : 4);
    this.pos = this.reducePos = nextEnd;
    this.score -= 190;
  }
  canShift(term) {
    for (let sim = new SimulatedStack(this);;) {
      let action = this.p.parser.stateSlot(sim.state, 4) || this.p.parser.hasAction(sim.state, term);
      if (action == 0) return false;
      if ((action & 65536) == 0) return true;
      sim.reduce(action);
    }
  }
  recoverByInsert(next) {
    if (this.stack.length >= 300) return [];
    let nextStates = this.p.parser.nextStates(this.state);
    if (nextStates.length > 4 << 1 || this.stack.length >= 120) {
      let best = [];
      for (let i = 0, s; i < nextStates.length; i += 2) {
        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);
      }
      if (this.stack.length < 120) for (let i = 0; best.length < 4 << 1 && i < nextStates.length; i += 2) {
        let s = nextStates[i + 1];
        if (!best.some((v, i) => i & 1 && v == s)) best.push(nextStates[i], s);
      }
      nextStates = best;
    }
    let result = [];
    for (let i = 0; i < nextStates.length && result.length < 4; i += 2) {
      let s = nextStates[i + 1];
      if (s == this.state) continue;
      let stack = this.split();
      stack.pushState(s, this.pos);
      stack.storeNode(0, stack.pos, stack.pos, 4, true);
      stack.shiftContext(nextStates[i], this.pos);
      stack.reducePos = this.pos;
      stack.score -= 200;
      result.push(stack);
    }
    return result;
  }
  forceReduce() {
    let {
      parser
    } = this.p;
    let reduce = parser.stateSlot(this.state, 5);
    if ((reduce & 65536) == 0) return false;
    if (!parser.validAction(this.state, reduce)) {
      let depth = reduce >> 19,
        term = reduce & 65535;
      let target = this.stack.length - depth * 3;
      if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {
        let backup = this.findForcedReduction();
        if (backup == null) return false;
        reduce = backup;
      }
      this.storeNode(0, this.pos, this.pos, 4, true);
      this.score -= 100;
    }
    this.reducePos = this.pos;
    this.reduce(reduce);
    return true;
  }
  findForcedReduction() {
    let {
        parser
      } = this.p,
      seen = [];
    let explore = (state, depth) => {
      if (seen.includes(state)) return;
      seen.push(state);
      return parser.allActions(state, action => {
        if (action & (262144 | 131072)) ;else if (action & 65536) {
          let rDepth = (action >> 19) - depth;
          if (rDepth > 1) {
            let term = action & 65535,
              target = this.stack.length - rDepth * 3;
            if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 | 65536 | term;
          }
        } else {
          let found = explore(action, depth + 1);
          if (found != null) return found;
        }
      });
    };
    return explore(this.state, 0);
  }
  forceAll() {
    while (!this.p.parser.stateFlag(this.state, 2)) {
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, true);
        break;
      }
    }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3) return false;
    let {
      parser
    } = this.p;
    return parser.data[parser.stateSlot(this.state, 1)] == 65535 && !parser.stateSlot(this.state, 4);
  }
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, true);
    this.state = this.stack[0];
    this.stack.length = 0;
  }
  sameState(other) {
    if (this.state != other.state || this.stack.length != other.stack.length) return false;
    for (let i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false;
    return true;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(dialectID) {
    return this.p.parser.dialect.flags[dialectID];
  }
  shiftContext(term, start) {
    if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  reduceContext(term, start) {
    if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
  }
  emitContext() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  emitLookAhead() {
    let last = this.buffer.length - 1;
    if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(context) {
    if (context != this.curContext.context) {
      let newCx = new StackContext(this.curContext.tracker, context);
      if (newCx.hash != this.curContext.hash) this.emitContext();
      this.curContext = newCx;
    }
  }
  setLookAhead(lookAhead) {
    if (lookAhead > this.lookAhead) {
      this.emitLookAhead();
      this.lookAhead = lookAhead;
    }
  }
  close() {
    if (this.curContext && this.curContext.tracker.strict) this.emitContext();
    if (this.lookAhead > 0) this.emitLookAhead();
  }
}
class StackContext {
  constructor(tracker, context) {
    this.tracker = tracker;
    this.context = context;
    this.hash = tracker.strict ? tracker.hash(context) : 0;
  }
}
class SimulatedStack {
  constructor(start) {
    this.start = start;
    this.state = start.state;
    this.stack = start.stack;
    this.base = this.stack.length;
  }
  reduce(action) {
    let term = action & 65535,
      depth = action >> 19;
    if (depth == 0) {
      if (this.stack == this.start.stack) this.stack = this.stack.slice();
      this.stack.push(this.state, 0, 0);
      this.base += 3;
    } else {
      this.base -= (depth - 1) * 3;
    }
    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
    this.state = goto;
  }
}
class StackBufferCursor {
  constructor(stack, pos, index) {
    this.stack = stack;
    this.pos = pos;
    this.index = index;
    this.buffer = stack.buffer;
    if (this.index == 0) this.maybeNext();
  }
  static create(stack, pos) {
    if (pos === void 0) {
      pos = stack.bufferBase + stack.buffer.length;
    }
    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
  }
  maybeNext() {
    let next = this.stack.parent;
    if (next != null) {
      this.index = this.stack.bufferBase - next.bufferBase;
      this.stack = next;
      this.buffer = next.buffer;
    }
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4;
    this.pos -= 4;
    if (this.index == 0) this.maybeNext();
  }
  fork() {
    return new StackBufferCursor(this.stack, this.pos, this.index);
  }
}
function decodeArray(input, Type) {
  if (Type === void 0) {
    Type = Uint16Array;
  }
  if (typeof input != "string") return input;
  let array = null;
  for (let pos = 0, out = 0; pos < input.length;) {
    let value = 0;
    for (;;) {
      let next = input.charCodeAt(pos++),
        stop = false;
      if (next == 126) {
        value = 65535;
        break;
      }
      if (next >= 92) next--;
      if (next >= 34) next--;
      let digit = next - 32;
      if (digit >= 46) {
        digit -= 46;
        stop = true;
      }
      value += digit;
      if (stop) break;
      value *= 46;
    }
    if (array) array[out++] = value;else array = new Type(value);
  }
  return array;
}
class CachedToken {
  constructor() {
    this.start = -1;
    this.value = -1;
    this.end = -1;
    this.extended = -1;
    this.lookAhead = 0;
    this.mask = 0;
    this.context = 0;
  }
}
const nullToken = new CachedToken();
class InputStream {
  constructor(input, ranges) {
    this.input = input;
    this.ranges = ranges;
    this.chunk = "";
    this.chunkOff = 0;
    this.chunk2 = "";
    this.chunk2Pos = 0;
    this.next = -1;
    this.token = nullToken;
    this.rangeIndex = 0;
    this.pos = this.chunkPos = ranges[0].from;
    this.range = ranges[0];
    this.end = ranges[ranges.length - 1].to;
    this.readNext();
  }
  resolveOffset(offset, assoc) {
    let range = this.range,
      index = this.rangeIndex;
    let pos = this.pos + offset;
    while (pos < range.from) {
      if (!index) return null;
      let next = this.ranges[--index];
      pos -= range.from - next.to;
      range = next;
    }
    while (assoc < 0 ? pos > range.to : pos >= range.to) {
      if (index == this.ranges.length - 1) return null;
      let next = this.ranges[++index];
      pos += next.from - range.to;
      range = next;
    }
    return pos;
  }
  clipPos(pos) {
    if (pos >= this.range.from && pos < this.range.to) return pos;
    for (var _iterator = _createForOfIteratorHelperLoose(this.ranges), _step; !(_step = _iterator()).done;) {
      let range = _step.value;
      if (range.to > pos) return Math.max(pos, range.from);
    }
    return this.end;
  }
  peek(offset) {
    let idx = this.chunkOff + offset,
      pos,
      result;
    if (idx >= 0 && idx < this.chunk.length) {
      pos = this.pos + offset;
      result = this.chunk.charCodeAt(idx);
    } else {
      let resolved = this.resolveOffset(offset, 1);
      if (resolved == null) return -1;
      pos = resolved;
      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
      } else {
        let i = this.rangeIndex,
          range = this.range;
        while (range.to <= pos) range = this.ranges[++i];
        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
        if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);
        result = this.chunk2.charCodeAt(0);
      }
    }
    if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;
    return result;
  }
  acceptToken(token, endOffset) {
    if (endOffset === void 0) {
      endOffset = 0;
    }
    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
    if (end == null || end < this.token.start) throw new RangeError("Token end out of bounds");
    this.token.value = token;
    this.token.end = end;
  }
  acceptTokenTo(token, endPos) {
    this.token.value = token;
    this.token.end = endPos;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let {
        chunk,
        chunkPos
      } = this;
      this.chunk = this.chunk2;
      this.chunkPos = this.chunk2Pos;
      this.chunk2 = chunk;
      this.chunk2Pos = chunkPos;
      this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk;
      this.chunk2Pos = this.chunkPos;
      let nextChunk = this.input.chunk(this.pos);
      let end = this.pos + nextChunk.length;
      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
      this.chunkPos = this.pos;
      this.chunkOff = 0;
    }
  }
  readNext() {
    if (this.chunkOff >= this.chunk.length) {
      this.getChunk();
      if (this.chunkOff == this.chunk.length) return this.next = -1;
    }
    return this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(n) {
    if (n === void 0) {
      n = 1;
    }
    this.chunkOff += n;
    while (this.pos + n >= this.range.to) {
      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();
      n -= this.range.to - this.pos;
      this.range = this.ranges[++this.rangeIndex];
      this.pos = this.range.from;
    }
    this.pos += n;
    if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;
    return this.readNext();
  }
  setDone() {
    this.pos = this.chunkPos = this.end;
    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
    this.chunk = "";
    return this.next = -1;
  }
  reset(pos, token) {
    if (token) {
      this.token = token;
      token.start = pos;
      token.lookAhead = pos + 1;
      token.value = token.extended = -1;
    } else {
      this.token = nullToken;
    }
    if (this.pos != pos) {
      this.pos = pos;
      if (pos == this.end) {
        this.setDone();
        return this;
      }
      while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex];
      while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex];
      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
        this.chunkOff = pos - this.chunkPos;
      } else {
        this.chunk = "";
        this.chunkOff = 0;
      }
      this.readNext();
    }
    return this;
  }
  read(from, to) {
    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
    if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);
    let result = "";
    for (var _iterator2 = _createForOfIteratorHelperLoose(this.ranges), _step2; !(_step2 = _iterator2()).done;) {
      let r = _step2.value;
      if (r.from >= to) break;
      if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
    }
    return result;
  }
}
class TokenGroup {
  constructor(data, id) {
    this.data = data;
    this.id = id;
  }
  token(input, stack) {
    let {
      parser
    } = stack.p;
    readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);
  }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class LocalTokenGroup {
  constructor(data, precTable, elseToken) {
    this.precTable = precTable;
    this.elseToken = elseToken;
    this.data = typeof data == "string" ? decodeArray(data) : data;
  }
  token(input, stack) {
    let start = input.pos,
      skipped = 0;
    for (;;) {
      let atEof = input.next < 0,
        nextPos = input.resolveOffset(1, 1);
      readToken(this.data, input, stack, 0, this.data, this.precTable);
      if (input.token.value > -1) break;
      if (this.elseToken == null) return;
      if (!atEof) skipped++;
      if (nextPos == null) break;
      input.reset(nextPos, input.token);
    }
    if (skipped) {
      input.reset(start, input.token);
      input.acceptToken(this.elseToken, skipped);
    }
  }
}
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
class ExternalTokenizer {
  constructor(token, options) {
    if (options === void 0) {
      options = {};
    }
    this.token = token;
    this.contextual = !!options.contextual;
    this.fallback = !!options.fallback;
    this.extend = !!options.extend;
  }
}
function readToken(data, input, stack, group, precTable, precOffset) {
  let state = 0,
    groupMask = 1 << group,
    {
      dialect
    } = stack.p.parser;
  scan: for (;;) {
    if ((groupMask & data[state]) == 0) break;
    let accEnd = data[state + 1];
    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {
      let term = data[i];
      if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {
        input.acceptToken(term);
        break;
      }
    }
    let next = input.next,
      low = 0,
      high = data[state + 2];
    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535) {
      state = data[accEnd + high * 3 - 1];
      continue scan;
    }
    for (; low < high;) {
      let mid = low + high >> 1;
      let index = accEnd + mid + (mid << 1);
      let from = data[index],
        to = data[index + 1] || 0x10000;
      if (next < from) high = mid;else if (next >= to) low = mid + 1;else {
        state = data[index + 2];
        input.advance();
        continue scan;
      }
    }
    break;
  }
}
function findOffset(data, start, term) {
  for (let i = start, next; (next = data[i]) != 65535; i++) if (next == term) return i - start;
  return -1;
}
function overrides(token, prev, tableData, tableOffset) {
  let iPrev = findOffset(tableData, tableOffset, prev);
  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}
const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
  let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .IterMode */ .Qj.IncludeAnonymous);
  cursor.moveTo(pos);
  for (;;) {
    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {
      if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25));
      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;
      if (!cursor.parent()) return side < 0 ? 0 : tree.length;
    }
  }
}
class FragmentCursor {
  constructor(fragments, nodeSet) {
    this.fragments = fragments;
    this.nodeSet = nodeSet;
    this.i = 0;
    this.fragment = null;
    this.safeFrom = -1;
    this.safeTo = -1;
    this.trees = [];
    this.start = [];
    this.index = [];
    this.nextFragment();
  }
  nextFragment() {
    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (fr) {
      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
      while (this.trees.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
      }
      this.trees.push(fr.tree);
      this.start.push(-fr.offset);
      this.index.push(0);
      this.nextStart = this.safeFrom;
    } else {
      this.nextStart = 1e9;
    }
  }
  nodeAt(pos) {
    if (pos < this.nextStart) return null;
    while (this.fragment && this.safeTo <= pos) this.nextFragment();
    if (!this.fragment) return null;
    for (;;) {
      let last = this.trees.length - 1;
      if (last < 0) {
        this.nextFragment();
        return null;
      }
      let top = this.trees[last],
        index = this.index[last];
      if (index == top.children.length) {
        this.trees.pop();
        this.start.pop();
        this.index.pop();
        continue;
      }
      let next = top.children[index];
      let start = this.start[last] + top.positions[index];
      if (start > pos) {
        this.nextStart = start;
        return null;
      }
      if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH) {
        if (start == pos) {
          if (start < this.safeFrom) return null;
          let end = start + next.length;
          if (end <= this.safeTo) {
            let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.lookAhead);
            if (!lookAhead || end + lookAhead < this.fragment.to) return next;
          }
        }
        this.index[last]++;
        if (start + next.length >= Math.max(this.safeFrom, pos)) {
          this.trees.push(next);
          this.start.push(start);
          this.index.push(0);
        }
      } else {
        this.index[last]++;
        this.nextStart = start + next.length;
      }
    }
  }
}
class TokenCache {
  constructor(parser, stream) {
    this.stream = stream;
    this.tokens = [];
    this.mainToken = null;
    this.actions = [];
    this.tokens = parser.tokenizers.map(_ => new CachedToken());
  }
  getActions(stack) {
    let actionIndex = 0;
    let main = null;
    let {
        parser
      } = stack.p,
      {
        tokenizers
      } = parser;
    let mask = parser.stateSlot(stack.state, 3);
    let context = stack.curContext ? stack.curContext.hash : 0;
    let lookAhead = 0;
    for (let i = 0; i < tokenizers.length; i++) {
      if ((1 << i & mask) == 0) continue;
      let tokenizer = tokenizers[i],
        token = this.tokens[i];
      if (main && !tokenizer.fallback) continue;
      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
        this.updateCachedToken(token, tokenizer, stack);
        token.mask = mask;
        token.context = context;
      }
      if (token.lookAhead > token.end + 25) lookAhead = Math.max(token.lookAhead, lookAhead);
      if (token.value != 0) {
        let startIndex = actionIndex;
        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
        if (!tokenizer.extend) {
          main = token;
          if (actionIndex > startIndex) break;
        }
      }
    }
    while (this.actions.length > actionIndex) this.actions.pop();
    if (lookAhead) stack.setLookAhead(lookAhead);
    if (!main && stack.pos == this.stream.end) {
      main = new CachedToken();
      main.value = stack.p.parser.eofTerm;
      main.start = main.end = stack.pos;
      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
    }
    this.mainToken = main;
    return this.actions;
  }
  getMainToken(stack) {
    if (this.mainToken) return this.mainToken;
    let main = new CachedToken(),
      {
        pos,
        p
      } = stack;
    main.start = pos;
    main.end = Math.min(pos + 1, p.stream.end);
    main.value = pos == p.stream.end ? p.parser.eofTerm : 0;
    return main;
  }
  updateCachedToken(token, tokenizer, stack) {
    let start = this.stream.clipPos(stack.pos);
    tokenizer.token(this.stream.reset(start, token), stack);
    if (token.value > -1) {
      let {
        parser
      } = stack.p;
      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {
        let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
          if ((result & 1) == 0) token.value = result >> 1;else token.extended = result >> 1;
          break;
        }
      }
    } else {
      token.value = 0;
      token.end = this.stream.clipPos(start + 1);
    }
  }
  putAction(action, token, end, index) {
    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index;
    this.actions[index++] = action;
    this.actions[index++] = token;
    this.actions[index++] = end;
    return index;
  }
  addActions(stack, token, end, index) {
    let {
        state
      } = stack,
      {
        parser
      } = stack.p,
      {
        data
      } = parser;
    for (let set = 0; set < 2; set++) {
      for (let i = parser.stateSlot(state, set ? 2 : 1);; i += 3) {
        if (data[i] == 65535) {
          if (data[i + 1] == 1) {
            i = pair(data, i + 2);
          } else {
            if (index == 0 && data[i + 1] == 2) index = this.putAction(pair(data, i + 2), token, end, index);
            break;
          }
        }
        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);
      }
    }
    return index;
  }
}
class Parse {
  constructor(parser, input, fragments, ranges) {
    this.parser = parser;
    this.input = input;
    this.ranges = ranges;
    this.recovering = 0;
    this.nextStackID = 0x2654;
    this.minStackPos = 0;
    this.reused = [];
    this.stoppedAt = null;
    this.lastBigReductionStart = -1;
    this.lastBigReductionSize = 0;
    this.bigReductionCount = 0;
    this.stream = new InputStream(input, ranges);
    this.tokens = new TokenCache(parser, this.stream);
    this.topTerm = parser.top[1];
    let {
      from
    } = ranges[0];
    this.stacks = [Stack.start(this, parser.top[0], from)];
    this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let stacks = this.stacks,
      pos = this.minStackPos;
    let newStacks = this.stacks = [];
    let stopped, stoppedTokens;
    if (this.bigReductionCount > 300 && stacks.length == 1) {
      let [s] = stacks;
      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {}
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i];
      for (;;) {
        this.tokens.mainToken = null;
        if (stack.pos > pos) {
          newStacks.push(stack);
        } else if (this.advanceStack(stack, newStacks, stacks)) {
          continue;
        } else {
          if (!stopped) {
            stopped = [];
            stoppedTokens = [];
          }
          stopped.push(stack);
          let tok = this.tokens.getMainToken(stack);
          stoppedTokens.push(tok.value, tok.end);
        }
        break;
      }
    }
    if (!newStacks.length) {
      let finished = stopped && findFinished(stopped);
      if (finished) {
        if (verbose) console.log("Finish with " + this.stackID(finished));
        return this.stackToTree(finished);
      }
      if (this.parser.strict) {
        if (verbose && stopped) console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
        throw new SyntaxError("No parse at " + pos);
      }
      if (!this.recovering) this.recovering = 5;
    }
    if (this.recovering && stopped) {
      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);
      if (finished) {
        if (verbose) console.log("Force-finish " + this.stackID(finished));
        return this.stackToTree(finished.forceAll());
      }
    }
    if (this.recovering) {
      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3;
      if (newStacks.length > maxRemaining) {
        newStacks.sort((a, b) => b.score - a.score);
        while (newStacks.length > maxRemaining) newStacks.pop();
      }
      if (newStacks.some(s => s.reducePos > pos)) this.recovering--;
    } else if (newStacks.length > 1) {
      outer: for (let i = 0; i < newStacks.length - 1; i++) {
        let stack = newStacks[i];
        for (let j = i + 1; j < newStacks.length; j++) {
          let other = newStacks[j];
          if (stack.sameState(other) || stack.buffer.length > 500 && other.buffer.length > 500) {
            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {
              newStacks.splice(j--, 1);
            } else {
              newStacks.splice(i--, 1);
              continue outer;
            }
          }
        }
      }
      if (newStacks.length > 12) newStacks.splice(12, newStacks.length - 12);
    }
    this.minStackPos = newStacks[0].pos;
    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  advanceStack(stack, stacks, split) {
    let start = stack.pos,
      {
        parser
      } = this;
    let base = verbose ? this.stackID(stack) + " -> " : "";
    if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;
    if (this.fragments) {
      let strictCx = stack.curContext && stack.curContext.tracker.strict,
        cxHash = strictCx ? stack.curContext.hash : 0;
      for (let cached = this.fragments.nodeAt(start); cached;) {
        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
        if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.contextHash) || 0) == cxHash)) {
          stack.useNode(cached, match);
          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
          return true;
        }
        if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH) || cached.children.length == 0 || cached.positions[0] > 0) break;
        let inner = cached.children[0];
        if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH && cached.positions[0] == 0) cached = inner;else break;
      }
    }
    let defaultReduce = parser.stateSlot(stack.state, 4);
    if (defaultReduce > 0) {
      stack.reduce(defaultReduce);
      if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535)})`);
      return true;
    }
    if (stack.stack.length >= 8400) {
      while (stack.stack.length > 6000 && stack.forceReduce()) {}
    }
    let actions = this.tokens.getActions(stack);
    for (let i = 0; i < actions.length;) {
      let action = actions[i++],
        term = actions[i++],
        end = actions[i++];
      let last = i == actions.length || !split;
      let localStack = last ? stack : stack.split();
      let main = this.tokens.mainToken;
      localStack.apply(action, term, main ? main.start : localStack.pos, end);
      if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536) == 0 ? "shift" : `reduce of ${parser.getName(action & 65535)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
      if (last) return true;else if (localStack.pos > start) stacks.push(localStack);else split.push(localStack);
    }
    return false;
  }
  advanceFully(stack, newStacks) {
    let pos = stack.pos;
    for (;;) {
      if (!this.advanceStack(stack, null, null)) return false;
      if (stack.pos > pos) {
        pushStackDedup(stack, newStacks);
        return true;
      }
    }
  }
  runRecovery(stacks, tokens, newStacks) {
    let finished = null,
      restarted = false;
    for (let i = 0; i < stacks.length; i++) {
      let stack = stacks[i],
        token = tokens[i << 1],
        tokenEnd = tokens[(i << 1) + 1];
      let base = verbose ? this.stackID(stack) + " -> " : "";
      if (stack.deadEnd) {
        if (restarted) continue;
        restarted = true;
        stack.restart();
        if (verbose) console.log(base + this.stackID(stack) + " (restarted)");
        let done = this.advanceFully(stack, newStacks);
        if (done) continue;
      }
      let force = stack.split(),
        forceBase = base;
      for (let j = 0; force.forceReduce() && j < 10; j++) {
        if (verbose) console.log(forceBase + this.stackID(force) + " (via force-reduce)");
        let done = this.advanceFully(force, newStacks);
        if (done) break;
        if (verbose) forceBase = this.stackID(force) + " -> ";
      }
      for (var _iterator3 = _createForOfIteratorHelperLoose(stack.recoverByInsert(token)), _step3; !(_step3 = _iterator3()).done;) {
        let insert = _step3.value;
        if (verbose) console.log(base + this.stackID(insert) + " (via recover-insert)");
        this.advanceFully(insert, newStacks);
      }
      if (this.stream.end > stack.pos) {
        if (tokenEnd == stack.pos) {
          tokenEnd++;
          token = 0;
        }
        stack.recoverByDelete(token, tokenEnd);
        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
        pushStackDedup(stack, newStacks);
      } else if (!finished || finished.score < stack.score) {
        finished = stack;
      }
    }
    return finished;
  }
  stackToTree(stack) {
    stack.close();
    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.build({
      buffer: StackBufferCursor.create(stack),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: stack.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(stack) {
    let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);
    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
    return id + stack;
  }
}
function pushStackDedup(stack, newStacks) {
  for (let i = 0; i < newStacks.length; i++) {
    let other = newStacks[i];
    if (other.pos == stack.pos && other.sameState(stack)) {
      if (newStacks[i].score < stack.score) newStacks[i] = stack;
      return;
    }
  }
  newStacks.push(stack);
}
class Dialect {
  constructor(source, flags, disabled) {
    this.source = source;
    this.flags = flags;
    this.disabled = disabled;
  }
  allows(term) {
    return !this.disabled || this.disabled[term] == 0;
  }
}
const id = x => x;
class ContextTracker {
  constructor(spec) {
    this.start = spec.start;
    this.shift = spec.shift || id;
    this.reduce = spec.reduce || id;
    this.reuse = spec.reuse || id;
    this.hash = spec.hash || (() => 0);
    this.strict = spec.strict !== false;
  }
}
class LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Parser */ .iX {
  constructor(spec) {
    super();
    this.wrappers = [];
    if (spec.version != 14) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14})`);
    let nodeNames = spec.nodeNames.split(" ");
    this.minRepeatTerm = nodeNames.length;
    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push("");
    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
    let nodeProps = [];
    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([]);
    function setProp(nodeID, prop, value) {
      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
    }
    if (spec.nodeProps) {
      for (var _iterator4 = _createForOfIteratorHelperLoose(spec.nodeProps), _step4; !(_step4 = _iterator4()).done;) {
        let propSpec = _step4.value;
        let prop = propSpec[0];
        if (typeof prop == "string") prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY[prop];
        for (let i = 1; i < propSpec.length;) {
          let next = propSpec[i++];
          if (next >= 0) {
            setProp(next, prop, propSpec[i++]);
          } else {
            let value = propSpec[i + -next];
            for (let j = -next; j > 0; j--) setProp(propSpec[i++], prop, value);
            i++;
          }
        }
      }
    }
    this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeSet */ .fI(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.define({
      name: i >= this.minRepeatTerm ? undefined : name,
      id: i,
      props: nodeProps[i],
      top: topTerms.indexOf(i) > -1,
      error: i == 0,
      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
    })));
    if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);
    this.strict = false;
    this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .DefaultBufferLength */ .cF;
    let tokenArray = decodeArray(spec.tokenData);
    this.context = spec.context;
    this.specializerSpecs = spec.specialized || [];
    this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let i = 0; i < this.specializerSpecs.length; i++) this.specialized[i] = this.specializerSpecs[i].term;
    this.specializers = this.specializerSpecs.map(getSpecializer);
    this.states = decodeArray(spec.states, Uint32Array);
    this.data = decodeArray(spec.stateData);
    this.goto = decodeArray(spec.goto);
    this.maxTerm = spec.maxTerm;
    this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
    this.topRules = spec.topRules;
    this.dialects = spec.dialects || {};
    this.dynamicPrecedences = spec.dynamicPrecedences || null;
    this.tokenPrecTable = spec.tokenPrec;
    this.termNames = spec.termNames || null;
    this.maxNode = this.nodeSet.types.length - 1;
    this.dialect = this.parseDialect();
    this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(input, fragments, ranges) {
    let parse = new Parse(this, input, fragments, ranges);
    for (var _iterator5 = _createForOfIteratorHelperLoose(this.wrappers), _step5; !(_step5 = _iterator5()).done;) {
      let w = _step5.value;
      parse = w(parse, input, fragments, ranges);
    }
    return parse;
  }
  getGoto(state, term, loose) {
    if (loose === void 0) {
      loose = false;
    }
    let table = this.goto;
    if (term >= table[0]) return -1;
    for (let pos = table[term + 1];;) {
      let groupTag = table[pos++],
        last = groupTag & 1;
      let target = table[pos++];
      if (last && loose) return target;
      for (let end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;
      if (last) return -1;
    }
  }
  hasAction(state, terminal) {
    let data = this.data;
    for (let set = 0; set < 2; set++) {
      for (let i = this.stateSlot(state, set ? 2 : 1), next;; i += 3) {
        if ((next = data[i]) == 65535) {
          if (data[i + 1] == 1) next = data[i = pair(data, i + 2)];else if (data[i + 1] == 2) return pair(data, i + 2);else break;
        }
        if (next == terminal || next == 0) return pair(data, i + 1);
      }
    }
    return 0;
  }
  stateSlot(state, slot) {
    return this.states[state * 6 + slot];
  }
  stateFlag(state, flag) {
    return (this.stateSlot(state, 0) & flag) > 0;
  }
  validAction(state, action) {
    return !!this.allActions(state, a => a == action ? true : null);
  }
  allActions(state, action) {
    let deflt = this.stateSlot(state, 4);
    let result = deflt ? action(deflt) : undefined;
    for (let i = this.stateSlot(state, 1); result == null; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1) i = pair(this.data, i + 2);else break;
      }
      result = action(pair(this.data, i + 1));
    }
    return result;
  }
  nextStates(state) {
    let result = [];
    for (let i = this.stateSlot(state, 1);; i += 3) {
      if (this.data[i] == 65535) {
        if (this.data[i + 1] == 1) i = pair(this.data, i + 2);else break;
      }
      if ((this.data[i + 2] & 65536 >> 16) == 0) {
        let value = this.data[i + 1];
        if (!result.some((v, i) => i & 1 && v == value)) result.push(this.data[i], value);
      }
    }
    return result;
  }
  configure(config) {
    let copy = Object.assign(Object.create(LRParser.prototype), this);
    if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);
    if (config.top) {
      let info = this.topRules[config.top];
      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);
      copy.top = info;
    }
    if (config.tokenizers) copy.tokenizers = this.tokenizers.map(t => {
      let found = config.tokenizers.find(r => r.from == t);
      return found ? found.to : t;
    });
    if (config.specializers) {
      copy.specializers = this.specializers.slice();
      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
        let found = config.specializers.find(r => r.from == s.external);
        if (!found) return s;
        let spec = Object.assign(Object.assign({}, s), {
          external: found.to
        });
        copy.specializers[i] = getSpecializer(spec);
        return spec;
      });
    }
    if (config.contextTracker) copy.context = config.contextTracker;
    if (config.dialect) copy.dialect = this.parseDialect(config.dialect);
    if (config.strict != null) copy.strict = config.strict;
    if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);
    if (config.bufferLength != null) copy.bufferLength = config.bufferLength;
    return copy;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(term) {
    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(term) {
    let prec = this.dynamicPrecedences;
    return prec == null ? 0 : prec[term] || 0;
  }
  parseDialect(dialect) {
    let values = Object.keys(this.dialects),
      flags = values.map(() => false);
    if (dialect) {
      for (var _iterator6 = _createForOfIteratorHelperLoose(dialect.split(" ")), _step6; !(_step6 = _iterator6()).done;) {
        let part = _step6.value;
        let id = values.indexOf(part);
        if (id >= 0) flags[id] = true;
      }
    }
    let disabled = null;
    for (let i = 0; i < values.length; i++) if (!flags[i]) {
      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535;) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
    }
    return new Dialect(dialect, flags, disabled);
  }
  static deserialize(spec) {
    return new LRParser(spec);
  }
}
function pair(data, off) {
  return data[off] | data[off + 1] << 16;
}
function findFinished(stacks) {
  let best = null;
  for (var _iterator7 = _createForOfIteratorHelperLoose(stacks), _step7; !(_step7 = _iterator7()).done;) {
    let stack = _step7.value;
    let stopped = stack.p.stoppedAt;
    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2) && (!best || best.score < stack.score)) best = stack;
  }
  return best;
}
function getSpecializer(spec) {
  if (spec.external) {
    let mask = spec.extend ? 1 : 0;
    return (value, stack) => spec.external(value, stack) << 1 | mask;
  }
  return spec.get;
}


/***/ }),

/***/ 2691:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_RESULT__;
(function () {
  var SYNTAX = {
    PATH: 1,
    SELECTOR: 2,
    OBJ_PRED: 3,
    POS_PRED: 4,
    LOGICAL_EXPR: 5,
    COMPARISON_EXPR: 6,
    MATH_EXPR: 7,
    CONCAT_EXPR: 8,
    UNARY_EXPR: 9,
    POS_EXPR: 10,
    LITERAL: 11
  };
  var parse = function () {
    var TOKEN = {
        ID: 1,
        NUM: 2,
        STR: 3,
        BOOL: 4,
        NULL: 5,
        PUNCT: 6,
        EOP: 7
      },
      MESSAGES = {
        UNEXP_TOKEN: 'Unexpected token "%0"',
        UNEXP_EOP: 'Unexpected end of path'
      };
    var path, idx, buf, len;
    function parse(_path) {
      path = _path.split('');
      idx = 0;
      buf = null;
      len = path.length;
      var res = parsePathConcatExpr(),
        token = lex();
      if (token.type !== TOKEN.EOP) {
        throwUnexpected(token);
      }
      return res;
    }
    function parsePathConcatExpr() {
      var expr = parsePathConcatPartExpr(),
        operands;
      while (match('|')) {
        lex();
        (operands || (operands = [expr])).push(parsePathConcatPartExpr());
      }
      return operands ? {
        type: SYNTAX.CONCAT_EXPR,
        args: operands
      } : expr;
    }
    function parsePathConcatPartExpr() {
      return match('(') ? parsePathGroupExpr() : parsePath();
    }
    function parsePathGroupExpr() {
      expect('(');
      var expr = parsePathConcatExpr();
      expect(')');
      var parts = [],
        part;
      while (part = parsePredicate()) {
        parts.push(part);
      }
      if (!parts.length) {
        return expr;
      } else if (expr.type === SYNTAX.PATH) {
        expr.parts = expr.parts.concat(parts);
        return expr;
      }
      parts.unshift(expr);
      return {
        type: SYNTAX.PATH,
        parts: parts
      };
    }
    function parsePredicate() {
      if (match('[')) {
        return parsePosPredicate();
      }
      if (match('{')) {
        return parseObjectPredicate();
      }
      if (match('(')) {
        return parsePathGroupExpr();
      }
    }
    function parsePath() {
      if (!matchPath()) {
        throwUnexpected(lex());
      }
      var fromRoot = false,
        subst;
      if (match('^')) {
        lex();
        fromRoot = true;
      } else if (matchSubst()) {
        subst = lex().val.substr(1);
      }
      var parts = [],
        part;
      while (part = parsePathPart()) {
        parts.push(part);
      }
      return {
        type: SYNTAX.PATH,
        fromRoot: fromRoot,
        subst: subst,
        parts: parts
      };
    }
    function parsePathPart() {
      return matchSelector() ? parseSelector() : parsePredicate();
    }
    function parseSelector() {
      var selector = lex().val,
        token = lookahead(),
        prop;
      if (match('*') || token.type === TOKEN.ID || token.type === TOKEN.STR) {
        prop = lex().val;
      }
      return {
        type: SYNTAX.SELECTOR,
        selector: selector,
        prop: prop
      };
    }
    function parsePosPredicate() {
      expect('[');
      var expr = parsePosExpr();
      expect(']');
      return {
        type: SYNTAX.POS_PRED,
        arg: expr
      };
    }
    function parseObjectPredicate() {
      expect('{');
      var expr = parseLogicalORExpr();
      expect('}');
      return {
        type: SYNTAX.OBJ_PRED,
        arg: expr
      };
    }
    function parseLogicalORExpr() {
      var expr = parseLogicalANDExpr(),
        operands;
      while (match('||')) {
        lex();
        (operands || (operands = [expr])).push(parseLogicalANDExpr());
      }
      return operands ? {
        type: SYNTAX.LOGICAL_EXPR,
        op: '||',
        args: operands
      } : expr;
    }
    function parseLogicalANDExpr() {
      var expr = parseEqualityExpr(),
        operands;
      while (match('&&')) {
        lex();
        (operands || (operands = [expr])).push(parseEqualityExpr());
      }
      return operands ? {
        type: SYNTAX.LOGICAL_EXPR,
        op: '&&',
        args: operands
      } : expr;
    }
    function parseEqualityExpr() {
      var expr = parseRelationalExpr();
      while (match('==') || match('!=') || match('===') || match('!==') || match('^==') || match('==^') || match('^=') || match('=^') || match('$==') || match('==$') || match('$=') || match('=$') || match('*==') || match('==*') || match('*=') || match('=*')) {
        expr = {
          type: SYNTAX.COMPARISON_EXPR,
          op: lex().val,
          args: [expr, parseEqualityExpr()]
        };
      }
      return expr;
    }
    function parseRelationalExpr() {
      var expr = parseAdditiveExpr();
      while (match('<') || match('>') || match('<=') || match('>=')) {
        expr = {
          type: SYNTAX.COMPARISON_EXPR,
          op: lex().val,
          args: [expr, parseRelationalExpr()]
        };
      }
      return expr;
    }
    function parseAdditiveExpr() {
      var expr = parseMultiplicativeExpr();
      while (match('+') || match('-')) {
        expr = {
          type: SYNTAX.MATH_EXPR,
          op: lex().val,
          args: [expr, parseMultiplicativeExpr()]
        };
      }
      return expr;
    }
    function parseMultiplicativeExpr() {
      var expr = parseUnaryExpr();
      while (match('*') || match('/') || match('%')) {
        expr = {
          type: SYNTAX.MATH_EXPR,
          op: lex().val,
          args: [expr, parseMultiplicativeExpr()]
        };
      }
      return expr;
    }
    function parsePosExpr() {
      if (match(':')) {
        lex();
        return {
          type: SYNTAX.POS_EXPR,
          toIdx: parseUnaryExpr()
        };
      }
      var fromExpr = parseUnaryExpr();
      if (match(':')) {
        lex();
        if (match(']')) {
          return {
            type: SYNTAX.POS_EXPR,
            fromIdx: fromExpr
          };
        }
        return {
          type: SYNTAX.POS_EXPR,
          fromIdx: fromExpr,
          toIdx: parseUnaryExpr()
        };
      }
      return {
        type: SYNTAX.POS_EXPR,
        idx: fromExpr
      };
    }
    function parseUnaryExpr() {
      if (match('!') || match('-')) {
        return {
          type: SYNTAX.UNARY_EXPR,
          op: lex().val,
          arg: parseUnaryExpr()
        };
      }
      return parsePrimaryExpr();
    }
    function parsePrimaryExpr() {
      var token = lookahead(),
        type = token.type;
      if (type === TOKEN.STR || type === TOKEN.NUM || type === TOKEN.BOOL || type === TOKEN.NULL) {
        return {
          type: SYNTAX.LITERAL,
          val: lex().val
        };
      }
      if (matchPath()) {
        return parsePath();
      }
      if (match('(')) {
        return parseGroupExpr();
      }
      return throwUnexpected(lex());
    }
    function parseGroupExpr() {
      expect('(');
      var expr = parseLogicalORExpr();
      expect(')');
      return expr;
    }
    function match(val) {
      var token = lookahead();
      return token.type === TOKEN.PUNCT && token.val === val;
    }
    function matchPath() {
      return matchSelector() || matchSubst() || match('^');
    }
    function matchSelector() {
      var token = lookahead();
      if (token.type === TOKEN.PUNCT) {
        var val = token.val;
        return val === '.' || val === '..';
      }
      return false;
    }
    function matchSubst() {
      var token = lookahead();
      return token.type === TOKEN.ID && token.val[0] === '$';
    }
    function expect(val) {
      var token = lex();
      if (token.type !== TOKEN.PUNCT || token.val !== val) {
        throwUnexpected(token);
      }
    }
    function lookahead() {
      if (buf !== null) {
        return buf;
      }
      var pos = idx;
      buf = advance();
      idx = pos;
      return buf;
    }
    function advance() {
      while (isWhiteSpace(path[idx])) {
        ++idx;
      }
      if (idx >= len) {
        return {
          type: TOKEN.EOP,
          range: [idx, idx]
        };
      }
      var token = scanPunctuator();
      if (token || (token = scanId()) || (token = scanString()) || (token = scanNumeric())) {
        return token;
      }
      token = {
        range: [idx, idx]
      };
      idx >= len ? token.type = TOKEN.EOP : token.val = path[idx];
      throwUnexpected(token);
    }
    function lex() {
      var token;
      if (buf) {
        idx = buf.range[1];
        token = buf;
        buf = null;
        return token;
      }
      return advance();
    }
    function isDigit(ch) {
      return '0123456789'.indexOf(ch) >= 0;
    }
    function isWhiteSpace(ch) {
      return ' \r\n\t'.indexOf(ch) > -1;
    }
    function isIdStart(ch) {
      return ch === '$' || ch === '@' || ch === '_' || ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z';
    }
    function isIdPart(ch) {
      return isIdStart(ch) || ch >= '0' && ch <= '9';
    }
    function scanId() {
      var ch = path[idx];
      if (!isIdStart(ch)) {
        return;
      }
      var start = idx,
        id = ch;
      while (++idx < len) {
        ch = path[idx];
        if (!isIdPart(ch)) {
          break;
        }
        id += ch;
      }
      switch (id) {
        case 'true':
        case 'false':
          return {
            type: TOKEN.BOOL,
            val: id === 'true',
            range: [start, idx]
          };
        case 'null':
          return {
            type: TOKEN.NULL,
            val: null,
            range: [start, idx]
          };
        default:
          return {
            type: TOKEN.ID,
            val: id,
            range: [start, idx]
          };
      }
    }
    function scanString() {
      if (path[idx] !== '"' && path[idx] !== '\'') {
        return;
      }
      var orig = path[idx],
        start = ++idx,
        str = '',
        eosFound = false,
        ch;
      while (idx < len) {
        ch = path[idx++];
        if (ch === '\\') {
          ch = path[idx++];
        } else if ((ch === '"' || ch === '\'') && ch === orig) {
          eosFound = true;
          break;
        }
        str += ch;
      }
      if (eosFound) {
        return {
          type: TOKEN.STR,
          val: str,
          range: [start, idx]
        };
      }
    }
    function scanNumeric() {
      var start = idx,
        ch = path[idx],
        isFloat = ch === '.';
      if (isFloat || isDigit(ch)) {
        var num = ch;
        while (++idx < len) {
          ch = path[idx];
          if (ch === '.') {
            if (isFloat) {
              return;
            }
            isFloat = true;
          } else if (!isDigit(ch)) {
            break;
          }
          num += ch;
        }
        return {
          type: TOKEN.NUM,
          val: isFloat ? parseFloat(num) : parseInt(num, 10),
          range: [start, idx]
        };
      }
    }
    function scanPunctuator() {
      var start = idx,
        ch1 = path[idx],
        ch2 = path[idx + 1];
      if (ch1 === '.') {
        if (isDigit(ch2)) {
          return;
        }
        return path[++idx] === '.' ? {
          type: TOKEN.PUNCT,
          val: '..',
          range: [start, ++idx]
        } : {
          type: TOKEN.PUNCT,
          val: '.',
          range: [start, idx]
        };
      }
      if (ch2 === '=') {
        var ch3 = path[idx + 2];
        if (ch3 === '=') {
          if ('=!^$*'.indexOf(ch1) >= 0) {
            return {
              type: TOKEN.PUNCT,
              val: ch1 + ch2 + ch3,
              range: [start, idx += 3]
            };
          }
        } else if ('^$*'.indexOf(ch3) >= 0) {
          if (ch1 === '=') {
            return {
              type: TOKEN.PUNCT,
              val: ch1 + ch2 + ch3,
              range: [start, idx += 3]
            };
          }
        } else if ('=!^$*><'.indexOf(ch1) >= 0) {
          return {
            type: TOKEN.PUNCT,
            val: ch1 + ch2,
            range: [start, idx += 2]
          };
        }
      } else if (ch1 === '=' && '^$*'.indexOf(ch2) >= 0) {
        return {
          type: TOKEN.PUNCT,
          val: ch1 + ch2,
          range: [start, idx += 2]
        };
      }
      if (ch1 === ch2 && (ch1 === '|' || ch1 === '&')) {
        return {
          type: TOKEN.PUNCT,
          val: ch1 + ch2,
          range: [start, idx += 2]
        };
      }
      if (':{}()[]^+-*/%!><|'.indexOf(ch1) >= 0) {
        return {
          type: TOKEN.PUNCT,
          val: ch1,
          range: [start, ++idx]
        };
      }
    }
    function throwUnexpected(token) {
      if (token.type === TOKEN.EOP) {
        throwError(token, MESSAGES.UNEXP_EOP);
      }
      throwError(token, MESSAGES.UNEXP_TOKEN, token.val);
    }
    function throwError(token, messageFormat) {
      var args = Array.prototype.slice.call(arguments, 2),
        msg = messageFormat.replace(/%(\d)/g, function (_, idx) {
          return args[idx] || '';
        }),
        error = new Error(msg);
      error.column = token.range[0];
      throw error;
    }
    return parse;
  }();
  var translate = function () {
    var body, vars, lastVarId, unusedVars;
    function acquireVar() {
      if (unusedVars.length) {
        return unusedVars.shift();
      }
      var varName = 'v' + ++lastVarId;
      vars.push(varName);
      return varName;
    }
    function releaseVars() {
      var args = arguments,
        i = args.length;
      while (i--) {
        unusedVars.push(args[i]);
      }
    }
    function translate(ast) {
      body = [];
      vars = ['res'];
      lastVarId = 0;
      unusedVars = [];
      translateExpr(ast, 'res', 'data');
      body.unshift('var ', Array.isArray ? 'isArr = Array.isArray' : 'toStr = Object.prototype.toString, isArr = function(o) { return toStr.call(o) === "[object Array]"; }', ', concat = Array.prototype.concat', ',', vars.join(','), ';');
      if (ast.type === SYNTAX.PATH) {
        var lastPart = ast.parts[ast.parts.length - 1];
        if (lastPart && lastPart.type === SYNTAX.POS_PRED && 'idx' in lastPart.arg) {
          body.push('res = res[0];');
        }
      }
      body.push('return res;');
      return body.join('');
    }
    function translatePath(path, dest, ctx) {
      var parts = path.parts,
        i = 0,
        len = parts.length;
      body.push(dest, '=', path.fromRoot ? 'data' : path.subst ? 'subst.' + path.subst : ctx, ';', 'isArr(' + dest + ') || (' + dest + ' = [' + dest + ']);');
      while (i < len) {
        var item = parts[i++];
        switch (item.type) {
          case SYNTAX.SELECTOR:
            item.selector === '..' ? translateDescendantSelector(item, dest, dest) : translateSelector(item, dest, dest);
            break;
          case SYNTAX.OBJ_PRED:
            translateObjectPredicate(item, dest, dest);
            break;
          case SYNTAX.POS_PRED:
            translatePosPredicate(item, dest, dest);
            break;
          case SYNTAX.CONCAT_EXPR:
            translateConcatExpr(item, dest, dest);
            break;
        }
      }
    }
    function translateSelector(sel, dest, ctx) {
      if (sel.prop) {
        var propStr = escapeStr(sel.prop),
          res = acquireVar(),
          i = acquireVar(),
          len = acquireVar(),
          curCtx = acquireVar(),
          j = acquireVar(),
          val = acquireVar(),
          tmpArr = acquireVar();
        body.push(res, '= [];', i, '= 0;', len, '=', ctx, '.length;', tmpArr, '= [];', 'while(', i, '<', len, ') {', curCtx, '=', ctx, '[', i, '++];', 'if(', curCtx, '!= null) {');
        if (sel.prop === '*') {
          body.push('if(typeof ', curCtx, '=== "object") {', 'if(isArr(', curCtx, ')) {', res, '=', res, '.concat(', curCtx, ');', '}', 'else {', 'for(', j, ' in ', curCtx, ') {', 'if(', curCtx, '.hasOwnProperty(', j, ')) {', val, '=', curCtx, '[', j, '];');
          inlineAppendToArray(res, val);
          body.push('}', '}', '}', '}');
        } else {
          body.push(val, '=', curCtx, '[', propStr, '];');
          inlineAppendToArray(res, val, tmpArr, len);
        }
        body.push('}', '}', dest, '=', len, '> 1 &&', tmpArr, '.length?', tmpArr, '.length > 1?', 'concat.apply(', res, ',', tmpArr, ') :', res, '.concat(', tmpArr, '[0]) :', res, ';');
        releaseVars(res, i, len, curCtx, j, val, tmpArr);
      }
    }
    function translateDescendantSelector(sel, dest, baseCtx) {
      var prop = sel.prop,
        ctx = acquireVar(),
        curCtx = acquireVar(),
        childCtxs = acquireVar(),
        i = acquireVar(),
        j = acquireVar(),
        val = acquireVar(),
        len = acquireVar(),
        res = acquireVar();
      body.push(ctx, '=', baseCtx, '.slice(),', res, '= [];', 'while(', ctx, '.length) {', curCtx, '=', ctx, '.shift();');
      prop ? body.push('if(typeof ', curCtx, '=== "object" &&', curCtx, ') {') : body.push('if(typeof ', curCtx, '!= null) {');
      body.push(childCtxs, '= [];', 'if(isArr(', curCtx, ')) {', i, '= 0,', len, '=', curCtx, '.length;', 'while(', i, '<', len, ') {', val, '=', curCtx, '[', i, '++];');
      prop && body.push('if(typeof ', val, '=== "object") {');
      inlineAppendToArray(childCtxs, val);
      prop && body.push('}');
      body.push('}', '}', 'else {');
      if (prop) {
        if (prop !== '*') {
          body.push(val, '=', curCtx, '["' + prop + '"];');
          inlineAppendToArray(res, val);
        }
      } else {
        inlineAppendToArray(res, curCtx);
        body.push('if(typeof ', curCtx, '=== "object") {');
      }
      body.push('for(', j, ' in ', curCtx, ') {', 'if(', curCtx, '.hasOwnProperty(', j, ')) {', val, '=', curCtx, '[', j, '];');
      inlineAppendToArray(childCtxs, val);
      prop === '*' && inlineAppendToArray(res, val);
      body.push('}', '}');
      prop || body.push('}');
      body.push('}', childCtxs, '.length &&', ctx, '.unshift.apply(', ctx, ',', childCtxs, ');', '}', '}', dest, '=', res, ';');
      releaseVars(ctx, curCtx, childCtxs, i, j, val, len, res);
    }
    function translateObjectPredicate(expr, dest, ctx) {
      var resVar = acquireVar(),
        i = acquireVar(),
        len = acquireVar(),
        cond = acquireVar(),
        curItem = acquireVar();
      body.push(resVar, '= [];', i, '= 0;', len, '=', ctx, '.length;', 'while(', i, '<', len, ') {', curItem, '=', ctx, '[', i, '++];');
      translateExpr(expr.arg, cond, curItem);
      body.push(convertToBool(expr.arg, cond), '&&', resVar, '.push(', curItem, ');', '}', dest, '=', resVar, ';');
      releaseVars(resVar, i, len, curItem, cond);
    }
    function translatePosPredicate(item, dest, ctx) {
      var arrayExpr = item.arg,
        fromIdx,
        toIdx;
      if (arrayExpr.idx) {
        var idx = acquireVar();
        translateExpr(arrayExpr.idx, idx, ctx);
        body.push(idx, '< 0 && (', idx, '=', ctx, '.length +', idx, ');', dest, '=', ctx, '[', idx, '] == null? [] : [', ctx, '[', idx, ']];');
        releaseVars(idx);
        return false;
      } else if (arrayExpr.fromIdx) {
        if (arrayExpr.toIdx) {
          translateExpr(arrayExpr.fromIdx, fromIdx = acquireVar(), ctx);
          translateExpr(arrayExpr.toIdx, toIdx = acquireVar(), ctx);
          body.push(dest, '=', ctx, '.slice(', fromIdx, ',', toIdx, ');');
          releaseVars(fromIdx, toIdx);
        } else {
          translateExpr(arrayExpr.fromIdx, fromIdx = acquireVar(), ctx);
          body.push(dest, '=', ctx, '.slice(', fromIdx, ');');
          releaseVars(fromIdx);
        }
      } else {
        translateExpr(arrayExpr.toIdx, toIdx = acquireVar(), ctx);
        body.push(dest, '=', ctx, '.slice(0,', toIdx, ');');
        releaseVars(toIdx);
      }
    }
    function translateExpr(expr, dest, ctx) {
      switch (expr.type) {
        case SYNTAX.PATH:
          translatePath(expr, dest, ctx);
          break;
        case SYNTAX.CONCAT_EXPR:
          translateConcatExpr(expr, dest, ctx);
          break;
        case SYNTAX.COMPARISON_EXPR:
          translateComparisonExpr(expr, dest, ctx);
          break;
        case SYNTAX.MATH_EXPR:
          translateMathExpr(expr, dest, ctx);
          break;
        case SYNTAX.LOGICAL_EXPR:
          translateLogicalExpr(expr, dest, ctx);
          break;
        case SYNTAX.UNARY_EXPR:
          translateUnaryExpr(expr, dest, ctx);
          break;
        case SYNTAX.LITERAL:
          body.push(dest, '=');
          translateLiteral(expr.val);
          body.push(';');
          break;
      }
    }
    function translateLiteral(val) {
      body.push(typeof val === 'string' ? escapeStr(val) : val === null ? 'null' : val);
    }
    function translateComparisonExpr(expr, dest, ctx) {
      var val1 = acquireVar(),
        val2 = acquireVar(),
        isVal1Array = acquireVar(),
        isVal2Array = acquireVar(),
        i = acquireVar(),
        j = acquireVar(),
        len1 = acquireVar(),
        len2 = acquireVar(),
        leftArg = expr.args[0],
        rightArg = expr.args[1];
      body.push(dest, '= false;');
      translateExpr(leftArg, val1, ctx);
      translateExpr(rightArg, val2, ctx);
      var isLeftArgPath = leftArg.type === SYNTAX.PATH,
        isRightArgLiteral = rightArg.type === SYNTAX.LITERAL;
      body.push(isVal1Array, '=');
      isLeftArgPath ? body.push('true;') : body.push('isArr(', val1, ');');
      body.push(isVal2Array, '=');
      isRightArgLiteral ? body.push('false;') : body.push('isArr(', val2, ');');
      body.push('if(');
      isLeftArgPath || body.push(isVal1Array, '&&');
      body.push(val1, '.length === 1) {', val1, '=', val1, '[0];', isVal1Array, '= false;', '}');
      isRightArgLiteral || body.push('if(', isVal2Array, '&&', val2, '.length === 1) {', val2, '=', val2, '[0];', isVal2Array, '= false;', '}');
      body.push(i, '= 0;', 'if(', isVal1Array, ') {', len1, '=', val1, '.length;');
      if (!isRightArgLiteral) {
        body.push('if(', isVal2Array, ') {', len2, '=', val2, '.length;', 'while(', i, '<', len1, '&& !', dest, ') {', j, '= 0;', 'while(', j, '<', len2, ') {');
        writeCondition(expr.op, [val1, '[', i, ']'].join(''), [val2, '[', j, ']'].join(''));
        body.push(dest, '= true;', 'break;', '}', '++', j, ';', '}', '++', i, ';', '}', '}', 'else {');
      }
      body.push('while(', i, '<', len1, ') {');
      writeCondition(expr.op, [val1, '[', i, ']'].join(''), val2);
      body.push(dest, '= true;', 'break;', '}', '++', i, ';', '}');
      isRightArgLiteral || body.push('}');
      body.push('}');
      if (!isRightArgLiteral) {
        body.push('else if(', isVal2Array, ') {', len2, '=', val2, '.length;', 'while(', i, '<', len2, ') {');
        writeCondition(expr.op, val1, [val2, '[', i, ']'].join(''));
        body.push(dest, '= true;', 'break;', '}', '++', i, ';', '}', '}');
      }
      body.push('else {', dest, '=', binaryOperators[expr.op](val1, val2), ';', '}');
      releaseVars(val1, val2, isVal1Array, isVal2Array, i, j, len1, len2);
    }
    function writeCondition(op, val1Expr, val2Expr) {
      body.push('if(', binaryOperators[op](val1Expr, val2Expr), ') {');
    }
    function translateLogicalExpr(expr, dest, ctx) {
      var conditionVars = [],
        args = expr.args,
        len = args.length,
        i = 0,
        val;
      body.push(dest, '= false;');
      switch (expr.op) {
        case '&&':
          while (i < len) {
            conditionVars.push(val = acquireVar());
            translateExpr(args[i], val, ctx);
            body.push('if(', convertToBool(args[i++], val), ') {');
          }
          body.push(dest, '= true;');
          break;
        case '||':
          while (i < len) {
            conditionVars.push(val = acquireVar());
            translateExpr(args[i], val, ctx);
            body.push('if(', convertToBool(args[i], val), ') {', dest, '= true;', '}');
            if (i++ + 1 < len) {
              body.push('else {');
            }
          }
          --len;
          break;
      }
      while (len--) {
        body.push('}');
      }
      releaseVars.apply(null, conditionVars);
    }
    function translateMathExpr(expr, dest, ctx) {
      var val1 = acquireVar(),
        val2 = acquireVar(),
        args = expr.args;
      translateExpr(args[0], val1, ctx);
      translateExpr(args[1], val2, ctx);
      body.push(dest, '=', binaryOperators[expr.op](convertToSingleValue(args[0], val1), convertToSingleValue(args[1], val2)), ';');
      releaseVars(val1, val2);
    }
    function translateUnaryExpr(expr, dest, ctx) {
      var val = acquireVar(),
        arg = expr.arg;
      translateExpr(arg, val, ctx);
      switch (expr.op) {
        case '!':
          body.push(dest, '= !', convertToBool(arg, val) + ';');
          break;
        case '-':
          body.push(dest, '= -', convertToSingleValue(arg, val) + ';');
          break;
      }
      releaseVars(val);
    }
    function translateConcatExpr(expr, dest, ctx) {
      var argVars = [],
        args = expr.args,
        len = args.length,
        i = 0;
      while (i < len) {
        argVars.push(acquireVar());
        translateExpr(args[i], argVars[i++], ctx);
      }
      body.push(dest, '= concat.call(', argVars.join(','), ');');
      releaseVars.apply(null, argVars);
    }
    function escapeStr(s) {
      return '\'' + s.replace(/\\/g, '\\\\').replace(/'/g, '\\\'') + '\'';
    }
    function inlineAppendToArray(res, val, tmpArr, len) {
      body.push('if(typeof ', val, '!== "undefined") {', 'if(isArr(', val, ')) {');
      if (tmpArr) {
        body.push(len, '> 1?');
        inlinePushToArray(tmpArr, val);
        body.push(':');
      }
      body.push(res, '=', res, '.length?', res, '.concat(', val, ') :', val, '.slice()', ';', '}', 'else {');
      tmpArr && body.push('if(', tmpArr, '.length) {', res, '= concat.apply(', res, ',', tmpArr, ');', tmpArr, '= [];', '}');
      inlinePushToArray(res, val);
      body.push(';', '}', '}');
    }
    function inlinePushToArray(res, val) {
      body.push(res, '.length?', res, '.push(', val, ') :', res, '[0] =', val);
    }
    function convertToBool(arg, varName) {
      switch (arg.type) {
        case SYNTAX.LOGICAL_EXPR:
          return varName;
        case SYNTAX.LITERAL:
          return '!!' + varName;
        case SYNTAX.PATH:
          return varName + '.length > 0';
        default:
          return ['(typeof ', varName, '=== "boolean"?', varName, ':', 'isArr(', varName, ')?', varName, '.length > 0 : !!', varName, ')'].join('');
      }
    }
    function convertToSingleValue(arg, varName) {
      switch (arg.type) {
        case SYNTAX.LITERAL:
          return varName;
        case SYNTAX.PATH:
          return varName + '[0]';
        default:
          return ['(isArr(', varName, ')?', varName, '[0] : ', varName, ')'].join('');
      }
    }
    function startsWithStrict(val1, val2) {
      return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string" &&', val1, '.indexOf(', val2, ') === 0'].join('');
    }
    function startsWith(val1, val2) {
      return [val1, '!= null &&', val2, '!= null &&', val1, '.toString().toLowerCase().indexOf(', val2, '.toString().toLowerCase()) === 0'].join('');
    }
    function endsWithStrict(val1, val2) {
      return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string" &&', val1, '.length >=', val2, '.length &&', val1, '.lastIndexOf(', val2, ') ===', val1, '.length -', val2, '.length'].join('');
    }
    function endsWith(val1, val2) {
      return [val1, '!= null &&', val2, '!= null &&', '(', val1, '=', val1, '.toString()).length >=', '(', val2, '=', val2, '.toString()).length &&', '(', val1, '.toLowerCase()).lastIndexOf(', '(', val2, '.toLowerCase())) ===', val1, '.length -', val2, '.length'].join('');
    }
    function containsStrict(val1, val2) {
      return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string" &&', val1, '.indexOf(', val2, ') > -1'].join('');
    }
    function contains(val1, val2) {
      return [val1, '!= null && ', val2, '!= null &&', val1, '.toString().toLowerCase().indexOf(', val2, '.toString().toLowerCase()) > -1'].join('');
    }
    var binaryOperators = {
      '===': function (val1, val2) {
        return val1 + '===' + val2;
      },
      '==': function (val1, val2) {
        return ['typeof ', val1, '=== "string" && typeof ', val2, '=== "string"?', val1, '.toLowerCase() ===', val2, '.toLowerCase() :' + val1, '==', val2].join('');
      },
      '>=': function (val1, val2) {
        return val1 + '>=' + val2;
      },
      '>': function (val1, val2) {
        return val1 + '>' + val2;
      },
      '<=': function (val1, val2) {
        return val1 + '<=' + val2;
      },
      '<': function (val1, val2) {
        return val1 + '<' + val2;
      },
      '!==': function (val1, val2) {
        return val1 + '!==' + val2;
      },
      '!=': function (val1, val2) {
        return val1 + '!=' + val2;
      },
      '^==': startsWithStrict,
      '==^': function (val1, val2) {
        return startsWithStrict(val2, val1);
      },
      '^=': startsWith,
      '=^': function (val1, val2) {
        return startsWith(val2, val1);
      },
      '$==': endsWithStrict,
      '==$': function (val1, val2) {
        return endsWithStrict(val2, val1);
      },
      '$=': endsWith,
      '=$': function (val1, val2) {
        return endsWith(val2, val1);
      },
      '*==': containsStrict,
      '==*': function (val1, val2) {
        return containsStrict(val2, val1);
      },
      '=*': function (val1, val2) {
        return contains(val2, val1);
      },
      '*=': contains,
      '+': function (val1, val2) {
        return val1 + '+' + val2;
      },
      '-': function (val1, val2) {
        return val1 + '-' + val2;
      },
      '*': function (val1, val2) {
        return val1 + '*' + val2;
      },
      '/': function (val1, val2) {
        return val1 + '/' + val2;
      },
      '%': function (val1, val2) {
        return val1 + '%' + val2;
      }
    };
    return translate;
  }();
  function compile(path) {
    return Function('data,subst', translate(parse(path)));
  }
  var cache = {},
    cacheKeys = [],
    params = {
      cacheSize: 100
    },
    setParamsHooks = {
      cacheSize: function (oldVal, newVal) {
        if (newVal < oldVal && cacheKeys.length > newVal) {
          var removedKeys = cacheKeys.splice(0, cacheKeys.length - newVal),
            i = removedKeys.length;
          while (i--) {
            delete cache[removedKeys[i]];
          }
        }
      }
    };
  var decl = function (path, ctx, substs) {
    if (!cache[path]) {
      cache[path] = compile(path);
      if (cacheKeys.push(path) > params.cacheSize) {
        delete cache[cacheKeys.shift()];
      }
    }
    return cache[path](ctx, substs || {});
  };
  decl.version = '0.3.4';
  decl.params = function (_params) {
    if (!arguments.length) {
      return params;
    }
    for (var name in _params) {
      if (_params.hasOwnProperty(name)) {
        setParamsHooks[name] && setParamsHooks[name](params[name], _params[name]);
        params[name] = _params[name];
      }
    }
  };
  decl.compile = compile;
  decl.apply = decl;
  if ( true && typeof module.exports === 'object') {
    module.exports = decl;
  } else if (typeof modules === 'object') {
    modules.define('jspath', function (provide) {
      provide(decl);
    });
  } else if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function (require, exports, module) {
      module.exports = decl;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})();

/***/ }),

/***/ 2725:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function ExportLibrary(root, factory) {
  if (true) {
    module.exports = factory();
  } else {}
})(this, function LibraryFactory() {
  var PahoMQTT = function (global) {
    var version = "@VERSION@-@BUILDLEVEL@";
    var localStorage = global.localStorage || function () {
      var data = {};
      return {
        setItem: function (key, item) {
          data[key] = item;
        },
        getItem: function (key) {
          return data[key];
        },
        removeItem: function (key) {
          delete data[key];
        }
      };
    }();
    var MESSAGE_TYPE = {
      CONNECT: 1,
      CONNACK: 2,
      PUBLISH: 3,
      PUBACK: 4,
      PUBREC: 5,
      PUBREL: 6,
      PUBCOMP: 7,
      SUBSCRIBE: 8,
      SUBACK: 9,
      UNSUBSCRIBE: 10,
      UNSUBACK: 11,
      PINGREQ: 12,
      PINGRESP: 13,
      DISCONNECT: 14
    };
    var validate = function (obj, keys) {
      for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
          if (keys.hasOwnProperty(key)) {
            if (typeof obj[key] !== keys[key]) throw new Error(format(ERROR.INVALID_TYPE, [typeof obj[key], key]));
          } else {
            var errorStr = "Unknown property, " + key + ". Valid properties are:";
            for (var validKey in keys) if (keys.hasOwnProperty(validKey)) errorStr = errorStr + " " + validKey;
            throw new Error(errorStr);
          }
        }
      }
    };
    var scope = function (f, scope) {
      return function () {
        return f.apply(scope, arguments);
      };
    };
    var ERROR = {
      OK: {
        code: 0,
        text: "AMQJSC0000I OK."
      },
      CONNECT_TIMEOUT: {
        code: 1,
        text: "AMQJSC0001E Connect timed out."
      },
      SUBSCRIBE_TIMEOUT: {
        code: 2,
        text: "AMQJS0002E Subscribe timed out."
      },
      UNSUBSCRIBE_TIMEOUT: {
        code: 3,
        text: "AMQJS0003E Unsubscribe timed out."
      },
      PING_TIMEOUT: {
        code: 4,
        text: "AMQJS0004E Ping timed out."
      },
      INTERNAL_ERROR: {
        code: 5,
        text: "AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}"
      },
      CONNACK_RETURNCODE: {
        code: 6,
        text: "AMQJS0006E Bad Connack return code:{0} {1}."
      },
      SOCKET_ERROR: {
        code: 7,
        text: "AMQJS0007E Socket error:{0}."
      },
      SOCKET_CLOSE: {
        code: 8,
        text: "AMQJS0008I Socket closed."
      },
      MALFORMED_UTF: {
        code: 9,
        text: "AMQJS0009E Malformed UTF data:{0} {1} {2}."
      },
      UNSUPPORTED: {
        code: 10,
        text: "AMQJS0010E {0} is not supported by this browser."
      },
      INVALID_STATE: {
        code: 11,
        text: "AMQJS0011E Invalid state {0}."
      },
      INVALID_TYPE: {
        code: 12,
        text: "AMQJS0012E Invalid type {0} for {1}."
      },
      INVALID_ARGUMENT: {
        code: 13,
        text: "AMQJS0013E Invalid argument {0} for {1}."
      },
      UNSUPPORTED_OPERATION: {
        code: 14,
        text: "AMQJS0014E Unsupported operation."
      },
      INVALID_STORED_DATA: {
        code: 15,
        text: "AMQJS0015E Invalid data in local storage key={0} value={1}."
      },
      INVALID_MQTT_MESSAGE_TYPE: {
        code: 16,
        text: "AMQJS0016E Invalid MQTT message type {0}."
      },
      MALFORMED_UNICODE: {
        code: 17,
        text: "AMQJS0017E Malformed Unicode string:{0} {1}."
      },
      BUFFER_FULL: {
        code: 18,
        text: "AMQJS0018E Message buffer is full, maximum buffer size: {0}."
      }
    };
    var CONNACK_RC = {
      0: "Connection Accepted",
      1: "Connection Refused: unacceptable protocol version",
      2: "Connection Refused: identifier rejected",
      3: "Connection Refused: server unavailable",
      4: "Connection Refused: bad user name or password",
      5: "Connection Refused: not authorized"
    };
    var format = function (error, substitutions) {
      var text = error.text;
      if (substitutions) {
        var field, start;
        for (var i = 0; i < substitutions.length; i++) {
          field = "{" + i + "}";
          start = text.indexOf(field);
          if (start > 0) {
            var part1 = text.substring(0, start);
            var part2 = text.substring(start + field.length);
            text = part1 + substitutions[i] + part2;
          }
        }
      }
      return text;
    };
    var MqttProtoIdentifierv3 = [0x00, 0x06, 0x4d, 0x51, 0x49, 0x73, 0x64, 0x70, 0x03];
    var MqttProtoIdentifierv4 = [0x00, 0x04, 0x4d, 0x51, 0x54, 0x54, 0x04];
    var WireMessage = function (type, options) {
      this.type = type;
      for (var name in options) {
        if (options.hasOwnProperty(name)) {
          this[name] = options[name];
        }
      }
    };
    WireMessage.prototype.encode = function () {
      var first = (this.type & 0x0f) << 4;
      var remLength = 0;
      var topicStrLength = [];
      var destinationNameLength = 0;
      var willMessagePayloadBytes;
      if (this.messageIdentifier !== undefined) remLength += 2;
      switch (this.type) {
        case MESSAGE_TYPE.CONNECT:
          switch (this.mqttVersion) {
            case 3:
              remLength += MqttProtoIdentifierv3.length + 3;
              break;
            case 4:
              remLength += MqttProtoIdentifierv4.length + 3;
              break;
          }
          remLength += UTF8Length(this.clientId) + 2;
          if (this.willMessage !== undefined) {
            remLength += UTF8Length(this.willMessage.destinationName) + 2;
            willMessagePayloadBytes = this.willMessage.payloadBytes;
            if (!(willMessagePayloadBytes instanceof Uint8Array)) willMessagePayloadBytes = new Uint8Array(payloadBytes);
            remLength += willMessagePayloadBytes.byteLength + 2;
          }
          if (this.userName !== undefined) remLength += UTF8Length(this.userName) + 2;
          if (this.password !== undefined) remLength += UTF8Length(this.password) + 2;
          break;
        case MESSAGE_TYPE.SUBSCRIBE:
          first |= 0x02;
          for (var i = 0; i < this.topics.length; i++) {
            topicStrLength[i] = UTF8Length(this.topics[i]);
            remLength += topicStrLength[i] + 2;
          }
          remLength += this.requestedQos.length;
          break;
        case MESSAGE_TYPE.UNSUBSCRIBE:
          first |= 0x02;
          for (var i = 0; i < this.topics.length; i++) {
            topicStrLength[i] = UTF8Length(this.topics[i]);
            remLength += topicStrLength[i] + 2;
          }
          break;
        case MESSAGE_TYPE.PUBREL:
          first |= 0x02;
          break;
        case MESSAGE_TYPE.PUBLISH:
          if (this.payloadMessage.duplicate) first |= 0x08;
          first = first |= this.payloadMessage.qos << 1;
          if (this.payloadMessage.retained) first |= 0x01;
          destinationNameLength = UTF8Length(this.payloadMessage.destinationName);
          remLength += destinationNameLength + 2;
          var payloadBytes = this.payloadMessage.payloadBytes;
          remLength += payloadBytes.byteLength;
          if (payloadBytes instanceof ArrayBuffer) payloadBytes = new Uint8Array(payloadBytes);else if (!(payloadBytes instanceof Uint8Array)) payloadBytes = new Uint8Array(payloadBytes.buffer);
          break;
        case MESSAGE_TYPE.DISCONNECT:
          break;
        default:
          break;
      }
      var mbi = encodeMBI(remLength);
      var pos = mbi.length + 1;
      var buffer = new ArrayBuffer(remLength + pos);
      var byteStream = new Uint8Array(buffer);
      byteStream[0] = first;
      byteStream.set(mbi, 1);
      if (this.type == MESSAGE_TYPE.PUBLISH) pos = writeString(this.payloadMessage.destinationName, destinationNameLength, byteStream, pos);else if (this.type == MESSAGE_TYPE.CONNECT) {
        switch (this.mqttVersion) {
          case 3:
            byteStream.set(MqttProtoIdentifierv3, pos);
            pos += MqttProtoIdentifierv3.length;
            break;
          case 4:
            byteStream.set(MqttProtoIdentifierv4, pos);
            pos += MqttProtoIdentifierv4.length;
            break;
        }
        var connectFlags = 0;
        if (this.cleanSession) connectFlags = 0x02;
        if (this.willMessage !== undefined) {
          connectFlags |= 0x04;
          connectFlags |= this.willMessage.qos << 3;
          if (this.willMessage.retained) {
            connectFlags |= 0x20;
          }
        }
        if (this.userName !== undefined) connectFlags |= 0x80;
        if (this.password !== undefined) connectFlags |= 0x40;
        byteStream[pos++] = connectFlags;
        pos = writeUint16(this.keepAliveInterval, byteStream, pos);
      }
      if (this.messageIdentifier !== undefined) pos = writeUint16(this.messageIdentifier, byteStream, pos);
      switch (this.type) {
        case MESSAGE_TYPE.CONNECT:
          pos = writeString(this.clientId, UTF8Length(this.clientId), byteStream, pos);
          if (this.willMessage !== undefined) {
            pos = writeString(this.willMessage.destinationName, UTF8Length(this.willMessage.destinationName), byteStream, pos);
            pos = writeUint16(willMessagePayloadBytes.byteLength, byteStream, pos);
            byteStream.set(willMessagePayloadBytes, pos);
            pos += willMessagePayloadBytes.byteLength;
          }
          if (this.userName !== undefined) pos = writeString(this.userName, UTF8Length(this.userName), byteStream, pos);
          if (this.password !== undefined) pos = writeString(this.password, UTF8Length(this.password), byteStream, pos);
          break;
        case MESSAGE_TYPE.PUBLISH:
          byteStream.set(payloadBytes, pos);
          break;
        case MESSAGE_TYPE.SUBSCRIBE:
          for (var i = 0; i < this.topics.length; i++) {
            pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
            byteStream[pos++] = this.requestedQos[i];
          }
          break;
        case MESSAGE_TYPE.UNSUBSCRIBE:
          for (var i = 0; i < this.topics.length; i++) pos = writeString(this.topics[i], topicStrLength[i], byteStream, pos);
          break;
        default:
      }
      return buffer;
    };
    function decodeMessage(input, pos) {
      var startingPos = pos;
      var first = input[pos];
      var type = first >> 4;
      var messageInfo = first &= 0x0f;
      pos += 1;
      var digit;
      var remLength = 0;
      var multiplier = 1;
      do {
        if (pos == input.length) {
          return [null, startingPos];
        }
        digit = input[pos++];
        remLength += (digit & 0x7F) * multiplier;
        multiplier *= 128;
      } while ((digit & 0x80) !== 0);
      var endPos = pos + remLength;
      if (endPos > input.length) {
        return [null, startingPos];
      }
      var wireMessage = new WireMessage(type);
      switch (type) {
        case MESSAGE_TYPE.CONNACK:
          var connectAcknowledgeFlags = input[pos++];
          if (connectAcknowledgeFlags & 0x01) wireMessage.sessionPresent = true;
          wireMessage.returnCode = input[pos++];
          break;
        case MESSAGE_TYPE.PUBLISH:
          var qos = messageInfo >> 1 & 0x03;
          var len = readUint16(input, pos);
          pos += 2;
          var topicName = parseUTF8(input, pos, len);
          pos += len;
          if (qos > 0) {
            wireMessage.messageIdentifier = readUint16(input, pos);
            pos += 2;
          }
          var message = new Message(input.subarray(pos, endPos));
          if ((messageInfo & 0x01) == 0x01) message.retained = true;
          if ((messageInfo & 0x08) == 0x08) message.duplicate = true;
          message.qos = qos;
          message.destinationName = topicName;
          wireMessage.payloadMessage = message;
          break;
        case MESSAGE_TYPE.PUBACK:
        case MESSAGE_TYPE.PUBREC:
        case MESSAGE_TYPE.PUBREL:
        case MESSAGE_TYPE.PUBCOMP:
        case MESSAGE_TYPE.UNSUBACK:
          wireMessage.messageIdentifier = readUint16(input, pos);
          break;
        case MESSAGE_TYPE.SUBACK:
          wireMessage.messageIdentifier = readUint16(input, pos);
          pos += 2;
          wireMessage.returnCode = input.subarray(pos, endPos);
          break;
        default:
          break;
      }
      return [wireMessage, endPos];
    }
    function writeUint16(input, buffer, offset) {
      buffer[offset++] = input >> 8;
      buffer[offset++] = input % 256;
      return offset;
    }
    function writeString(input, utf8Length, buffer, offset) {
      offset = writeUint16(utf8Length, buffer, offset);
      stringToUTF8(input, buffer, offset);
      return offset + utf8Length;
    }
    function readUint16(buffer, offset) {
      return 256 * buffer[offset] + buffer[offset + 1];
    }
    function encodeMBI(number) {
      var output = new Array(1);
      var numBytes = 0;
      do {
        var digit = number % 128;
        number = number >> 7;
        if (number > 0) {
          digit |= 0x80;
        }
        output[numBytes++] = digit;
      } while (number > 0 && numBytes < 4);
      return output;
    }
    function UTF8Length(input) {
      var output = 0;
      for (var i = 0; i < input.length; i++) {
        var charCode = input.charCodeAt(i);
        if (charCode > 0x7FF) {
          if (0xD800 <= charCode && charCode <= 0xDBFF) {
            i++;
            output++;
          }
          output += 3;
        } else if (charCode > 0x7F) output += 2;else output++;
      }
      return output;
    }
    function stringToUTF8(input, output, start) {
      var pos = start;
      for (var i = 0; i < input.length; i++) {
        var charCode = input.charCodeAt(i);
        if (0xD800 <= charCode && charCode <= 0xDBFF) {
          var lowCharCode = input.charCodeAt(++i);
          if (isNaN(lowCharCode)) {
            throw new Error(format(ERROR.MALFORMED_UNICODE, [charCode, lowCharCode]));
          }
          charCode = (charCode - 0xD800 << 10) + (lowCharCode - 0xDC00) + 0x10000;
        }
        if (charCode <= 0x7F) {
          output[pos++] = charCode;
        } else if (charCode <= 0x7FF) {
          output[pos++] = charCode >> 6 & 0x1F | 0xC0;
          output[pos++] = charCode & 0x3F | 0x80;
        } else if (charCode <= 0xFFFF) {
          output[pos++] = charCode >> 12 & 0x0F | 0xE0;
          output[pos++] = charCode >> 6 & 0x3F | 0x80;
          output[pos++] = charCode & 0x3F | 0x80;
        } else {
          output[pos++] = charCode >> 18 & 0x07 | 0xF0;
          output[pos++] = charCode >> 12 & 0x3F | 0x80;
          output[pos++] = charCode >> 6 & 0x3F | 0x80;
          output[pos++] = charCode & 0x3F | 0x80;
        }
      }
      return output;
    }
    function parseUTF8(input, offset, length) {
      var output = "";
      var utf16;
      var pos = offset;
      while (pos < offset + length) {
        var byte1 = input[pos++];
        if (byte1 < 128) utf16 = byte1;else {
          var byte2 = input[pos++] - 128;
          if (byte2 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), ""]));
          if (byte1 < 0xE0) utf16 = 64 * (byte1 - 0xC0) + byte2;else {
            var byte3 = input[pos++] - 128;
            if (byte3 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16)]));
            if (byte1 < 0xF0) utf16 = 4096 * (byte1 - 0xE0) + 64 * byte2 + byte3;else {
              var byte4 = input[pos++] - 128;
              if (byte4 < 0) throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));
              if (byte1 < 0xF8) utf16 = 262144 * (byte1 - 0xF0) + 4096 * byte2 + 64 * byte3 + byte4;else throw new Error(format(ERROR.MALFORMED_UTF, [byte1.toString(16), byte2.toString(16), byte3.toString(16), byte4.toString(16)]));
            }
          }
        }
        if (utf16 > 0xFFFF) {
            utf16 -= 0x10000;
            output += String.fromCharCode(0xD800 + (utf16 >> 10));
            utf16 = 0xDC00 + (utf16 & 0x3FF);
          }
        output += String.fromCharCode(utf16);
      }
      return output;
    }
    var Pinger = function (client, keepAliveInterval) {
      this._client = client;
      this._keepAliveInterval = keepAliveInterval * 1000;
      this.isReset = false;
      var pingReq = new WireMessage(MESSAGE_TYPE.PINGREQ).encode();
      var doTimeout = function (pinger) {
        return function () {
          return doPing.apply(pinger);
        };
      };
      var doPing = function () {
        if (!this.isReset) {
          this._client._trace("Pinger.doPing", "Timed out");
          this._client._disconnected(ERROR.PING_TIMEOUT.code, format(ERROR.PING_TIMEOUT));
        } else {
          this.isReset = false;
          this._client._trace("Pinger.doPing", "send PINGREQ");
          this._client.socket.send(pingReq);
          this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);
        }
      };
      this.reset = function () {
        this.isReset = true;
        clearTimeout(this.timeout);
        if (this._keepAliveInterval > 0) this.timeout = setTimeout(doTimeout(this), this._keepAliveInterval);
      };
      this.cancel = function () {
        clearTimeout(this.timeout);
      };
    };
    var Timeout = function (client, timeoutSeconds, action, args) {
      if (!timeoutSeconds) timeoutSeconds = 30;
      var doTimeout = function (action, client, args) {
        return function () {
          return action.apply(client, args);
        };
      };
      this.timeout = setTimeout(doTimeout(action, client, args), timeoutSeconds * 1000);
      this.cancel = function () {
        clearTimeout(this.timeout);
      };
    };
    var ClientImpl = function (uri, host, port, path, clientId) {
      if (!("WebSocket" in global && global.WebSocket !== null)) {
        throw new Error(format(ERROR.UNSUPPORTED, ["WebSocket"]));
      }
      if (!("ArrayBuffer" in global && global.ArrayBuffer !== null)) {
        throw new Error(format(ERROR.UNSUPPORTED, ["ArrayBuffer"]));
      }
      this._trace("Paho.Client", uri, host, port, path, clientId);
      this.host = host;
      this.port = port;
      this.path = path;
      this.uri = uri;
      this.clientId = clientId;
      this._wsuri = null;
      this._localKey = host + ":" + port + (path != "/mqtt" ? ":" + path : "") + ":" + clientId + ":";
      this._msg_queue = [];
      this._buffered_msg_queue = [];
      this._sentMessages = {};
      this._receivedMessages = {};
      this._notify_msg_sent = {};
      this._message_identifier = 1;
      this._sequence = 0;
      for (var key in localStorage) if (key.indexOf("Sent:" + this._localKey) === 0 || key.indexOf("Received:" + this._localKey) === 0) this.restore(key);
    };
    ClientImpl.prototype.host = null;
    ClientImpl.prototype.port = null;
    ClientImpl.prototype.path = null;
    ClientImpl.prototype.uri = null;
    ClientImpl.prototype.clientId = null;
    ClientImpl.prototype.socket = null;
    ClientImpl.prototype.connected = false;
    ClientImpl.prototype.maxMessageIdentifier = 65536;
    ClientImpl.prototype.connectOptions = null;
    ClientImpl.prototype.hostIndex = null;
    ClientImpl.prototype.onConnected = null;
    ClientImpl.prototype.onConnectionLost = null;
    ClientImpl.prototype.onMessageDelivered = null;
    ClientImpl.prototype.onMessageArrived = null;
    ClientImpl.prototype.traceFunction = null;
    ClientImpl.prototype._msg_queue = null;
    ClientImpl.prototype._buffered_msg_queue = null;
    ClientImpl.prototype._connectTimeout = null;
    ClientImpl.prototype.sendPinger = null;
    ClientImpl.prototype.receivePinger = null;
    ClientImpl.prototype._reconnectInterval = 1;
    ClientImpl.prototype._reconnecting = false;
    ClientImpl.prototype._reconnectTimeout = null;
    ClientImpl.prototype.disconnectedPublishing = false;
    ClientImpl.prototype.disconnectedBufferSize = 5000;
    ClientImpl.prototype.receiveBuffer = null;
    ClientImpl.prototype._traceBuffer = null;
    ClientImpl.prototype._MAX_TRACE_ENTRIES = 100;
    ClientImpl.prototype.connect = function (connectOptions) {
      var connectOptionsMasked = this._traceMask(connectOptions, "password");
      this._trace("Client.connect", connectOptionsMasked, this.socket, this.connected);
      if (this.connected) throw new Error(format(ERROR.INVALID_STATE, ["already connected"]));
      if (this.socket) throw new Error(format(ERROR.INVALID_STATE, ["already connected"]));
      if (this._reconnecting) {
        this._reconnectTimeout.cancel();
        this._reconnectTimeout = null;
        this._reconnecting = false;
      }
      this.connectOptions = connectOptions;
      this._reconnectInterval = 1;
      this._reconnecting = false;
      if (connectOptions.uris) {
        this.hostIndex = 0;
        this._doConnect(connectOptions.uris[0]);
      } else {
        this._doConnect(this.uri);
      }
    };
    ClientImpl.prototype.subscribe = function (filter, subscribeOptions) {
      this._trace("Client.subscribe", filter, subscribeOptions);
      if (!this.connected) throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
      var wireMessage = new WireMessage(MESSAGE_TYPE.SUBSCRIBE);
      wireMessage.topics = filter.constructor === Array ? filter : [filter];
      if (subscribeOptions.qos === undefined) subscribeOptions.qos = 0;
      wireMessage.requestedQos = [];
      for (var i = 0; i < wireMessage.topics.length; i++) wireMessage.requestedQos[i] = subscribeOptions.qos;
      if (subscribeOptions.onSuccess) {
        wireMessage.onSuccess = function (grantedQos) {
          subscribeOptions.onSuccess({
            invocationContext: subscribeOptions.invocationContext,
            grantedQos: grantedQos
          });
        };
      }
      if (subscribeOptions.onFailure) {
        wireMessage.onFailure = function (errorCode) {
          subscribeOptions.onFailure({
            invocationContext: subscribeOptions.invocationContext,
            errorCode: errorCode,
            errorMessage: format(errorCode)
          });
        };
      }
      if (subscribeOptions.timeout) {
        wireMessage.timeOut = new Timeout(this, subscribeOptions.timeout, subscribeOptions.onFailure, [{
          invocationContext: subscribeOptions.invocationContext,
          errorCode: ERROR.SUBSCRIBE_TIMEOUT.code,
          errorMessage: format(ERROR.SUBSCRIBE_TIMEOUT)
        }]);
      }
      this._requires_ack(wireMessage);
      this._schedule_message(wireMessage);
    };
    ClientImpl.prototype.unsubscribe = function (filter, unsubscribeOptions) {
      this._trace("Client.unsubscribe", filter, unsubscribeOptions);
      if (!this.connected) throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
      var wireMessage = new WireMessage(MESSAGE_TYPE.UNSUBSCRIBE);
      wireMessage.topics = filter.constructor === Array ? filter : [filter];
      if (unsubscribeOptions.onSuccess) {
        wireMessage.callback = function () {
          unsubscribeOptions.onSuccess({
            invocationContext: unsubscribeOptions.invocationContext
          });
        };
      }
      if (unsubscribeOptions.timeout) {
        wireMessage.timeOut = new Timeout(this, unsubscribeOptions.timeout, unsubscribeOptions.onFailure, [{
          invocationContext: unsubscribeOptions.invocationContext,
          errorCode: ERROR.UNSUBSCRIBE_TIMEOUT.code,
          errorMessage: format(ERROR.UNSUBSCRIBE_TIMEOUT)
        }]);
      }
      this._requires_ack(wireMessage);
      this._schedule_message(wireMessage);
    };
    ClientImpl.prototype.send = function (message) {
      this._trace("Client.send", message);
      var wireMessage = new WireMessage(MESSAGE_TYPE.PUBLISH);
      wireMessage.payloadMessage = message;
      if (this.connected) {
        if (message.qos > 0) {
          this._requires_ack(wireMessage);
        } else if (this.onMessageDelivered) {
          this._notify_msg_sent[wireMessage] = this.onMessageDelivered(wireMessage.payloadMessage);
        }
        this._schedule_message(wireMessage);
      } else {
        if (this._reconnecting && this.disconnectedPublishing) {
          var messageCount = Object.keys(this._sentMessages).length + this._buffered_msg_queue.length;
          if (messageCount > this.disconnectedBufferSize) {
            throw new Error(format(ERROR.BUFFER_FULL, [this.disconnectedBufferSize]));
          } else {
            if (message.qos > 0) {
              this._requires_ack(wireMessage);
            } else {
              wireMessage.sequence = ++this._sequence;
              this._buffered_msg_queue.unshift(wireMessage);
            }
          }
        } else {
          throw new Error(format(ERROR.INVALID_STATE, ["not connected"]));
        }
      }
    };
    ClientImpl.prototype.disconnect = function () {
      this._trace("Client.disconnect");
      if (this._reconnecting) {
        this._reconnectTimeout.cancel();
        this._reconnectTimeout = null;
        this._reconnecting = false;
      }
      if (!this.socket) throw new Error(format(ERROR.INVALID_STATE, ["not connecting or connected"]));
      var wireMessage = new WireMessage(MESSAGE_TYPE.DISCONNECT);
      this._notify_msg_sent[wireMessage] = scope(this._disconnected, this);
      this._schedule_message(wireMessage);
    };
    ClientImpl.prototype.getTraceLog = function () {
      if (this._traceBuffer !== null) {
        this._trace("Client.getTraceLog", new Date());
        this._trace("Client.getTraceLog in flight messages", this._sentMessages.length);
        for (var key in this._sentMessages) this._trace("_sentMessages ", key, this._sentMessages[key]);
        for (var key in this._receivedMessages) this._trace("_receivedMessages ", key, this._receivedMessages[key]);
        return this._traceBuffer;
      }
    };
    ClientImpl.prototype.startTrace = function () {
      if (this._traceBuffer === null) {
        this._traceBuffer = [];
      }
      this._trace("Client.startTrace", new Date(), version);
    };
    ClientImpl.prototype.stopTrace = function () {
      delete this._traceBuffer;
    };
    ClientImpl.prototype._doConnect = function (wsurl) {
      if (this.connectOptions.useSSL) {
        var uriParts = wsurl.split(":");
        uriParts[0] = "wss";
        wsurl = uriParts.join(":");
      }
      this._wsuri = wsurl;
      this.connected = false;
      if (this.connectOptions.mqttVersion < 4) {
        this.socket = new WebSocket(wsurl, ["mqttv3.1"]);
      } else {
        this.socket = new WebSocket(wsurl, ["mqtt"]);
      }
      this.socket.binaryType = "arraybuffer";
      this.socket.onopen = scope(this._on_socket_open, this);
      this.socket.onmessage = scope(this._on_socket_message, this);
      this.socket.onerror = scope(this._on_socket_error, this);
      this.socket.onclose = scope(this._on_socket_close, this);
      this.sendPinger = new Pinger(this, this.connectOptions.keepAliveInterval);
      this.receivePinger = new Pinger(this, this.connectOptions.keepAliveInterval);
      if (this._connectTimeout) {
        this._connectTimeout.cancel();
        this._connectTimeout = null;
      }
      this._connectTimeout = new Timeout(this, this.connectOptions.timeout, this._disconnected, [ERROR.CONNECT_TIMEOUT.code, format(ERROR.CONNECT_TIMEOUT)]);
    };
    ClientImpl.prototype._schedule_message = function (message) {
      this._msg_queue.unshift(message);
      if (this.connected) {
        this._process_queue();
      }
    };
    ClientImpl.prototype.store = function (prefix, wireMessage) {
      var storedMessage = {
        type: wireMessage.type,
        messageIdentifier: wireMessage.messageIdentifier,
        version: 1
      };
      switch (wireMessage.type) {
        case MESSAGE_TYPE.PUBLISH:
          if (wireMessage.pubRecReceived) storedMessage.pubRecReceived = true;
          storedMessage.payloadMessage = {};
          var hex = "";
          var messageBytes = wireMessage.payloadMessage.payloadBytes;
          for (var i = 0; i < messageBytes.length; i++) {
            if (messageBytes[i] <= 0xF) hex = hex + "0" + messageBytes[i].toString(16);else hex = hex + messageBytes[i].toString(16);
          }
          storedMessage.payloadMessage.payloadHex = hex;
          storedMessage.payloadMessage.qos = wireMessage.payloadMessage.qos;
          storedMessage.payloadMessage.destinationName = wireMessage.payloadMessage.destinationName;
          if (wireMessage.payloadMessage.duplicate) storedMessage.payloadMessage.duplicate = true;
          if (wireMessage.payloadMessage.retained) storedMessage.payloadMessage.retained = true;
          if (prefix.indexOf("Sent:") === 0) {
            if (wireMessage.sequence === undefined) wireMessage.sequence = ++this._sequence;
            storedMessage.sequence = wireMessage.sequence;
          }
          break;
        default:
          throw Error(format(ERROR.INVALID_STORED_DATA, [prefix + this._localKey + wireMessage.messageIdentifier, storedMessage]));
      }
      localStorage.setItem(prefix + this._localKey + wireMessage.messageIdentifier, JSON.stringify(storedMessage));
    };
    ClientImpl.prototype.restore = function (key) {
      var value = localStorage.getItem(key);
      var storedMessage = JSON.parse(value);
      var wireMessage = new WireMessage(storedMessage.type, storedMessage);
      switch (storedMessage.type) {
        case MESSAGE_TYPE.PUBLISH:
          var hex = storedMessage.payloadMessage.payloadHex;
          var buffer = new ArrayBuffer(hex.length / 2);
          var byteStream = new Uint8Array(buffer);
          var i = 0;
          while (hex.length >= 2) {
            var x = parseInt(hex.substring(0, 2), 16);
            hex = hex.substring(2, hex.length);
            byteStream[i++] = x;
          }
          var payloadMessage = new Message(byteStream);
          payloadMessage.qos = storedMessage.payloadMessage.qos;
          payloadMessage.destinationName = storedMessage.payloadMessage.destinationName;
          if (storedMessage.payloadMessage.duplicate) payloadMessage.duplicate = true;
          if (storedMessage.payloadMessage.retained) payloadMessage.retained = true;
          wireMessage.payloadMessage = payloadMessage;
          break;
        default:
          throw Error(format(ERROR.INVALID_STORED_DATA, [key, value]));
      }
      if (key.indexOf("Sent:" + this._localKey) === 0) {
        wireMessage.payloadMessage.duplicate = true;
        this._sentMessages[wireMessage.messageIdentifier] = wireMessage;
      } else if (key.indexOf("Received:" + this._localKey) === 0) {
        this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;
      }
    };
    ClientImpl.prototype._process_queue = function () {
      var message = null;
      while (message = this._msg_queue.pop()) {
        this._socket_send(message);
        if (this._notify_msg_sent[message]) {
          this._notify_msg_sent[message]();
          delete this._notify_msg_sent[message];
        }
      }
    };
    ClientImpl.prototype._requires_ack = function (wireMessage) {
      var messageCount = Object.keys(this._sentMessages).length;
      if (messageCount > this.maxMessageIdentifier) throw Error("Too many messages:" + messageCount);
      while (this._sentMessages[this._message_identifier] !== undefined) {
        this._message_identifier++;
      }
      wireMessage.messageIdentifier = this._message_identifier;
      this._sentMessages[wireMessage.messageIdentifier] = wireMessage;
      if (wireMessage.type === MESSAGE_TYPE.PUBLISH) {
        this.store("Sent:", wireMessage);
      }
      if (this._message_identifier === this.maxMessageIdentifier) {
        this._message_identifier = 1;
      }
    };
    ClientImpl.prototype._on_socket_open = function () {
      var wireMessage = new WireMessage(MESSAGE_TYPE.CONNECT, this.connectOptions);
      wireMessage.clientId = this.clientId;
      this._socket_send(wireMessage);
    };
    ClientImpl.prototype._on_socket_message = function (event) {
      this._trace("Client._on_socket_message", event.data);
      var messages = this._deframeMessages(event.data);
      for (var i = 0; i < messages.length; i += 1) {
        this._handleMessage(messages[i]);
      }
    };
    ClientImpl.prototype._deframeMessages = function (data) {
      var byteArray = new Uint8Array(data);
      var messages = [];
      if (this.receiveBuffer) {
        var newData = new Uint8Array(this.receiveBuffer.length + byteArray.length);
        newData.set(this.receiveBuffer);
        newData.set(byteArray, this.receiveBuffer.length);
        byteArray = newData;
        delete this.receiveBuffer;
      }
      try {
        var offset = 0;
        while (offset < byteArray.length) {
          var result = decodeMessage(byteArray, offset);
          var wireMessage = result[0];
          offset = result[1];
          if (wireMessage !== null) {
            messages.push(wireMessage);
          } else {
            break;
          }
        }
        if (offset < byteArray.length) {
          this.receiveBuffer = byteArray.subarray(offset);
        }
      } catch (error) {
        var errorStack = error.hasOwnProperty("stack") == "undefined" ? error.stack.toString() : "No Error Stack Available";
        this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));
        return;
      }
      return messages;
    };
    ClientImpl.prototype._handleMessage = function (wireMessage) {
      this._trace("Client._handleMessage", wireMessage);
      try {
        switch (wireMessage.type) {
          case MESSAGE_TYPE.CONNACK:
            this._connectTimeout.cancel();
            if (this._reconnectTimeout) this._reconnectTimeout.cancel();
            if (this.connectOptions.cleanSession) {
              for (var key in this._sentMessages) {
                var sentMessage = this._sentMessages[key];
                localStorage.removeItem("Sent:" + this._localKey + sentMessage.messageIdentifier);
              }
              this._sentMessages = {};
              for (var key in this._receivedMessages) {
                var receivedMessage = this._receivedMessages[key];
                localStorage.removeItem("Received:" + this._localKey + receivedMessage.messageIdentifier);
              }
              this._receivedMessages = {};
            }
            if (wireMessage.returnCode === 0) {
              this.connected = true;
              if (this.connectOptions.uris) this.hostIndex = this.connectOptions.uris.length;
            } else {
              this._disconnected(ERROR.CONNACK_RETURNCODE.code, format(ERROR.CONNACK_RETURNCODE, [wireMessage.returnCode, CONNACK_RC[wireMessage.returnCode]]));
              break;
            }
            var sequencedMessages = [];
            for (var msgId in this._sentMessages) {
              if (this._sentMessages.hasOwnProperty(msgId)) sequencedMessages.push(this._sentMessages[msgId]);
            }
            if (this._buffered_msg_queue.length > 0) {
              var msg = null;
              while (msg = this._buffered_msg_queue.pop()) {
                sequencedMessages.push(msg);
                if (this.onMessageDelivered) this._notify_msg_sent[msg] = this.onMessageDelivered(msg.payloadMessage);
              }
            }
            var sequencedMessages = sequencedMessages.sort(function (a, b) {
              return a.sequence - b.sequence;
            });
            for (var i = 0, len = sequencedMessages.length; i < len; i++) {
              var sentMessage = sequencedMessages[i];
              if (sentMessage.type == MESSAGE_TYPE.PUBLISH && sentMessage.pubRecReceived) {
                var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {
                  messageIdentifier: sentMessage.messageIdentifier
                });
                this._schedule_message(pubRelMessage);
              } else {
                this._schedule_message(sentMessage);
              }
            }
            if (this.connectOptions.onSuccess) {
              this.connectOptions.onSuccess({
                invocationContext: this.connectOptions.invocationContext
              });
            }
            var reconnected = false;
            if (this._reconnecting) {
              reconnected = true;
              this._reconnectInterval = 1;
              this._reconnecting = false;
            }
            this._connected(reconnected, this._wsuri);
            this._process_queue();
            break;
          case MESSAGE_TYPE.PUBLISH:
            this._receivePublish(wireMessage);
            break;
          case MESSAGE_TYPE.PUBACK:
            var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
            if (sentMessage) {
              delete this._sentMessages[wireMessage.messageIdentifier];
              localStorage.removeItem("Sent:" + this._localKey + wireMessage.messageIdentifier);
              if (this.onMessageDelivered) this.onMessageDelivered(sentMessage.payloadMessage);
            }
            break;
          case MESSAGE_TYPE.PUBREC:
            var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
            if (sentMessage) {
              sentMessage.pubRecReceived = true;
              var pubRelMessage = new WireMessage(MESSAGE_TYPE.PUBREL, {
                messageIdentifier: wireMessage.messageIdentifier
              });
              this.store("Sent:", sentMessage);
              this._schedule_message(pubRelMessage);
            }
            break;
          case MESSAGE_TYPE.PUBREL:
            var receivedMessage = this._receivedMessages[wireMessage.messageIdentifier];
            localStorage.removeItem("Received:" + this._localKey + wireMessage.messageIdentifier);
            if (receivedMessage) {
              this._receiveMessage(receivedMessage);
              delete this._receivedMessages[wireMessage.messageIdentifier];
            }
            var pubCompMessage = new WireMessage(MESSAGE_TYPE.PUBCOMP, {
              messageIdentifier: wireMessage.messageIdentifier
            });
            this._schedule_message(pubCompMessage);
            break;
          case MESSAGE_TYPE.PUBCOMP:
            var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
            delete this._sentMessages[wireMessage.messageIdentifier];
            localStorage.removeItem("Sent:" + this._localKey + wireMessage.messageIdentifier);
            if (this.onMessageDelivered) this.onMessageDelivered(sentMessage.payloadMessage);
            break;
          case MESSAGE_TYPE.SUBACK:
            var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
            if (sentMessage) {
              if (sentMessage.timeOut) sentMessage.timeOut.cancel();
              if (wireMessage.returnCode[0] === 0x80) {
                if (sentMessage.onFailure) {
                  sentMessage.onFailure(wireMessage.returnCode);
                }
              } else if (sentMessage.onSuccess) {
                sentMessage.onSuccess(wireMessage.returnCode);
              }
              delete this._sentMessages[wireMessage.messageIdentifier];
            }
            break;
          case MESSAGE_TYPE.UNSUBACK:
            var sentMessage = this._sentMessages[wireMessage.messageIdentifier];
            if (sentMessage) {
              if (sentMessage.timeOut) sentMessage.timeOut.cancel();
              if (sentMessage.callback) {
                sentMessage.callback();
              }
              delete this._sentMessages[wireMessage.messageIdentifier];
            }
            break;
          case MESSAGE_TYPE.PINGRESP:
            this.sendPinger.reset();
            break;
          case MESSAGE_TYPE.DISCONNECT:
            this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
            break;
          default:
            this._disconnected(ERROR.INVALID_MQTT_MESSAGE_TYPE.code, format(ERROR.INVALID_MQTT_MESSAGE_TYPE, [wireMessage.type]));
        }
      } catch (error) {
        var errorStack = error.hasOwnProperty("stack") == "undefined" ? error.stack.toString() : "No Error Stack Available";
        this._disconnected(ERROR.INTERNAL_ERROR.code, format(ERROR.INTERNAL_ERROR, [error.message, errorStack]));
        return;
      }
    };
    ClientImpl.prototype._on_socket_error = function (error) {
      if (!this._reconnecting) {
        this._disconnected(ERROR.SOCKET_ERROR.code, format(ERROR.SOCKET_ERROR, [error.data]));
      }
    };
    ClientImpl.prototype._on_socket_close = function () {
      if (!this._reconnecting) {
        this._disconnected(ERROR.SOCKET_CLOSE.code, format(ERROR.SOCKET_CLOSE));
      }
    };
    ClientImpl.prototype._socket_send = function (wireMessage) {
      if (wireMessage.type == 1) {
        var wireMessageMasked = this._traceMask(wireMessage, "password");
        this._trace("Client._socket_send", wireMessageMasked);
      } else this._trace("Client._socket_send", wireMessage);
      this.socket.send(wireMessage.encode());
      this.sendPinger.reset();
    };
    ClientImpl.prototype._receivePublish = function (wireMessage) {
      switch (wireMessage.payloadMessage.qos) {
        case "undefined":
        case 0:
          this._receiveMessage(wireMessage);
          break;
        case 1:
          var pubAckMessage = new WireMessage(MESSAGE_TYPE.PUBACK, {
            messageIdentifier: wireMessage.messageIdentifier
          });
          this._schedule_message(pubAckMessage);
          this._receiveMessage(wireMessage);
          break;
        case 2:
          this._receivedMessages[wireMessage.messageIdentifier] = wireMessage;
          this.store("Received:", wireMessage);
          var pubRecMessage = new WireMessage(MESSAGE_TYPE.PUBREC, {
            messageIdentifier: wireMessage.messageIdentifier
          });
          this._schedule_message(pubRecMessage);
          break;
        default:
          throw Error("Invaild qos=" + wireMessage.payloadMessage.qos);
      }
    };
    ClientImpl.prototype._receiveMessage = function (wireMessage) {
      if (this.onMessageArrived) {
        this.onMessageArrived(wireMessage.payloadMessage);
      }
    };
    ClientImpl.prototype._connected = function (reconnect, uri) {
      if (this.onConnected) this.onConnected(reconnect, uri);
    };
    ClientImpl.prototype._reconnect = function () {
      this._trace("Client._reconnect");
      if (!this.connected) {
        this._reconnecting = true;
        this.sendPinger.cancel();
        this.receivePinger.cancel();
        if (this._reconnectInterval < 128) this._reconnectInterval = this._reconnectInterval * 2;
        if (this.connectOptions.uris) {
          this.hostIndex = 0;
          this._doConnect(this.connectOptions.uris[0]);
        } else {
          this._doConnect(this.uri);
        }
      }
    };
    ClientImpl.prototype._disconnected = function (errorCode, errorText) {
      this._trace("Client._disconnected", errorCode, errorText);
      if (errorCode !== undefined && this._reconnecting) {
        this._reconnectTimeout = new Timeout(this, this._reconnectInterval, this._reconnect);
        return;
      }
      this.sendPinger.cancel();
      this.receivePinger.cancel();
      if (this._connectTimeout) {
        this._connectTimeout.cancel();
        this._connectTimeout = null;
      }
      this._msg_queue = [];
      this._buffered_msg_queue = [];
      this._notify_msg_sent = {};
      if (this.socket) {
        this.socket.onopen = null;
        this.socket.onmessage = null;
        this.socket.onerror = null;
        this.socket.onclose = null;
        if (this.socket.readyState === 1) this.socket.close();
        delete this.socket;
      }
      if (this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) {
        this.hostIndex++;
        this._doConnect(this.connectOptions.uris[this.hostIndex]);
      } else {
        if (errorCode === undefined) {
          errorCode = ERROR.OK.code;
          errorText = format(ERROR.OK);
        }
        if (this.connected) {
          this.connected = false;
          if (this.onConnectionLost) {
            this.onConnectionLost({
              errorCode: errorCode,
              errorMessage: errorText,
              reconnect: this.connectOptions.reconnect,
              uri: this._wsuri
            });
          }
          if (errorCode !== ERROR.OK.code && this.connectOptions.reconnect) {
            this._reconnectInterval = 1;
            this._reconnect();
            return;
          }
        } else {
          if (this.connectOptions.mqttVersion === 4 && this.connectOptions.mqttVersionExplicit === false) {
            this._trace("Failed to connect V4, dropping back to V3");
            this.connectOptions.mqttVersion = 3;
            if (this.connectOptions.uris) {
              this.hostIndex = 0;
              this._doConnect(this.connectOptions.uris[0]);
            } else {
              this._doConnect(this.uri);
            }
          } else if (this.connectOptions.onFailure) {
            this.connectOptions.onFailure({
              invocationContext: this.connectOptions.invocationContext,
              errorCode: errorCode,
              errorMessage: errorText
            });
          }
        }
      }
    };
    ClientImpl.prototype._trace = function () {
      if (this.traceFunction) {
        var args = Array.prototype.slice.call(arguments);
        for (var i in args) {
          if (typeof args[i] !== "undefined") args.splice(i, 1, JSON.stringify(args[i]));
        }
        var record = args.join("");
        this.traceFunction({
          severity: "Debug",
          message: record
        });
      }
      if (this._traceBuffer !== null) {
        for (var i = 0, max = arguments.length; i < max; i++) {
          if (this._traceBuffer.length == this._MAX_TRACE_ENTRIES) {
            this._traceBuffer.shift();
          }
          if (i === 0) this._traceBuffer.push(arguments[i]);else if (typeof arguments[i] === "undefined") this._traceBuffer.push(arguments[i]);else this._traceBuffer.push("  " + JSON.stringify(arguments[i]));
        }
      }
    };
    ClientImpl.prototype._traceMask = function (traceObject, masked) {
      var traceObjectMasked = {};
      for (var attr in traceObject) {
        if (traceObject.hasOwnProperty(attr)) {
          if (attr == masked) traceObjectMasked[attr] = "******";else traceObjectMasked[attr] = traceObject[attr];
        }
      }
      return traceObjectMasked;
    };
    var Client = function (host, port, path, clientId) {
      var uri;
      if (typeof host !== "string") throw new Error(format(ERROR.INVALID_TYPE, [typeof host, "host"]));
      if (arguments.length == 2) {
        clientId = port;
        uri = host;
        var match = uri.match(/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/);
        if (match) {
          host = match[4] || match[2];
          port = parseInt(match[7]);
          path = match[8];
        } else {
          throw new Error(format(ERROR.INVALID_ARGUMENT, [host, "host"]));
        }
      } else {
        if (arguments.length == 3) {
          clientId = path;
          path = "/mqtt";
        }
        if (typeof port !== "number" || port < 0) throw new Error(format(ERROR.INVALID_TYPE, [typeof port, "port"]));
        if (typeof path !== "string") throw new Error(format(ERROR.INVALID_TYPE, [typeof path, "path"]));
        var ipv6AddSBracket = host.indexOf(":") !== -1 && host.slice(0, 1) !== "[" && host.slice(-1) !== "]";
        uri = "ws://" + (ipv6AddSBracket ? "[" + host + "]" : host) + ":" + port + path;
      }
      var clientIdLength = 0;
      for (var i = 0; i < clientId.length; i++) {
        var charCode = clientId.charCodeAt(i);
        if (0xD800 <= charCode && charCode <= 0xDBFF) {
          i++;
        }
        clientIdLength++;
      }
      if (typeof clientId !== "string" || clientIdLength > 65535) throw new Error(format(ERROR.INVALID_ARGUMENT, [clientId, "clientId"]));
      var client = new ClientImpl(uri, host, port, path, clientId);
      Object.defineProperties(this, {
        "host": {
          get: function () {
            return host;
          },
          set: function () {
            throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
          }
        },
        "port": {
          get: function () {
            return port;
          },
          set: function () {
            throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
          }
        },
        "path": {
          get: function () {
            return path;
          },
          set: function () {
            throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
          }
        },
        "uri": {
          get: function () {
            return uri;
          },
          set: function () {
            throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
          }
        },
        "clientId": {
          get: function () {
            return client.clientId;
          },
          set: function () {
            throw new Error(format(ERROR.UNSUPPORTED_OPERATION));
          }
        },
        "onConnected": {
          get: function () {
            return client.onConnected;
          },
          set: function (newOnConnected) {
            if (typeof newOnConnected === "function") client.onConnected = newOnConnected;else throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnected, "onConnected"]));
          }
        },
        "disconnectedPublishing": {
          get: function () {
            return client.disconnectedPublishing;
          },
          set: function (newDisconnectedPublishing) {
            client.disconnectedPublishing = newDisconnectedPublishing;
          }
        },
        "disconnectedBufferSize": {
          get: function () {
            return client.disconnectedBufferSize;
          },
          set: function (newDisconnectedBufferSize) {
            client.disconnectedBufferSize = newDisconnectedBufferSize;
          }
        },
        "onConnectionLost": {
          get: function () {
            return client.onConnectionLost;
          },
          set: function (newOnConnectionLost) {
            if (typeof newOnConnectionLost === "function") client.onConnectionLost = newOnConnectionLost;else throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnConnectionLost, "onConnectionLost"]));
          }
        },
        "onMessageDelivered": {
          get: function () {
            return client.onMessageDelivered;
          },
          set: function (newOnMessageDelivered) {
            if (typeof newOnMessageDelivered === "function") client.onMessageDelivered = newOnMessageDelivered;else throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageDelivered, "onMessageDelivered"]));
          }
        },
        "onMessageArrived": {
          get: function () {
            return client.onMessageArrived;
          },
          set: function (newOnMessageArrived) {
            if (typeof newOnMessageArrived === "function") client.onMessageArrived = newOnMessageArrived;else throw new Error(format(ERROR.INVALID_TYPE, [typeof newOnMessageArrived, "onMessageArrived"]));
          }
        },
        "trace": {
          get: function () {
            return client.traceFunction;
          },
          set: function (trace) {
            if (typeof trace === "function") {
              client.traceFunction = trace;
            } else {
              throw new Error(format(ERROR.INVALID_TYPE, [typeof trace, "onTrace"]));
            }
          }
        }
      });
      this.connect = function (connectOptions) {
        connectOptions = connectOptions || {};
        validate(connectOptions, {
          timeout: "number",
          userName: "string",
          password: "string",
          willMessage: "object",
          keepAliveInterval: "number",
          cleanSession: "boolean",
          useSSL: "boolean",
          invocationContext: "object",
          onSuccess: "function",
          onFailure: "function",
          hosts: "object",
          ports: "object",
          reconnect: "boolean",
          mqttVersion: "number",
          mqttVersionExplicit: "boolean",
          uris: "object"
        });
        if (connectOptions.keepAliveInterval === undefined) connectOptions.keepAliveInterval = 60;
        if (connectOptions.mqttVersion > 4 || connectOptions.mqttVersion < 3) {
          throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.mqttVersion, "connectOptions.mqttVersion"]));
        }
        if (connectOptions.mqttVersion === undefined) {
          connectOptions.mqttVersionExplicit = false;
          connectOptions.mqttVersion = 4;
        } else {
          connectOptions.mqttVersionExplicit = true;
        }
        if (connectOptions.password !== undefined && connectOptions.userName === undefined) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.password, "connectOptions.password"]));
        if (connectOptions.willMessage) {
          if (!(connectOptions.willMessage instanceof Message)) throw new Error(format(ERROR.INVALID_TYPE, [connectOptions.willMessage, "connectOptions.willMessage"]));
          connectOptions.willMessage.stringPayload = null;
          if (typeof connectOptions.willMessage.destinationName === "undefined") throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.willMessage.destinationName, "connectOptions.willMessage.destinationName"]));
        }
        if (typeof connectOptions.cleanSession === "undefined") connectOptions.cleanSession = true;
        if (connectOptions.hosts) {
          if (!(connectOptions.hosts instanceof Array)) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, "connectOptions.hosts"]));
          if (connectOptions.hosts.length < 1) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts, "connectOptions.hosts"]));
          var usingURIs = false;
          for (var i = 0; i < connectOptions.hosts.length; i++) {
            if (typeof connectOptions.hosts[i] !== "string") throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.hosts[i], "connectOptions.hosts[" + i + "]"]));
            if (/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/.test(connectOptions.hosts[i])) {
              if (i === 0) {
                usingURIs = true;
              } else if (!usingURIs) {
                throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], "connectOptions.hosts[" + i + "]"]));
              }
            } else if (usingURIs) {
              throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.hosts[i], "connectOptions.hosts[" + i + "]"]));
            }
          }
          if (!usingURIs) {
            if (!connectOptions.ports) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
            if (!(connectOptions.ports instanceof Array)) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
            if (connectOptions.hosts.length !== connectOptions.ports.length) throw new Error(format(ERROR.INVALID_ARGUMENT, [connectOptions.ports, "connectOptions.ports"]));
            connectOptions.uris = [];
            for (var i = 0; i < connectOptions.hosts.length; i++) {
              if (typeof connectOptions.ports[i] !== "number" || connectOptions.ports[i] < 0) throw new Error(format(ERROR.INVALID_TYPE, [typeof connectOptions.ports[i], "connectOptions.ports[" + i + "]"]));
              var host = connectOptions.hosts[i];
              var port = connectOptions.ports[i];
              var ipv6 = host.indexOf(":") !== -1;
              uri = "ws://" + (ipv6 ? "[" + host + "]" : host) + ":" + port + path;
              connectOptions.uris.push(uri);
            }
          } else {
            connectOptions.uris = connectOptions.hosts;
          }
        }
        client.connect(connectOptions);
      };
      this.subscribe = function (filter, subscribeOptions) {
        if (typeof filter !== "string" && filter.constructor !== Array) throw new Error("Invalid argument:" + filter);
        subscribeOptions = subscribeOptions || {};
        validate(subscribeOptions, {
          qos: "number",
          invocationContext: "object",
          onSuccess: "function",
          onFailure: "function",
          timeout: "number"
        });
        if (subscribeOptions.timeout && !subscribeOptions.onFailure) throw new Error("subscribeOptions.timeout specified with no onFailure callback.");
        if (typeof subscribeOptions.qos !== "undefined" && !(subscribeOptions.qos === 0 || subscribeOptions.qos === 1 || subscribeOptions.qos === 2)) throw new Error(format(ERROR.INVALID_ARGUMENT, [subscribeOptions.qos, "subscribeOptions.qos"]));
        client.subscribe(filter, subscribeOptions);
      };
      this.unsubscribe = function (filter, unsubscribeOptions) {
        if (typeof filter !== "string" && filter.constructor !== Array) throw new Error("Invalid argument:" + filter);
        unsubscribeOptions = unsubscribeOptions || {};
        validate(unsubscribeOptions, {
          invocationContext: "object",
          onSuccess: "function",
          onFailure: "function",
          timeout: "number"
        });
        if (unsubscribeOptions.timeout && !unsubscribeOptions.onFailure) throw new Error("unsubscribeOptions.timeout specified with no onFailure callback.");
        client.unsubscribe(filter, unsubscribeOptions);
      };
      this.send = function (topic, payload, qos, retained) {
        var message;
        if (arguments.length === 0) {
          throw new Error("Invalid argument." + "length");
        } else if (arguments.length == 1) {
          if (!(topic instanceof Message) && typeof topic !== "string") throw new Error("Invalid argument:" + typeof topic);
          message = topic;
          if (typeof message.destinationName === "undefined") throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, "Message.destinationName"]));
          client.send(message);
        } else {
          message = new Message(payload);
          message.destinationName = topic;
          if (arguments.length >= 3) message.qos = qos;
          if (arguments.length >= 4) message.retained = retained;
          client.send(message);
        }
      };
      this.publish = function (topic, payload, qos, retained) {
        var message;
        if (arguments.length === 0) {
          throw new Error("Invalid argument." + "length");
        } else if (arguments.length == 1) {
          if (!(topic instanceof Message) && typeof topic !== "string") throw new Error("Invalid argument:" + typeof topic);
          message = topic;
          if (typeof message.destinationName === "undefined") throw new Error(format(ERROR.INVALID_ARGUMENT, [message.destinationName, "Message.destinationName"]));
          client.send(message);
        } else {
          message = new Message(payload);
          message.destinationName = topic;
          if (arguments.length >= 3) message.qos = qos;
          if (arguments.length >= 4) message.retained = retained;
          client.send(message);
        }
      };
      this.disconnect = function () {
        client.disconnect();
      };
      this.getTraceLog = function () {
        return client.getTraceLog();
      };
      this.startTrace = function () {
        client.startTrace();
      };
      this.stopTrace = function () {
        client.stopTrace();
      };
      this.isConnected = function () {
        return client.connected;
      };
    };
    var Message = function (newPayload) {
      var payload;
      if (typeof newPayload === "string" || newPayload instanceof ArrayBuffer || ArrayBuffer.isView(newPayload) && !(newPayload instanceof DataView)) {
        payload = newPayload;
      } else {
        throw format(ERROR.INVALID_ARGUMENT, [newPayload, "newPayload"]);
      }
      var destinationName;
      var qos = 0;
      var retained = false;
      var duplicate = false;
      Object.defineProperties(this, {
        "payloadString": {
          enumerable: true,
          get: function () {
            if (typeof payload === "string") return payload;else return parseUTF8(payload, 0, payload.length);
          }
        },
        "payloadBytes": {
          enumerable: true,
          get: function () {
            if (typeof payload === "string") {
              var buffer = new ArrayBuffer(UTF8Length(payload));
              var byteStream = new Uint8Array(buffer);
              stringToUTF8(payload, byteStream, 0);
              return byteStream;
            } else {
              return payload;
            }
          }
        },
        "destinationName": {
          enumerable: true,
          get: function () {
            return destinationName;
          },
          set: function (newDestinationName) {
            if (typeof newDestinationName === "string") destinationName = newDestinationName;else throw new Error(format(ERROR.INVALID_ARGUMENT, [newDestinationName, "newDestinationName"]));
          }
        },
        "qos": {
          enumerable: true,
          get: function () {
            return qos;
          },
          set: function (newQos) {
            if (newQos === 0 || newQos === 1 || newQos === 2) qos = newQos;else throw new Error("Invalid argument:" + newQos);
          }
        },
        "retained": {
          enumerable: true,
          get: function () {
            return retained;
          },
          set: function (newRetained) {
            if (typeof newRetained === "boolean") retained = newRetained;else throw new Error(format(ERROR.INVALID_ARGUMENT, [newRetained, "newRetained"]));
          }
        },
        "topic": {
          enumerable: true,
          get: function () {
            return destinationName;
          },
          set: function (newTopic) {
            destinationName = newTopic;
          }
        },
        "duplicate": {
          enumerable: true,
          get: function () {
            return duplicate;
          },
          set: function (newDuplicate) {
            duplicate = newDuplicate;
          }
        }
      });
    };
    return {
      Client: Client,
      Message: Message
    };
  }(typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  return PahoMQTT;
});

/***/ }),

/***/ 2866:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  json: () => (/* binding */ json),
  jsonLanguage: () => (/* binding */ jsonLanguage),
  jsonParseLinter: () => (/* binding */ jsonParseLinter)
});

// EXTERNAL MODULE: ./node_modules/@lezer/lr/dist/index.js
var dist = __webpack_require__(2612);
// EXTERNAL MODULE: ./node_modules/@lezer/highlight/dist/index.js
var highlight_dist = __webpack_require__(5016);
;// ./node_modules/@lezer/json/dist/index.js


const jsonHighlighting = (0,highlight_dist/* styleTags */.pn)({
  String: highlight_dist/* tags */._A.string,
  Number: highlight_dist/* tags */._A.number,
  "True False": highlight_dist/* tags */._A.bool,
  PropertyName: highlight_dist/* tags */._A.propertyName,
  Null: highlight_dist/* tags */._A.null,
  ", :": highlight_dist/* tags */._A.separator,
  "[ ]": highlight_dist/* tags */._A.squareBracket,
  "{ }": highlight_dist/* tags */._A.brace
});
const parser = dist/* LRParser */.U1.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CtOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59W,59WO!iQPO,59WOVQPO,59QOqQPO'#CmO!nQPO,59`OOQO1G.k1G.kOVQPO'#CnO!vQPO,59aOOQO1G.r1G.rOOQO1G.l1G.lOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l",
  stateData: "#O~OeOS~OQSORSOSSOTSOWQO_ROgPO~OVXOgUO~O^[O~PVO[^O~O]_OVhX~OVaO~O]bO^iX~O^dO~O]_OVha~O]bO^ia~O",
  goto: "!kjPPPPPPkPPkqwPPPPk{!RPPP!XP!e!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName : , ] [ Array",
  maxTerm: 25,
  nodeProps: [["isolate", -2, 6, 11, ""], ["openedBy", 7, "{", 14, "["], ["closedBy", 8, "}", 15, "]"]],
  propSources: [jsonHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oe~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Og~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zO]~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yO[~~'OO_~~'TO^~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: {
    "JsonText": [0, 1]
  },
  tokenPrec: 0
});

// EXTERNAL MODULE: ./node_modules/@codemirror/language/dist/index.js
var language_dist = __webpack_require__(4658);
;// ./node_modules/@codemirror/lang-json/dist/index.js


const jsonParseLinter = () => view => {
  try {
    JSON.parse(view.state.doc.toString());
  } catch (e) {
    if (!(e instanceof SyntaxError)) throw e;
    const pos = getErrorPosition(e, view.state.doc);
    return [{
      from: pos,
      message: e.message,
      severity: 'error',
      to: pos
    }];
  }
  return [];
};
function getErrorPosition(error, doc) {
  let m;
  if (m = error.message.match(/at position (\d+)/)) return Math.min(+m[1], doc.length);
  if (m = error.message.match(/at line (\d+) column (\d+)/)) return Math.min(doc.line(+m[1]).from + +m[2] - 1, doc.length);
  return 0;
}
const jsonLanguage = language_dist/* LRLanguage */.bj.define({
  name: "json",
  parser: parser.configure({
    props: [language_dist/* indentNodeProp */.Oh.add({
      Object: (0,language_dist/* continuedIndent */.mz)({
        except: /^\s*\}/
      }),
      Array: (0,language_dist/* continuedIndent */.mz)({
        except: /^\s*\]/
      })
    }), language_dist/* foldNodeProp */.b_.add({
      "Object Array": language_dist/* foldInside */.yd
    })]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["[", "{", '"']
    },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function json() {
  return new language_dist/* LanguageSupport */.Yy(jsonLanguage);
}


/***/ }),

/***/ 2907:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Light-webfont.woff";

/***/ }),

/***/ 3020:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const ECLevel = __webpack_require__(151);
const EC_BLOCKS_TABLE = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];
const EC_CODEWORDS_TABLE = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel.L:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
    case ECLevel.M:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
    case ECLevel.Q:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
    case ECLevel.H:
      return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
    default:
      return undefined;
  }
};
exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
  switch (errorCorrectionLevel) {
    case ECLevel.L:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
    case ECLevel.M:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
    case ECLevel.Q:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
    case ECLevel.H:
      return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
    default:
      return undefined;
  }
};

/***/ }),

/***/ 3075:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const GF = __webpack_require__(7009);
exports.mul = function mul(p1, p2) {
  const coeff = new Uint8Array(p1.length + p2.length - 1);
  for (let i = 0; i < p1.length; i++) {
    for (let j = 0; j < p2.length; j++) {
      coeff[i + j] ^= GF.mul(p1[i], p2[j]);
    }
  }
  return coeff;
};
exports.mod = function mod(divident, divisor) {
  let result = new Uint8Array(divident);
  while (result.length - divisor.length >= 0) {
    const coeff = result[0];
    for (let i = 0; i < divisor.length; i++) {
      result[i] ^= GF.mul(divisor[i], coeff);
    }
    let offset = 0;
    while (offset < result.length && result[offset] === 0) offset++;
    result = result.slice(offset);
  }
  return result;
};
exports.generateECPolynomial = function generateECPolynomial(degree) {
  let poly = new Uint8Array([1]);
  for (let i = 0; i < degree; i++) {
    poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
  }
  return poly;
};

/***/ }),

/***/ 3099:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const getSymbolSize = (__webpack_require__(3340).getSymbolSize);
exports.getRowColCoords = function getRowColCoords(version) {
  if (version === 1) return [];
  const posCount = Math.floor(version / 7) + 2;
  const size = getSymbolSize(version);
  const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
  const positions = [size - 7];
  for (let i = 1; i < posCount - 1; i++) {
    positions[i] = positions[i - 1] - intervals;
  }
  positions.push(6);
  return positions.reverse();
};
exports.getPositions = function getPositions(version) {
  const coords = [];
  const pos = exports.getRowColCoords(version);
  const posLength = pos.length;
  for (let i = 0; i < posLength; i++) {
    for (let j = 0; j < posLength; j++) {
      if (i === 0 && j === 0 || i === 0 && j === posLength - 1 || i === posLength - 1 && j === 0) {
        continue;
      }
      coords.push([pos[i], pos[j]]);
    }
  }
  return coords;
};

/***/ }),

/***/ 3154:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
const amiTwig = {
  version: '1.2.0'
};
if ( true && typeof module.exports === 'object') {
  module.exports.amiTwig = amiTwig;
} else if (typeof window !== 'undefined') {
  window.amiTwig = amiTwig;
} else if (typeof __webpack_require__.g !== 'undefined') {
  __webpack_require__.g.amiTwig = amiTwig;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (amiTwig);
amiTwig.tokenizer = {
  tokenize: function (code, line, spaces, tokenDefs, tokenTypes, error) {
    if (tokenDefs.length !== tokenTypes.length) {
      throw '`tokenDefs.length != tokenTypes.length`';
    }
    const result_tokens = [];
    const result_types = [];
    const result_lines = [];
    let i = 0x000000000;
    const l = code.length;
    let word = '',
      token,
      c;
    __l0: while (i < l) {
      c = code.charAt(0);
      if (c === '\n') {
        line++;
      }
      if (spaces.indexOf(c) >= 0) {
        if (word) {
          if (error) {
            throw 'invalid token `' + word + '`';
          }
          result_tokens.push(word);
          result_types.push(-1);
          result_lines.push(line);
          word = '';
        }
        code = code.substring(1);
        i += 1;
        continue __l0;
      }
      for (const j in tokenDefs) {
        token = this._match(code, tokenDefs[j]);
        if (token) {
          if (word) {
            if (error) {
              throw 'invalid token `' + word + '`';
            }
            result_tokens.push(word);
            result_types.push(-1);
            result_lines.push(line);
            word = '';
          }
          result_tokens.push(token);
          result_types.push(tokenTypes[j]);
          result_lines.push(line);
          code = code.substring(token.length);
          i += token.length;
          continue __l0;
        }
      }
      word += c;
      code = code.substring(1);
      i += 1;
    }
    if (word) {
      if (error) {
        throw 'invalid token `' + word + '`';
      }
      result_tokens.push(word);
      result_types.push(-1);
      result_lines.push(line);
    }
    return {
      tokens: result_tokens,
      types: result_types,
      lines: result_lines
    };
  },
  _match: function (s, stringOrRegExp) {
    let m;
    if (stringOrRegExp instanceof RegExp) {
      m = s.match(stringOrRegExp);
      return m !== null && this._checkNextChar(s, m[0]) ? m[0] : null;
    } else {
      m = s.indexOf(stringOrRegExp);
      return m === 0x00 && this._checkNextChar(s, stringOrRegExp) ? stringOrRegExp : null;
    }
  },
  _alphanum: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  _checkNextChar: function (s, token) {
    const length = token.length;
    const charCode2 = s.charCodeAt(length - 0);
    const charCode1 = s.charCodeAt(length - 1);
    return isNaN(charCode2) || this._alphanum[charCode2] === 0 || this._alphanum[charCode1] === 0;
  }
};
amiTwig.expr = {};
amiTwig.expr.tokens = {
  $init: function () {
    this.IS_XXX = [this.DEFINED, this.NULL, this.EMPTY, this.ITERABLE, this.EVEN, this.ODD];
    this.XXX_WITH = [this.STARTS_WITH, this.ENDS_WITH];
    this.PLUS_MINUS = [this.CONCAT, this.PLUS, this.MINUS];
    this.MUL_FLDIV_DIV_MOD = [this.MUL, this.FLDIV, this.DIV, this.MOD];
    this.RX = [this.RP, this.RB1];
  },
  LOGICAL_OR: 100,
  LOGICAL_AND: 101,
  BITWISE_OR: 102,
  BITWISE_XOR: 103,
  BITWISE_AND: 104,
  NOT: 105,
  IS: 106,
  DEFINED: 107,
  NULL: 108,
  EMPTY: 109,
  ITERABLE: 110,
  EVEN: 111,
  ODD: 112,
  CMP_OP: 113,
  STARTS_WITH: 114,
  ENDS_WITH: 115,
  MATCHES: 116,
  IN: 117,
  RANGE: 118,
  CONCAT: 119,
  PLUS: 120,
  MINUS: 121,
  POWER: 122,
  MUL: 123,
  FLDIV: 124,
  DIV: 125,
  MOD: 126,
  DOUBLE_QUESTION: 127,
  QUESTION: 128,
  COLON: 129,
  DOT: 130,
  COMMA: 131,
  PIPE: 132,
  LP: 133,
  RP: 134,
  LB1: 135,
  RB1: 136,
  LB2: 137,
  RB2: 138,
  SID: 139,
  TERMINAL: 140,
  LST: 200,
  DIC: 201,
  FUN: 202,
  VAR: 203
};
amiTwig.expr.tokens.$init();
amiTwig.expr.Tokenizer = function (code, line) {
  this._spaces = [' ', '\t', '\n', '\r'];
  this._tokenDefs = ['or', 'and', 'b-or', 'b-xor', 'b-and', 'not', 'is', 'defined', 'null', 'empty', 'iterable', 'even', 'odd', '===', '==', '!==', '!=', '<=', '>=', '<', '>', /^starts\s+with/, /^ends\s+with/, 'matches', 'in', '..', '~', '+', '-', '**', '*', '//', '/', '%', '??', '?', ':', '.', ',', '|', '(', ')', '[', ']', '{', '}', 'true', 'false', /^[0-9]+\.[0-9]+/, /^[0-9]+/, /^'(\\'|[^'])*'/, /^"(\\"|[^"])*"/, /^[a-zA-Z_$][a-zA-Z0-9_$]*/];
  this._tokenTypes = [amiTwig.expr.tokens.LOGICAL_OR, amiTwig.expr.tokens.LOGICAL_AND, amiTwig.expr.tokens.BITWISE_OR, amiTwig.expr.tokens.BITWISE_XOR, amiTwig.expr.tokens.BITWISE_AND, amiTwig.expr.tokens.NOT, amiTwig.expr.tokens.IS, amiTwig.expr.tokens.DEFINED, amiTwig.expr.tokens.NULL, amiTwig.expr.tokens.EMPTY, amiTwig.expr.tokens.ITERABLE, amiTwig.expr.tokens.EVEN, amiTwig.expr.tokens.ODD, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.CMP_OP, amiTwig.expr.tokens.STARTS_WITH, amiTwig.expr.tokens.ENDS_WITH, amiTwig.expr.tokens.MATCHES, amiTwig.expr.tokens.IN, amiTwig.expr.tokens.RANGE, amiTwig.expr.tokens.CONCAT, amiTwig.expr.tokens.PLUS, amiTwig.expr.tokens.MINUS, amiTwig.expr.tokens.POWER, amiTwig.expr.tokens.MUL, amiTwig.expr.tokens.FLDIV, amiTwig.expr.tokens.DIV, amiTwig.expr.tokens.MOD, amiTwig.expr.tokens.DOUBLE_QUESTION, amiTwig.expr.tokens.QUESTION, amiTwig.expr.tokens.COLON, amiTwig.expr.tokens.DOT, amiTwig.expr.tokens.COMMA, amiTwig.expr.tokens.PIPE, amiTwig.expr.tokens.LP, amiTwig.expr.tokens.RP, amiTwig.expr.tokens.LB1, amiTwig.expr.tokens.RB1, amiTwig.expr.tokens.LB2, amiTwig.expr.tokens.RB2, amiTwig.expr.tokens.TERMINAL, amiTwig.expr.tokens.TERMINAL, amiTwig.expr.tokens.TERMINAL, amiTwig.expr.tokens.TERMINAL, amiTwig.expr.tokens.TERMINAL, amiTwig.expr.tokens.TERMINAL, amiTwig.expr.tokens.SID];
  this.$init = function (code, line) {
    const result = amiTwig.tokenizer.tokenize(code, line, this._spaces, this._tokenDefs, this._tokenTypes, true);
    this.tokens = result.tokens;
    this.types = result.types;
    this.i = 0;
  };
  this.next = function (n) {
    if (n === void 0) {
      n = 1;
    }
    this.i += n;
  };
  this.isEmpty = function () {
    return this.i >= this.tokens.length;
  };
  this.peekToken = function () {
    return this.tokens[this.i];
  };
  this.peekType = function () {
    return this.types[this.i];
  };
  this.checkType = function (type) {
    if (this.i < this.tokens.length) {
      const TYPE = this.types[this.i];
      return type instanceof Array ? type.indexOf(TYPE) >= 0 : type === TYPE;
    }
    return false;
  };
  this.$init(code, line);
};
amiTwig.expr.Compiler = function (code, line) {
  this.$init(code, line);
};
amiTwig.expr.Compiler.prototype = {
  $init: function (code, line) {
    this.tokenizer = new amiTwig.expr.Tokenizer(this.code = code, this.line = line);
    this.rootNode = this.parseNullCoalescing();
    if (this.tokenizer.isEmpty() === false) {
      throw 'syntax error, line `' + this.line + '`, unexpected token `' + this.tokenizer.peekToken() + '`';
    }
  },
  dump: function () {
    return this.rootNode.dump();
  },
  parseNullCoalescing: function () {
    let left = this.parseLogicalOr(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.DOUBLE_QUESTION)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseLogicalOr();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseLogicalOr: function () {
    let left = this.parseLogicalAnd(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.LOGICAL_OR)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseLogicalAnd();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseLogicalAnd: function () {
    let left = this.parseBitwiseOr(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.LOGICAL_AND)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseBitwiseOr();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseBitwiseOr: function () {
    let left = this.parseBitwiseXor(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.BITWISE_OR)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseBitwiseXor();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseBitwiseXor: function () {
    let left = this.parseBitwiseAnd(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.BITWISE_XOR)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseBitwiseAnd();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseBitwiseAnd: function () {
    let left = this.parseNot(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.BITWISE_AND)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseNot();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseNot: function () {
    let right, node;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.NOT)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseComp();
      node.nodeLeft = null;
      node.nodeRight = right;
      return node;
    }
    return this.parseComp();
  },
  parseComp: function () {
    let left = this.parseAddSub(),
      right,
      node,
      swap;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.IS)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      swap = node;
      if (this.tokenizer.checkType(amiTwig.expr.tokens.NOT)) {
        node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
        this.tokenizer.next();
        node.nodeLeft = null;
        node.nodeRight = swap;
      }
      if (this.tokenizer.checkType(amiTwig.expr.tokens.IS_XXX)) {
        right = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
        this.tokenizer.next();
        swap.nodeLeft = left;
        swap.nodeRight = right;
      } else {
        throw 'syntax error, line `' + this.line + '`, keyword `defined`, `null`, `empty`, `iterable`, `even` or `odd` expected';
      }
      left = node;
    } else if (this.tokenizer.checkType(amiTwig.expr.tokens.CMP_OP)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseAddSub();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    } else if (this.tokenizer.checkType(amiTwig.expr.tokens.XXX_WITH)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseAddSub();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    } else if (this.tokenizer.checkType(amiTwig.expr.tokens.MATCHES)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseAddSub();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    } else if (this.tokenizer.checkType(amiTwig.expr.tokens.IN)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseAddSub();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseAddSub: function () {
    let left = this.parseMulDiv(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.PLUS_MINUS)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseMulDiv();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseMulDiv: function () {
    let left = this.parsePlusMinus(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.MUL_FLDIV_DIV_MOD)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parsePlusMinus();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parsePlusMinus: function () {
    let right, node;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.PLUS_MINUS)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parsePower();
      node.nodeLeft = null;
      node.nodeRight = right;
      return node;
    }
    return this.parsePower();
  },
  parsePower: function () {
    let left = this.parseFilter(),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.POWER)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      right = this.parseFilter();
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseFilter: function () {
    let left = this.parseDot1(),
      node,
      temp;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.PIPE)) {
      this.tokenizer.next();
      node = this.parseDot1(true);
      for (temp = node; temp.nodeType === amiTwig.expr.tokens.DOT; temp = temp.nodeLeft) {}
      temp.list.unshift(left);
      left = node;
    }
    return left;
  },
  parseDot1: function (isFilter) {
    const node = this.parseDot2(isFilter);
    if (node) {
      let temp;
      for (temp = node; temp.nodeType === amiTwig.expr.tokens.DOT; temp = temp.nodeLeft) {}
      if (temp.q) {
        if (temp.nodeType === amiTwig.expr.tokens.FUN) {
          if (temp.nodeValue in amiTwig.stdlib) {
            temp.nodeValue = 'amiTwig.stdlib.' + temp.nodeValue;
          } else {
            temp.nodeValue = '_.' + temp.nodeValue;
          }
        } else if (temp.nodeType === amiTwig.expr.tokens.VAR) {
          temp.nodeValue = '_.' + temp.nodeValue;
        }
        temp.q = false;
      }
    }
    return node;
  },
  parseDot2: function (isFilter) {
    let left = this.parseDot3(isFilter),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.DOT)) {
      node = new amiTwig.expr.Node(this.tokenizer.peekType(), '.');
      this.tokenizer.next();
      right = this.parseDot3(isFilter);
      node.nodeLeft = left;
      node.nodeRight = right;
      left = node;
    }
    return left;
  },
  parseDot3: function (isFilter) {
    let left = this.parseX(isFilter),
      right,
      node;
    while (this.tokenizer.checkType(amiTwig.expr.tokens.LB1)) {
      this.tokenizer.next();
      right = this.parseNullCoalescing();
      if (this.tokenizer.checkType(amiTwig.expr.tokens.RB1)) {
        this.tokenizer.next();
        node = new amiTwig.expr.Node(amiTwig.expr.tokens.DOT, '[]');
        node.nodeLeft = left;
        node.nodeRight = right;
        left = node;
      } else {
        throw 'syntax error, line `' + this.line + '`, `]` expected';
      }
    }
    return left;
  },
  parseX: function (isFilter) {
    let node;
    if (node = this.parseGroup()) {
      return node;
    }
    if (node = this.parseArray()) {
      return node;
    }
    if (node = this.parseObject()) {
      return node;
    }
    if (node = this.parseFunVar(isFilter)) {
      return node;
    }
    if (node = this.parseTerminal()) {
      return node;
    }
    throw 'syntax error, line `' + this.line + '`, syntax error or truncated expression';
  },
  parseGroup: function () {
    let node;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.LP)) {
      this.tokenizer.next();
      node = this.parseNullCoalescing();
      if (this.tokenizer.checkType(amiTwig.expr.tokens.RP)) {
        this.tokenizer.next();
        return node;
      } else {
        throw 'syntax error, line `' + this.line + '`, `)` expected';
      }
    }
    return null;
  },
  parseArray: function () {
    let node, list;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.LB1)) {
      this.tokenizer.next();
      list = this._parseSinglets();
      if (this.tokenizer.checkType(amiTwig.expr.tokens.RB1)) {
        this.tokenizer.next();
        node = new amiTwig.expr.Node(amiTwig.expr.tokens.LST, 'Array');
        node.list = list;
        return node;
      } else {
        throw 'syntax error, line `' + this.line + '`, `]` expected';
      }
    }
    return null;
  },
  parseObject: function () {
    let node, dict;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.LB2)) {
      this.tokenizer.next();
      dict = this._parseDoublets();
      if (this.tokenizer.checkType(amiTwig.expr.tokens.RB2)) {
        this.tokenizer.next();
        node = new amiTwig.expr.Node(amiTwig.expr.tokens.DIC, 'Object');
        node.dict = dict;
        return node;
      } else {
        throw 'syntax error, line `' + this.line + '`, `}` expected';
      }
    }
    return null;
  },
  parseFunVar: function (isFilter) {
    let node;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.SID)) {
      node = new amiTwig.expr.Node(0, isFilter ? 'filter_' + this.tokenizer.peekToken() : this.tokenizer.peekToken());
      node.q = true;
      this.tokenizer.next();
      if (this.tokenizer.checkType(amiTwig.expr.tokens.LP)) {
        this.tokenizer.next();
        node.list = this._parseSinglets();
        if (this.tokenizer.checkType(amiTwig.expr.tokens.RP)) {
          this.tokenizer.next();
          node.nodeType = amiTwig.expr.tokens.FUN;
        } else {
          throw 'syntax error, line `' + this.line + '`, `)` expected';
        }
      } else {
        node.nodeType = isFilter ? amiTwig.expr.tokens.FUN : amiTwig.expr.tokens.VAR;
        node.list = [];
      }
      return node;
    }
    return null;
  },
  _parseSinglets: function () {
    const result = [];
    while (this.tokenizer.checkType(amiTwig.expr.tokens.RX) === false) {
      this._parseSinglet(result);
      if (this.tokenizer.checkType(amiTwig.expr.tokens.COMMA) === true) {
        this.tokenizer.next();
      } else {
        break;
      }
    }
    return result;
  },
  _parseDoublets: function () {
    const result = {};
    while (this.tokenizer.checkType(amiTwig.expr.tokens.RB2) === false) {
      this._parseDoublet(result);
      if (this.tokenizer.checkType(amiTwig.expr.tokens.COMMA) === true) {
        this.tokenizer.next();
      } else {
        break;
      }
    }
    return result;
  },
  _parseSinglet: function (result) {
    result.push(this.parseNullCoalescing());
  },
  _parseDoublet: function (result) {
    if (this.tokenizer.checkType(amiTwig.expr.tokens.TERMINAL)) {
      const key = this.tokenizer.peekToken();
      this.tokenizer.next();
      if (this.tokenizer.checkType(amiTwig.expr.tokens.COLON)) {
        this.tokenizer.next();
        result[key] = this.parseNullCoalescing();
      } else {
        throw 'syntax error, line `' + this.line + '`, `:` expected';
      }
    } else {
      throw 'syntax error, line `' + this.line + '`, terminal expected';
    }
  },
  parseTerminal: function () {
    let left, right, node;
    if (this.tokenizer.checkType(amiTwig.expr.tokens.TERMINAL)) {
      left = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
      this.tokenizer.next();
      if (this.tokenizer.checkType(amiTwig.expr.tokens.RANGE)) {
        node = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
        this.tokenizer.next();
        if (this.tokenizer.checkType(amiTwig.expr.tokens.TERMINAL)) {
          right = new amiTwig.expr.Node(this.tokenizer.peekType(), this.tokenizer.peekToken());
          this.tokenizer.next();
          node.nodeLeft = left;
          node.nodeRight = right;
          return node;
        }
      } else {
        return left;
      }
    }
    return null;
  }
};
amiTwig.expr.Node = function (nodeType, nodeValue) {
  this.$init(nodeType, nodeValue);
};
amiTwig.expr.Node.prototype = {
  $init: function (nodeType, nodeValue) {
    this.nodeType = nodeType;
    this.nodeValue = nodeValue;
    this.nodeLeft = null;
    this.nodeRight = null;
    this.list = null;
    this.dict = null;
  },
  _dump: function (nodes, edges, pCnt) {
    let CNT;
    const cnt = pCnt[0];
    nodes.push('\tnode' + cnt + ' [label="' + this.nodeValue.replace(/"/g, '\\"') + '"];');
    if (this.nodeLeft) {
      CNT = ++pCnt[0];
      edges.push('\tnode' + cnt + ' -> node' + CNT + ';');
      this.nodeLeft._dump(nodes, edges, pCnt);
    }
    if (this.nodeRight) {
      CNT = ++pCnt[0];
      edges.push('\tnode' + cnt + ' -> node' + CNT + ';');
      this.nodeRight._dump(nodes, edges, pCnt);
    }
    if (this.list) {
      for (const i in this.list) {
        CNT = ++pCnt[0];
        edges.push('\tnode' + cnt + ' -> node' + CNT + ' [label="[' + i.replace(/"/g, '\\"') + ']"];');
        this.list[i]._dump(nodes, edges, pCnt);
      }
    }
    if (this.dict) {
      for (const i in this.dict) {
        CNT = ++pCnt[0];
        edges.push('\tnode' + cnt + ' -> node' + CNT + ' [label="[' + i.replace(/"/g, '\\"') + ']"];');
        this.dict[i]._dump(nodes, edges, pCnt);
      }
    }
  },
  dump: function () {
    const nodes = [];
    const edges = [];
    this._dump(nodes, edges, [0]);
    return 'digraph ast {\n\trankdir=TB;\n' + nodes.join('\n') + '\n' + edges.join('\n') + '\n}';
  }
};
amiTwig.tmpl = {};
amiTwig.tmpl.Compiler = function (tmpl) {
  this.$init(tmpl);
};
amiTwig.tmpl.Compiler.prototype = {
  STATEMENT_RE: /{%\s*([a-zA-Z]+)\s*((?:.|\n)*?)\s*%}/,
  COMMENT_RE: /{#\s*((?:.|\n)*?)\s*#}/g,
  _count: function (s) {
    let result = 0;
    const l = s.length;
    for (let i = 0; i < l; i++) {
      if (s[i] === '\n') result++;
    }
    return result;
  },
  $init: function (tmpl) {
    let line = 1;
    let column;
    let COLUMN;
    this.rootNode = {
      line: line,
      keyword: '@root',
      expression: '',
      blocks: [{
        expression: '@true',
        list: []
      }],
      value: ''
    };
    const stack1 = [this.rootNode];
    const stack2 = [0x00000000000];
    let item;
    for (tmpl = tmpl.replace(this.COMMENT_RE, '');; tmpl = tmpl.substr(COLUMN)) {
      const curr = stack1[stack1.length - 1];
      let indx = stack2[stack2.length - 1];
      const m = tmpl.match(this.STATEMENT_RE);
      if (m === null) {
        line += this._count(tmpl);
        curr.blocks[indx].list.push({
          line: line,
          keyword: '@text',
          expression: '',
          blocks: [],
          value: tmpl
        });
        const errors = [];
        for (let i = stack1.length - 1; i > 0; i--) {
          if (stack1[i].keyword === 'if') {
            errors.push('missing keyword `endif`');
          } else if (stack1[i].keyword === 'for') {
            errors.push('missing keyword `endfor`');
          }
        }
        if (errors.length > 0) {
          throw 'syntax error, line `' + line + '`, ' + errors.join(', ');
        }
        break;
      }
      const match = m[0];
      const keyword = m[1];
      const expression = m[2];
      column = m.index + 0x0000000000;
      COLUMN = m.index + match.length;
      const value = tmpl.substr(0, column);
      const VALUE = tmpl.substr(0, COLUMN);
      line += this._count(VALUE);
      if (value) {
        item = {
          line: line,
          keyword: '@text',
          expression: '',
          blocks: [],
          value: value
        };
        curr.blocks[indx].list.push(item);
      }
      switch (keyword) {
        case 'flush':
        case 'autoescape':
        case 'spaceless':
        case 'verbatim':
          break;
        case 'do':
        case 'set':
        case 'include':
          item = {
            line: line,
            keyword: keyword,
            expression: expression,
            blocks: [],
            value: ''
          };
          curr.blocks[indx].list.push(item);
          break;
        case 'if':
        case 'for':
          item = {
            line: line,
            keyword: keyword,
            blocks: [{
              expression: expression,
              list: []
            }],
            value: ''
          };
          curr.blocks[indx].list.push(item);
          stack1.push(item);
          stack2.push(0x00);
          break;
        case 'elseif':
          if (curr['keyword'] !== 'if') {
            throw 'syntax error, line `' + line + '`, unexpected keyword `elseif`';
          }
          indx = curr.blocks.length;
          curr.blocks.push({
            expression: expression,
            list: []
          });
          stack2[stack2.length - 1] = indx;
          break;
        case 'else':
          if (curr['keyword'] !== 'if' && curr['keyword'] !== 'for') {
            throw 'syntax error, line `' + line + '`, unexpected keyword `else`';
          }
          indx = curr.blocks.length;
          curr.blocks.push({
            expression: '@true',
            list: []
          });
          stack2[stack2.length - 1] = indx;
          break;
        case 'endif':
          if (curr['keyword'] !== 'if') {
            throw 'syntax error, line `' + line + '`, unexpected keyword `endif`';
          }
          stack1.pop();
          stack2.pop();
          break;
        case 'endfor':
          if (curr['keyword'] !== 'for') {
            throw 'syntax error, line `' + line + '`, unexpected keyword `endfor`';
          }
          stack1.pop();
          stack2.pop();
          break;
        default:
          throw 'syntax error, line `' + line + '`, unknown keyword `' + keyword + '`';
      }
    }
  },
  dump: function () {
    return JSON.stringify(this.rootNode, null, 2);
  }
};
amiTwig.engine = {
  VARIABLE_RE: /{{\s*(.*?)\s*}}/g,
  _render: function (result, item, dict, tmpls) {
    if (dict === void 0) {
      dict = {};
    }
    if (tmpls === void 0) {
      tmpls = {};
    }
    let m;
    let expression;
    this.dict = dict;
    this.tmpls = tmpls;
    switch (item.keyword) {
      case 'do':
        {
          amiTwig.expr.cache.eval(item.expression, item.line, dict);
          break;
        }
      case 'set':
        {
          m = item.expression.match(/((?:[a-zA-Z_$][a-zA-Z0-9_$]*\.)*[a-zA-Z_$][a-zA-Z0-9_$]*)\s*=\s*(.+)/);
          if (!m) {
            throw 'syntax error, line `' + item.line + '`, invalid `set` statement';
          }
          const parts = m[1].split('.'),
            l = parts.length - 1;
          let parent, j;
          if (parts[0] === 'window' || parts[0] === 'global') {
            if (typeof window !== 'undefined') {
              parent = window;
            } else if (typeof __webpack_require__.g !== 'undefined') {
              parent = __webpack_require__.g;
            } else {
              throw 'internal error';
            }
            j = 1;
          } else {
            parent = dict;
            j = 0;
          }
          let i;
          for (i = j; i < l; i++) {
            if (parent[parts[i]]) {
              parent = parent[parts[i]];
            } else {
              throw 'runtime error, line `' + item.line + '`, `' + m[1] + '` not declared';
            }
          }
          parent[parts[i]] = amiTwig.expr.cache.eval(m[2], item.line, dict);
          break;
        }
      case '@text':
        {
          result.push(item.value.replace(this.VARIABLE_RE, function (match, expression) {
            let value = amiTwig.expr.cache.eval(expression, item.line, dict);
            return value !== null && value !== undefined ? value : '';
          }));
          break;
        }
      case 'if':
      case '@root':
        {
          item.blocks.every(block => {
            expression = block.expression;
            if (expression === '@true' || amiTwig.expr.cache.eval(expression, item.line, dict)) {
              for (const i in block.list) {
                this._render(result, block.list[i], dict, tmpls);
              }
              return false;
            }
            return true;
          });
          break;
        }
      case 'for':
        {
          let sym1;
          let sym2;
          let expr;
          m = item.blocks[0].expression.match(/([a-zA-Z_$][a-zA-Z0-9_$]*)\s*,\s*([a-zA-Z_$][a-zA-Z0-9_$]*)\s+in\s+(.+)/);
          if (!m) {
            m = item.blocks[0].expression.match(/([a-zA-Z_$][a-zA-Z0-9_$]*)\s+in\s+(.+)/);
            if (!m) {
              throw 'syntax error, line `' + item.line + '`, invalid `for` statement';
            } else {
              sym1 = m[1];
              sym2 = null;
              expr = m[2];
            }
          } else {
            sym1 = m[1];
            sym2 = m[2];
            expr = m[3];
          }
          const origValue = amiTwig.expr.cache.eval(expr, item.line, dict);
          const typeName = Object.prototype.toString.call(origValue);
          let iterValue;
          if (typeName === '[object Object]') {
            iterValue = sym2 ? Object.entries(origValue) : Object.keys(origValue);
          } else {
            iterValue = origValue;
            if (typeName !== '[object Array]' && typeName !== '[object String]') {
              throw 'syntax error, line `' + item.line + '`, right operand not iterable';
            }
            if (sym2) {
              throw 'syntax error, line `' + item.line + '`, right operand not an object';
            }
          }
          const l = iterValue.length;
          if (l > 0) {
            let k = 0x00000000000000;
            const list = item.blocks[0].list;
            if (sym2) {
              const old1 = dict[sym1];
              const old2 = dict[sym2];
              const old3 = dict['loop'];
              dict.loop = {
                length: l,
                parent: dict['loop']
              };
              for (const i in iterValue) {
                dict[sym1] = iterValue[i][0];
                dict[sym2] = iterValue[i][1];
                dict.loop.first = k === 0 - 0;
                dict.loop.last = k === l - 1;
                dict.loop.revindex0 = l - k;
                dict.loop.index0 = k;
                k++;
                dict.loop.revindex = l - k;
                dict.loop.index = k;
                for (const j in list) {
                  this._render(result, list[j], dict, tmpls);
                }
              }
              dict['loop'] = old3;
              dict[sym2] = old2;
              dict[sym1] = old1;
            } else {
              const old1 = dict[sym1];
              const old2 = dict['loop'];
              dict.loop = {
                length: l,
                parent: dict['loop']
              };
              for (const i in iterValue) {
                dict[sym1] = iterValue[i];
                dict.loop.first = k === 0 - 0;
                dict.loop.last = k === l - 1;
                dict.loop.revindex0 = l - k;
                dict.loop.index0 = k;
                k++;
                dict.loop.revindex = l - k;
                dict.loop.index = k;
                for (const j in list) {
                  this._render(result, list[j], dict, tmpls);
                }
              }
              dict['loop'] = old2;
              dict[sym1] = old1;
            }
          } else {
            if (item.blocks.length > 1) {
              const list = item.blocks[1].list;
              for (const j in list) {
                this._render(result, list[j], dict, tmpls);
              }
            }
          }
          break;
        }
      case 'include':
        {
          let m_1_ = item.expression,
            with_subexpr,
            with_context;
          if (m = m_1_.match(/(.+)\s+with\s+(.+)\s+only$/)) {
            expression = m[1];
            with_subexpr = m[2];
            with_context = false;
          } else if (m = m_1_.match(/(.+)\s+with\s+(.+)$/)) {
            expression = m[1];
            with_subexpr = m[2];
            with_context = true;
          } else if (m = m_1_.match(/(.+)\s+only$/)) {
            expression = m[1];
            with_subexpr = '{}';
            with_context = false;
          } else {
            expression = m_1_;
            with_subexpr = '{}';
            with_context = true;
          }
          const fileName = amiTwig.expr.cache.eval(expression, item.line, dict) || '';
          if (Object.prototype.toString.call(fileName) !== '[object String]') {
            throw 'runtime error, line `' + item.line + '`, string expected';
          }
          const variables = amiTwig.expr.cache.eval(with_subexpr, item.line, dict) || {};
          if (Object.prototype.toString.call(variables) !== '[object Object]') {
            throw 'runtime error, line `' + item.line + '`, object expected';
          }
          result.push(amiTwig.stdlib.include(fileName, variables, with_context, false));
          break;
        }
    }
  },
  render: function (tmpl, dict, tmpls) {
    if (dict === void 0) {
      dict = {};
    }
    if (tmpls === void 0) {
      tmpls = {};
    }
    const result = [];
    switch (Object.prototype.toString.call(tmpl)) {
      case '[object String]':
        this._render(result, new amiTwig.tmpl.Compiler(tmpl).rootNode, dict, tmpls);
        break;
      case '[object Object]':
        this._render(result, tmpl, dict, tmpls);
        break;
    }
    return result.join('');
  }
};
amiTwig.expr.cache = {
  dict: {},
  eval: function (expression, line, _) {
    let f;
    if (expression in this.dict) {
      f = this.dict[expression];
    } else {
      f = this.dict[expression] = eval(amiTwig.expr.interpreter.getJS(new amiTwig.expr.Compiler(expression, line)));
    }
    _ = _ || {};
    return f.call(_, _);
  }
};
amiTwig.stdlib = {
  'isUndefined': function (x) {
    return x === undefined;
  },
  'isDefined': function (x) {
    return x !== undefined;
  },
  'isNull': function (x) {
    return x === null;
  },
  'isNotNull': function (x) {
    return x !== null;
  },
  'isEmpty': function (x) {
    if (x === null || x === false || x === '') {
      return true;
    }
    const typeName = Object.prototype.toString.call(x);
    return typeName === '[object Array]' && x.length === 0 || (typeName === '[object Set]' || typeName === '[object WeakSet]') && x.size === 0 || (typeName === '[object Object]' || typeName === '[object Map]' || typeName === '[object WeakMap]') && Object.keys(x).length === 0;
  },
  'isNumber': function (x) {
    const typeName = Object.prototype.toString.call(x);
    return typeName === '[object Number]' || typeName === '[object BigInt]';
  },
  'isString': function (x) {
    return Object.prototype.toString.call(x) === '[object String]';
  },
  'isDate': function (x) {
    return Object.prototype.toString.call(x) === '[object Date]';
  },
  'isArray': function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  },
  'isObject': function (x) {
    return Object.prototype.toString.call(x) === '[object Object]';
  },
  'isSet': function (x) {
    const typeName = Object.prototype.toString.call(x);
    return typeName === '[object Set]' || typeName === '[object WeakSet]';
  },
  'isMap': function (x) {
    const typeName = Object.prototype.toString.call(x);
    return typeName === '[object Object]' || typeName === '[object Map]' || typeName === '[object WeakMap]';
  },
  'isIterable': function (x) {
    const typeName = Object.prototype.toString.call(x);
    return typeName === '[object String]' || typeName === '[object Array]' || typeName === '[object Object]' || typeName === '[object Set]' || typeName === '[object WeakSet]' || typeName === '[object Map]' || typeName === '[object WeakMap]';
  },
  'isEven': function (x) {
    return this.isNumber(x) && (x & 1) === 0;
  },
  'isOdd': function (x) {
    return this.isNumber(x) && (x & 1) === 1;
  },
  'isInObject': function (x, y) {
    if (this.isArray(y) || this.isString(y)) {
      return y.indexOf(x) >= 0;
    }
    if (this.isSet(y)) {
      return y.has(x);
    }
    if (this.isMap(y)) {
      return Object.prototype.hasOwnProperty.call(y, x);
    }
    return false;
  },
  'isInRange': function (x, x1, x2) {
    if (this.isNumber(x1) && this.isNumber(x2)) {
      return (x >= x1) && (x <= x2);
    }
    if (this.isString(x1) && x1.length === 1 && this.isString(x2) && x2.length === 1) {
      return x.charCodeAt(0) >= x1.charCodeAt(0) && x.charCodeAt(0) <= x2.charCodeAt(0);
    }
    return false;
  },
  'range': function (x1, x2, step) {
    if (step === void 0) {
      step = 1;
    }
    const result = [];
    if (this.isNumber(x1) && this.isNumber(x2)) {
      for (let i = x1; i <= x2; i += step) {
        result.push(i);
      }
    } else if (this.isString(x1) && x1.length === 1 && this.isString(x2) && x2.length === 1) {
      for (let i = x1.charCodeAt(0); i <= x2.charCodeAt(0); i += step) {
        result.push(String.fromCharCode(i));
      }
    }
    return result;
  },
  'filter_length': function (x) {
    if (this.isString(x) || this.isArray(x) || this.isSet(x)) {
      return x.length;
    }
    if (this.isSet(x)) {
      return x.size;
    }
    if (this.isMap(x)) {
      return Object.keys(x).length;
    }
    return 0;
  },
  'filter_first': function (x) {
    return (this.isString(x) || this.isArray(x)) && x.length > 0 ? x[0x0000000000] : '';
  },
  'filter_last': function (x) {
    return (this.isString(x) || this.isArray(x)) && x.length > 0 ? x[x.length - 1] : '';
  },
  'filter_slice': function (x, idx1, idx2) {
    return this.isString(x) || this.isArray(x) ? x.slice(idx1, idx2) : null;
  },
  'filter_merge': function () {
    if (arguments.length > 1) {
      if (this.isString(arguments[0])) {
        const L = [];
        for (const i in arguments) {
          const item = arguments[i];
          if (!this.isString(item)) {
            return null;
          }
          L.push(arguments[i]);
        }
        return L.join('');
      }
      if (this.isArray(arguments[0])) {
        const L = [];
        for (const i in arguments) {
          const item = arguments[i];
          if (!this.isArray(item)) {
            return null;
          }
          item.forEach(x => L.push(x));
        }
        return L;
      }
      if (this.isSet(arguments[0])) {
        const L = [];
        for (const i in arguments) {
          const item = arguments[i];
          if (!this.isSet(item)) {
            return null;
          }
          item.forEach(x => L.add(x));
        }
        return L;
      }
      if (this.isObject(arguments[0])) {
        const D = {};
        for (const i in arguments) {
          const item = arguments[i];
          if (!this.isObject(item)) {
            return null;
          }
          for (const j in item) D[j] = item[j];
        }
        return D;
      }
    }
    return null;
  },
  'filter_sort': function (x) {
    return this.isArray(x) ? x.sort() : [];
  },
  'filter_reverse': function (x) {
    return this.isArray(x) ? x.reverse() : [];
  },
  'filter_join': function (x, sep) {
    return this.isArray(x) ? x.join(sep) : '';
  },
  'filter_keys': function (x) {
    return this.isMap(x) ? Object.keys(x) : [];
  },
  'filter_column': function (x, key) {
    return this.isArray(x) ? x.map(val => val[key]) : [];
  },
  'filter_batch': function (x, n, missing) {
    if (missing === void 0) {
      missing = '';
    }
    const result = [];
    if (this.isArray(x) && this.isNumber(n)) {
      const l = x.length;
      if (l > 0) {
        let last;
        const m = Math.ceil(l / n) * n;
        for (let i = 0; i < l; i += n) {
          result.push(last = x.slice(i, i + n));
        }
        for (let i = l; i < m; i += 1) {
          last.push(missing);
        }
      }
    }
    return result;
  },
  'startsWith': function (s1, s2) {
    if (this.isString(s1) && this.isString(s2)) {
      const base = 0x0000000000000000000;
      return s1.indexOf(s2, base) === base;
    }
    return false;
  },
  'endsWith': function (s1, s2) {
    if (this.isString(s1) && this.isString(s2)) {
      const base = s1.length - s2.length;
      return s1.indexOf(s2, base) === base;
    }
    return false;
  },
  'match': function (s, regex) {
    if (this.isString(s) && this.isString(regex)) {
      const idx1 = regex.indexOf('/');
      const idx2 = regex.lastIndexOf('/');
      if (idx1 === 0 || idx1 < idx2) {
        try {
          return new RegExp(regex.substring(idx1 + 1, idx2), regex.substring(idx2 + 1)).test(s);
        } catch (err) {}
      }
    }
    return false;
  },
  'filter_default': function (s1, s2) {
    return s1 || s2 || '';
  },
  'filter_lower': function (s) {
    return this.isString(s) ? s.toLowerCase() : '';
  },
  'filter_upper': function (s) {
    return this.isString(s) ? s.toUpperCase() : '';
  },
  'filter_capitalize': function (s) {
    if (this.isString(s)) {
      return s.trim().toLowerCase().replace(/^\S/g, function (c) {
        return c.toUpperCase();
      });
    }
    return '';
  },
  'filter_title': function (s) {
    if (this.isString(s)) {
      return s.trim().toLowerCase().replace(/(?:^|\s)\S/g, function (c) {
        return c.toUpperCase();
      });
    }
    return '';
  },
  'filter_trim': function (s) {
    return this.isString(s) ? s.trim() : '';
  },
  '_replace': function (s, oldStrs, newStrs) {
    const result = [];
    const l = s.length;
    const m = oldStrs.length;
    const n = newStrs.length;
    if (m !== n) {
      throw 'internal error';
    }
    __l0: for (let i = 0; i < l; i += 0) {
      const p = s.substring(i);
      for (let j = 0; j < m; j += 1) {
        if (p.indexOf(oldStrs[j]) === 0) {
          result.push(newStrs[j]);
          i += oldStrs[j].length;
          continue __l0;
        }
      }
      result.push(s.charAt(i++));
    }
    return result.join('');
  },
  '_textToHtmlX': ['&', '"', '<', '>'],
  '_textToHtmlY': ['&amp;', '&quot;', '&lt;', '&gt;'],
  '_textToStringX': ['\\', '\r', '\n', '"', '\''],
  '_textToStringY': ['\\\\', '\\r', '\\n', '\\"', '\\\''],
  '_textToJsonStringX': ['\\', '\r', '\n', '"'],
  '_textToJsonStringY': ['\\\\', '\\r', '\\n', '\\"'],
  'filter_escape': function (s, mode) {
    if (this.isString(s)) {
      switch (mode || 'html') {
        case 'html':
        case 'html_attr':
          return this._replace(s, this._textToHtmlX, this._textToHtmlY);
        case 'js':
        case 'string':
          return this._replace(s, this._textToStringX, this._textToStringY);
        case 'json':
          return this._replace(s, this._textToJsonStringX, this._textToJsonStringY);
        case 'url':
          return encodeURIComponent(s);
        default:
          return s;
      }
    }
    return '';
  },
  'filter_url_encode': function (s) {
    return this.isString(s) ? encodeURIComponent(s) : '';
  },
  'filter_nl2br': function (s) {
    return this.isString(s) ? s.replace(/\n/g, '<br/>') : '';
  },
  'filter_raw': function (s) {
    return this.isString(s) ? s : '';
  },
  'filter_replace': function (s, dict) {
    return this.isString(s) && this.isMap(dict) ? this._replace(s, Object.keys(dict), Object.values(dict)) : '';
  },
  'filter_split': function (s, sep, max) {
    return this.isString(s) ? s.split(sep, max) : [];
  },
  'filter_format_number': function (x) {
    return parseFloat(x);
  },
  'filter_format_decimal_number': function (x) {
    return parseInt(x);
  },
  'filter_abs': function (x) {
    return Math.abs(x);
  },
  'filter_round': function (x, mode) {
    switch (mode) {
      case 'ceil':
        return Math.ceil(x);
      case 'floor':
        return Math.floor(x);
      default:
        return Math.round(x);
    }
  },
  'min': function () {
    const args = arguments.length === 1 && (this.isArray(arguments[0]) || this.isObject(arguments[0])) ? arguments[0] : arguments;
    let result = Number.POSITIVE_INFINITY;
    for (const i in args) {
      if (!this.isNumber(args[i])) {
        return Number.NaN;
      }
      if (result > args[i]) {
        result = args[i];
      }
    }
    return result;
  },
  'max': function () {
    const args = arguments.length === 1 && (this.isArray(arguments[0]) || this.isObject(arguments[0])) ? arguments[0] : arguments;
    let result = Number.NEGATIVE_INFINITY;
    for (const i in args) {
      if (!this.isNumber(args[i])) {
        return Number.NaN;
      }
      if (result < args[i]) {
        result = args[i];
      }
    }
    return result;
  },
  'random': function (x) {
    const y = Math.random();
    if (x) {
      if (this.isArray(x) || this.isMap(x)) {
        const X = Object.keys(x);
        return x[X[Math.floor(X.length * y)]];
      }
      if (this.isString(x)) {
        return x[Math.floor(x.length * y)];
      }
      if (this.isNumber(x)) {
        return Math.floor(x * y);
      }
    }
    x = Number.MAX_SAFE_INTEGER;
    return Math.floor(x * y);
  },
  'filter_date': function (date, format, timezone) {
    if (typeof moment !== 'undefined' && (this.isDate(date) || this.isString(date)) && this.isString(format)) {
      if (typeof moment.tz !== 'undefined' && this.isString(timezone)) {
        return moment(date).tz(timezone).format(format);
      } else {
        return moment(date).format(format);
      }
    }
    return '';
  },
  'filter_json_encode': function (x, indent) {
    return JSON.stringify(x, null, this.isNumber(indent) ? indent : 2);
  },
  'filter_json_jspath': function (x, path) {
    return typeof JSPath !== 'undefined' ? JSPath.apply(path, x) : [];
  },
  'include': function (fileName, variables, withContext, ignoreMissing) {
    if (variables === void 0) {
      variables = {};
    }
    if (withContext === void 0) {
      withContext = true;
    }
    if (ignoreMissing === void 0) {
      ignoreMissing = false;
    }
    if (fileName in amiTwig.engine.tmpls) {
      const temp = {};
      if (withContext) {
        for (const i in amiTwig.engine.dict) {
          temp[i] = amiTwig.engine.dict[i];
        }
      }
      if (variables) {
        for (const i in variables) {
          temp[i] = variables[i];
        }
      }
      return amiTwig.engine.render(amiTwig.engine.tmpls[fileName], temp);
    }
    if (!ignoreMissing) {
      throw 'runtime error, could not open `' + fileName + '`';
    }
    return '';
  }
};
amiTwig.stdlib.filter_e = amiTwig.stdlib.filter_escape;
amiTwig.expr.interpreter = {
  _getJS: function (node) {
    let L;
    let x;
    let left;
    let right;
    let operator;
    switch (node.nodeType) {
      case amiTwig.expr.tokens.LST:
        L = [];
        for (const i in node.list) {
          L.push(this._getJS(node.list[i]));
        }
        return '[' + L.join(',') + ']';
      case amiTwig.expr.tokens.DIC:
        L = [];
        for (const i in node.dict) {
          L.push(i + ':' + this._getJS(node.dict[i]));
        }
        return '{' + L.join(',') + '}';
      case amiTwig.expr.tokens.FUN:
        L = [];
        for (const i in node.list) {
          L.push(this._getJS(node.list[i]));
        }
        return node.nodeValue + '(' + L.join(',') + ')';
      case amiTwig.expr.tokens.VAR:
        L = [];
        for (const i in node.list) {
          L.push('[' + this._getJS(node.list[i]) + ']');
        }
        return L.length > 0 ? node.nodeValue + L.join('') : node.nodeValue;
      case amiTwig.expr.tokens.TERMINAL:
        return node.nodeValue;
      case amiTwig.expr.tokens.IS:
        left = this._getJS(node.nodeLeft);
        switch (node.nodeRight.nodeType) {
          case amiTwig.expr.tokens.DEFINED:
            return 'amiTwig.stdlib.isDefined(' + left + ')';
          case amiTwig.expr.tokens.NULL:
            return 'amiTwig.stdlib.isNull(' + left + ')';
          case amiTwig.expr.tokens.EMPTY:
            return 'amiTwig.stdlib.isEmpty(' + left + ')';
          case amiTwig.expr.tokens.ITERABLE:
            return 'amiTwig.stdlib.isIterable(' + left + ')';
          case amiTwig.expr.tokens.EVEN:
            return 'amiTwig.stdlib.isEven(' + left + ')';
          case amiTwig.expr.tokens.ODD:
            return 'amiTwig.stdlib.isOdd(' + left + ')';
          default:
            throw 'internal error';
        }
      case amiTwig.expr.tokens.IN:
        if (node.nodeRight.nodeType !== amiTwig.expr.tokens.RANGE) {
          left = this._getJS(node.nodeLeft);
          right = this._getJS(node.nodeRight);
          return 'amiTwig.stdlib.isInObject(' + left + ',' + right + ')';
        } else {
          x = this._getJS(node.nodeLeft);
          left = node.nodeRight.nodeLeft.nodeValue;
          right = node.nodeRight.nodeRight.nodeValue;
          return 'amiTwig.stdlib.isInRange(' + x + ',' + left + ',' + right + ')';
        }
      case amiTwig.expr.tokens.STARTS_WITH:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        return 'amiTwig.stdlib.startsWith(' + left + ',' + right + ')';
      case amiTwig.expr.tokens.ENDS_WITH:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        return 'amiTwig.stdlib.endsWith(' + left + ',' + right + ')';
      case amiTwig.expr.tokens.MATCHES:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        return 'amiTwig.stdlib.match(' + left + ',' + right + ')';
      case amiTwig.expr.tokens.RANGE:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        return 'amiTwig.stdlib.range(' + left + ',' + right + ')';
      case amiTwig.expr.tokens.DOT:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        if (node.nodeValue[0] === '.') {
          return left + '.' + right;
        } else {
          return left + '[' + right + ']';
        }
      case amiTwig.expr.tokens.FLDIV:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        return 'Math.floor(' + left + '/' + right + ')';
      case amiTwig.expr.tokens.POWER:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        return 'Math.pow(' + left + ',' + right + ')';
      case amiTwig.expr.tokens.DOUBLE_QUESTION:
        left = this._getJS(node.nodeLeft);
        right = this._getJS(node.nodeRight);
        return '((' + left + ') || (' + right + '))';
      default:
        if (node.nodeLeft === null && node.nodeRight !== null) {
          operator = node.nodeType !== amiTwig.expr.tokens.NOT ? node.nodeValue : '!';
          return operator + '(' + this._getJS(node.nodeRight) + ')';
        }
        if (node.nodeLeft !== null && node.nodeRight === null) {
          operator = node.nodeType !== amiTwig.expr.tokens.NOT ? node.nodeValue : '!';
          return '(' + this._getJS(node.nodeLeft) + ')' + operator;
        }
        if (node.nodeLeft !== null && node.nodeRight !== null) {
          switch (node.nodeType) {
            case amiTwig.expr.tokens.LOGICAL_OR:
              operator = '||';
              break;
            case amiTwig.expr.tokens.LOGICAL_AND:
              operator = '&&';
              break;
            case amiTwig.expr.tokens.BITWISE_OR:
              operator = '|';
              break;
            case amiTwig.expr.tokens.BITWISE_XOR:
              operator = '^';
              break;
            case amiTwig.expr.tokens.BITWISE_AND:
              operator = '&';
              break;
            case amiTwig.expr.tokens.CONCAT:
              operator = '+';
              break;
            default:
              operator = node.nodeValue;
              break;
          }
          left = this._getJS(node.nodeLeft);
          right = this._getJS(node.nodeRight);
          return '(' + left + operator + right + ')';
        }
    }
  },
  getJS: function (expr) {
    return '(function(_) { return ' + this._getJS(expr.rootNode) + '; })';
  },
  eval: function (expr, _) {
    _ = _ || {};
    return eval(this.getJS(expr)).call(_, _);
  }
};

/***/ }),

/***/ 3258:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/bootstrap-icons.woff2";

/***/ }),

/***/ 3340:
/***/ ((__unused_webpack_module, exports) => {

let toSJISFunction;
const CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
exports.getSymbolSize = function getSymbolSize(version) {
  if (!version) throw new Error('"version" cannot be null or undefined');
  if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40');
  return version * 4 + 17;
};
exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
  return CODEWORDS_COUNT[version];
};
exports.getBCHDigit = function (data) {
  let digit = 0;
  while (data !== 0) {
    digit++;
    data >>>= 1;
  }
  return digit;
};
exports.setToSJISFunction = function setToSJISFunction(f) {
  if (typeof f !== 'function') {
    throw new Error('"toSJISFunc" is not a valid function.');
  }
  toSJISFunction = f;
};
exports.isKanjiModeEnabled = function () {
  return typeof toSJISFunction !== 'undefined';
};
exports.toSJIS = function toSJIS(kanji) {
  return toSJISFunction(kanji);
};

/***/ }),

/***/ 3363:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Regular-webfont.woff";

/***/ }),

/***/ 3487:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Utils = __webpack_require__(3340);
const G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
const G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
const G15_BCH = Utils.getBCHDigit(G15);
exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
  const data = errorCorrectionLevel.bit << 3 | mask;
  let d = data << 10;
  while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
  }
  return (data << 10 | d) ^ G15_MASK;
};

/***/ }),

/***/ 3552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/images/stripe1.png";

/***/ }),

/***/ 3819:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/Trochut-Regular.ttf";

/***/ }),

/***/ 4165:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Utils = __webpack_require__(9984);
function clearCanvas(ctx, canvas, size) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!canvas.style) canvas.style = {};
  canvas.height = size;
  canvas.width = size;
  canvas.style.height = size + 'px';
  canvas.style.width = size + 'px';
}
function getCanvasElement() {
  try {
    return document.createElement('canvas');
  } catch (e) {
    throw new Error('You need to specify a canvas element');
  }
}
exports.render = function render(qrData, canvas, options) {
  let opts = options;
  let canvasEl = canvas;
  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas;
    canvas = undefined;
  }
  if (!canvas) {
    canvasEl = getCanvasElement();
  }
  opts = Utils.getOptions(opts);
  const size = Utils.getImageWidth(qrData.modules.size, opts);
  const ctx = canvasEl.getContext('2d');
  const image = ctx.createImageData(size, size);
  Utils.qrToImageData(image.data, qrData, opts);
  clearCanvas(ctx, canvasEl, size);
  ctx.putImageData(image, 0, 0);
  return canvasEl;
};
exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
  let opts = options;
  if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
    opts = canvas;
    canvas = undefined;
  }
  if (!opts) opts = {};
  const canvasEl = exports.render(qrData, canvas, opts);
  const type = opts.type || 'image/png';
  const rendererOpts = opts.rendererOpts || {};
  return canvasEl.toDataURL(type, rendererOpts.quality);
};

/***/ }),

/***/ 4271:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Mode = __webpack_require__(8674);
const Utils = __webpack_require__(3340);
function KanjiData(data) {
  this.mode = Mode.KANJI;
  this.data = data;
}
KanjiData.getBitsLength = function getBitsLength(length) {
  return length * 13;
};
KanjiData.prototype.getLength = function getLength() {
  return this.data.length;
};
KanjiData.prototype.getBitsLength = function getBitsLength() {
  return KanjiData.getBitsLength(this.data.length);
};
KanjiData.prototype.write = function (bitBuffer) {
  let i;
  for (i = 0; i < this.data.length; i++) {
    let value = Utils.toSJIS(this.data[i]);
    if (value >= 0x8140 && value <= 0x9FFC) {
      value -= 0x8140;
    } else if (value >= 0xE040 && value <= 0xEBBF) {
      value -= 0xC140;
    } else {
      throw new Error('Invalid SJIS character: ' + this.data[i] + '\n' + 'Make sure your charset is UTF-8');
    }
    value = (value >>> 8 & 0xff) * 0xC0 + (value & 0xff);
    bitBuffer.put(value, 13);
  }
};
module.exports = KanjiData;

/***/ }),

/***/ 4491:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Regular-webfont.eot";

/***/ }),

/***/ 4658:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (/* binding */ delimitedIndent),
/* harmony export */   EI: () => (/* binding */ indentString),
/* harmony export */   KB: () => (/* binding */ IndentContext),
/* harmony export */   Lv: () => (/* binding */ foldGutter),
/* harmony export */   Oh: () => (/* binding */ indentNodeProp),
/* harmony export */   Q0: () => (/* binding */ sublanguageProp),
/* harmony export */   Q_: () => (/* binding */ bracketMatchingHandle),
/* harmony export */   TM: () => (/* binding */ Language),
/* harmony export */   Tg: () => (/* binding */ StreamLanguage),
/* harmony export */   Xt: () => (/* binding */ indentUnit),
/* harmony export */   Yy: () => (/* binding */ LanguageSupport),
/* harmony export */   Zt: () => (/* binding */ defaultHighlightStyle),
/* harmony export */   _Y: () => (/* binding */ flatIndent),
/* harmony export */   _v: () => (/* binding */ getIndentation),
/* harmony export */   b_: () => (/* binding */ foldNodeProp),
/* harmony export */   bj: () => (/* binding */ LRLanguage),
/* harmony export */   iB: () => (/* binding */ languageDataProp),
/* harmony export */   jU: () => (/* binding */ matchBrackets),
/* harmony export */   mv: () => (/* binding */ syntaxTree),
/* harmony export */   mz: () => (/* binding */ continuedIndent),
/* harmony export */   nq: () => (/* binding */ ParseContext),
/* harmony export */   p9: () => (/* binding */ defineLanguageFacet),
/* harmony export */   t: () => (/* binding */ foldService),
/* harmony export */   t$: () => (/* binding */ LanguageDescription),
/* harmony export */   tp: () => (/* binding */ getIndentUnit),
/* harmony export */   y9: () => (/* binding */ syntaxHighlighting),
/* harmony export */   yd: () => (/* binding */ foldInside)
/* harmony export */ });
/* unused harmony exports DocInput, HighlightStyle, StringStream, TreeIndentContext, bidiIsolates, bracketMatching, codeFolding, ensureSyntaxTree, foldAll, foldCode, foldEffect, foldKeymap, foldState, foldable, foldedRanges, forceParsing, highlightingFor, indentOnInput, indentRange, indentService, language, syntaxParserRunning, syntaxTreeAvailable, toggleFold, unfoldAll, unfoldCode, unfoldEffect */
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(1001);
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5177);
/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5016);
/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1785);
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }





var _a;
const languageDataProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
function defineLanguageFacet(baseData) {
  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
    combine: baseData ? values => values.concat(baseData) : undefined
  });
}
const sublanguageProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
class Language {
  constructor(data, parser, extraExtensions, name) {
    if (extraExtensions === void 0) {
      extraExtensions = [];
    }
    if (name === void 0) {
      name = "";
    }
    this.data = data;
    this.name = name;
    if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t.prototype.hasOwnProperty("tree")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t.prototype, "tree", {
      get() {
        return syntaxTree(this);
      }
    });
    this.parser = parser;
    this.extension = [language.of(this), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t.languageData.of((state, pos, side) => {
      let top = topNodeAt(state, pos, side),
        data = top.type.prop(languageDataProp);
      if (!data) return [];
      let base = state.facet(data),
        sub = top.type.prop(sublanguageProp);
      if (sub) {
        let innerNode = top.resolve(pos - top.from, side);
        for (var _iterator = _createForOfIteratorHelperLoose(sub), _step; !(_step = _iterator()).done;) {
          let sublang = _step.value;
          if (sublang.test(innerNode, state)) {
            let data = state.facet(sublang.facet);
            return sublang.type == "replace" ? data : data.concat(base);
          }
        }
      }
      return base;
    })].concat(extraExtensions);
  }
  isActiveAt(state, pos, side) {
    if (side === void 0) {
      side = -1;
    }
    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
  }
  findRegions(state) {
    let lang = state.facet(language);
    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{
      from: 0,
      to: state.doc.length
    }];
    if (!lang || !lang.allowsNesting) return [];
    let result = [];
    let explore = (tree, from) => {
      if (tree.prop(languageDataProp) == this.data) {
        result.push({
          from,
          to: from + tree.length
        });
        return;
      }
      let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.mounted);
      if (mount) {
        if (mount.tree.prop(languageDataProp) == this.data) {
          if (mount.overlay) {
            for (var _iterator2 = _createForOfIteratorHelperLoose(mount.overlay), _step2; !(_step2 = _iterator2()).done;) {
              let r = _step2.value;
              result.push({
                from: r.from + from,
                to: r.to + from
              });
            }
          } else result.push({
            from: from,
            to: from + tree.length
          });
          return;
        } else if (mount.overlay) {
          let size = result.length;
          explore(mount.tree, mount.overlay[0].from + from);
          if (result.length > size) return;
        }
      }
      for (let i = 0; i < tree.children.length; i++) {
        let ch = tree.children[i];
        if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH) explore(ch, tree.positions[i] + from);
      }
    };
    explore(syntaxTree(state), 0);
    return result;
  }
  get allowsNesting() {
    return true;
  }
}
Language.setState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.define();
function topNodeAt(state, pos, side) {
  let topLang = state.facet(language),
    tree = syntaxTree(state).topNode;
  if (!topLang || topLang.allowsNesting) {
    for (let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .IterMode */ .Qj.ExcludeBuffers)) if (node.type.isTop) tree = node;
  }
  return tree;
}
class LRLanguage extends Language {
  constructor(data, parser, name) {
    super(data, parser, [], name);
    this.parser = parser;
  }
  static define(spec) {
    let data = defineLanguageFacet(spec.languageData);
    return new LRLanguage(data, spec.parser.configure({
      props: [languageDataProp.add(type => type.isTop ? data : undefined)]
    }), spec.name);
  }
  configure(options, name) {
    return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function syntaxTree(state) {
  let field = state.field(Language.state, false);
  return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty;
}
function ensureSyntaxTree(state, upto, timeout) {
  if (timeout === void 0) {
    timeout = 50;
  }
  var _a;
  let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
  if (!parse) return null;
  let oldVieport = parse.viewport;
  parse.updateViewport({
    from: 0,
    to: upto
  });
  let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
  parse.updateViewport(oldVieport);
  return result;
}
function syntaxTreeAvailable(state, upto) {
  if (upto === void 0) {
    upto = state.doc.length;
  }
  var _a;
  return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;
}
function forceParsing(view, upto, timeout) {
  if (upto === void 0) {
    upto = view.viewport.to;
  }
  if (timeout === void 0) {
    timeout = 100;
  }
  let success = ensureSyntaxTree(view.state, upto, timeout);
  if (success != syntaxTree(view.state)) view.dispatch({});
  return !!success;
}
function syntaxParserRunning(view) {
  var _a;
  return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;
}
class DocInput {
  constructor(doc) {
    this.doc = doc;
    this.cursorPos = 0;
    this.string = "";
    this.cursor = doc.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(pos) {
    this.string = this.cursor.next(pos - this.cursorPos).value;
    this.cursorPos = pos + this.string.length;
    return this.cursorPos - this.string.length;
  }
  chunk(pos) {
    this.syncTo(pos);
    return this.string;
  }
  get lineChunks() {
    return true;
  }
  read(from, to) {
    let stringStart = this.cursorPos - this.string.length;
    if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);else return this.string.slice(from - stringStart, to - stringStart);
  }
}
let currentContext = null;
class ParseContext {
  constructor(parser, state, fragments, tree, treeLen, viewport, skipped, scheduleOn) {
    if (fragments === void 0) {
      fragments = [];
    }
    this.parser = parser;
    this.state = state;
    this.fragments = fragments;
    this.tree = tree;
    this.treeLen = treeLen;
    this.viewport = viewport;
    this.skipped = skipped;
    this.scheduleOn = scheduleOn;
    this.parse = null;
    this.tempSkipped = [];
  }
  static create(parser, state, viewport) {
    return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty, 0, viewport, [], null);
  }
  startParse() {
    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
  }
  work(until, upto) {
    if (upto != null && upto >= this.state.doc.length) upto = undefined;
    if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
      this.takeTree();
      return true;
    }
    return this.withContext(() => {
      var _a;
      if (typeof until == "number") {
        let endTime = Date.now() + until;
        until = () => Date.now() > endTime;
      }
      if (!this.parse) this.parse = this.startParse();
      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);
      for (;;) {
        let done = this.parse.advance();
        if (done) {
          this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.addTree(done, this.fragments, this.parse.stoppedAt != null));
          this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
          this.tree = done;
          this.parse = null;
          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();else return true;
        }
        if (until()) return false;
      }
    });
  }
  takeTree() {
    let pos, tree;
    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);
      this.withContext(() => {
        while (!(tree = this.parse.advance())) {}
      });
      this.treeLen = pos;
      this.tree = tree;
      this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.addTree(this.tree, this.fragments, true));
      this.parse = null;
    }
  }
  withContext(f) {
    let prev = currentContext;
    currentContext = this;
    try {
      return f();
    } finally {
      currentContext = prev;
    }
  }
  withoutTempSkipped(fragments) {
    for (let r; r = this.tempSkipped.pop();) fragments = cutFragments(fragments, r.from, r.to);
    return fragments;
  }
  changes(changes, newState) {
    let {
      fragments,
      tree,
      treeLen,
      viewport,
      skipped
    } = this;
    this.takeTree();
    if (!changes.empty) {
      let ranges = [];
      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({
        fromA,
        toA,
        fromB,
        toB
      }));
      fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.applyChanges(fragments, ranges);
      tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty;
      treeLen = 0;
      viewport = {
        from: changes.mapPos(viewport.from, -1),
        to: changes.mapPos(viewport.to, 1)
      };
      if (this.skipped.length) {
        skipped = [];
        for (var _iterator3 = _createForOfIteratorHelperLoose(this.skipped), _step3; !(_step3 = _iterator3()).done;) {
          let r = _step3.value;
          let from = changes.mapPos(r.from, 1),
            to = changes.mapPos(r.to, -1);
          if (from < to) skipped.push({
            from,
            to
          });
        }
      }
    }
    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
  }
  updateViewport(viewport) {
    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;
    this.viewport = viewport;
    let startLen = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let {
        from,
        to
      } = this.skipped[i];
      if (from < viewport.to && to > viewport.from) {
        this.fragments = cutFragments(this.fragments, from, to);
        this.skipped.splice(i--, 1);
      }
    }
    if (this.skipped.length >= startLen) return false;
    this.reset();
    return true;
  }
  reset() {
    if (this.parse) {
      this.takeTree();
      this.parse = null;
    }
  }
  skipUntilInView(from, to) {
    this.skipped.push({
      from,
      to
    });
  }
  static getSkippingParser(until) {
    return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Parser */ .iX {
      createParse(input, fragments, ranges) {
        let from = ranges[0].from,
          to = ranges[ranges.length - 1].to;
        let parser = {
          parsedPos: from,
          advance() {
            let cx = currentContext;
            if (cx) {
              for (var _iterator4 = _createForOfIteratorHelperLoose(ranges), _step4; !(_step4 = _iterator4()).done;) {
                let r = _step4.value;
                cx.tempSkipped.push(r);
              }
              if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
            }
            this.parsedPos = to;
            return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.none, [], [], to - from);
          },
          stoppedAt: null,
          stopAt() {}
        };
        return parser;
      }
    }();
  }
  isDone(upto) {
    upto = Math.min(upto, this.state.doc.length);
    let frags = this.fragments;
    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
  }
  static get() {
    return currentContext;
  }
}
function cutFragments(fragments, from, to) {
  return _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .TreeFragment */ .rr.applyChanges(fragments, [{
    fromA: from,
    toA: to,
    fromB: from,
    toB: to
  }]);
}
class LanguageState {
  constructor(context) {
    this.context = context;
    this.tree = context.tree;
  }
  apply(tr) {
    if (!tr.docChanged && this.tree == this.context.tree) return this;
    let newCx = this.context.changes(tr.changes, tr.state);
    let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
    if (!newCx.work(20, upto)) newCx.takeTree();
    return new LanguageState(newCx);
  }
  static init(state) {
    let vpTo = Math.min(3000, state.doc.length);
    let parseState = ParseContext.create(state.facet(language).parser, state, {
      from: 0,
      to: vpTo
    });
    if (!parseState.work(20, vpTo)) parseState.takeTree();
    return new LanguageState(parseState);
  }
}
Language.state = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField */ .sU.define({
  create: LanguageState.init,
  update(value, tr) {
    for (var _iterator5 = _createForOfIteratorHelperLoose(tr.effects), _step5; !(_step5 = _iterator5()).done;) {
      let e = _step5.value;
      if (e.is(Language.setState)) return e.value;
    }
    if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);
    return value.apply(tr);
  }
});
let requestIdle = callback => {
  let timeout = setTimeout(() => callback(), 500);
  return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined") requestIdle = callback => {
  let idle = -1,
    timeout = setTimeout(() => {
      idle = requestIdleCallback(callback, {
        timeout: 500 - 100
      });
    }, 100);
  return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
};
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(class ParseWorker {
  constructor(view) {
    this.view = view;
    this.working = null;
    this.workScheduled = 0;
    this.chunkEnd = -1;
    this.chunkBudget = -1;
    this.work = this.work.bind(this);
    this.scheduleWork();
  }
  update(update) {
    let cx = this.view.state.field(Language.state).context;
    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();
    if (update.docChanged || update.selectionSet) {
      if (this.view.hasFocus) this.chunkBudget += 50;
      this.scheduleWork();
    }
    this.checkAsyncSchedule(cx);
  }
  scheduleWork() {
    if (this.working) return;
    let {
        state
      } = this.view,
      field = state.field(Language.state);
    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);
  }
  work(deadline) {
    this.working = null;
    let now = Date.now();
    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {
      this.chunkEnd = now + 30000;
      this.chunkBudget = 3000;
    }
    if (this.chunkBudget <= 0) return;
    let {
        state,
        viewport: {
          to: vpTo
        }
      } = this.view,
      field = state.field(Language.state);
    if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000)) return;
    let endTime = Date.now() + Math.min(this.chunkBudget, 100, deadline && !isInputPending ? Math.max(25, deadline.timeRemaining() - 5) : 1e9);
    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
    let done = field.context.work(() => {
      return isInputPending && isInputPending() || Date.now() > endTime;
    }, vpTo + (viewportFirst ? 0 : 100000));
    this.chunkBudget -= Date.now() - now;
    if (done || this.chunkBudget <= 0) {
      field.context.takeTree();
      this.view.dispatch({
        effects: Language.setState.of(new LanguageState(field.context))
      });
    }
    if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();
    this.checkAsyncSchedule(field.context);
  }
  checkAsyncSchedule(cx) {
    if (cx.scheduleOn) {
      this.workScheduled++;
      cx.scheduleOn.then(() => this.scheduleWork()).catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .logException */ .c_)(this.view.state, err)).then(() => this.workScheduled--);
      cx.scheduleOn = null;
    }
  }
  destroy() {
    if (this.working) this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: {
    focus() {
      this.scheduleWork();
    }
  }
});
const language = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
  combine(languages) {
    return languages.length ? languages[0] : null;
  },
  enables: language => [Language.state, parseWorker, _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.contentAttributes.compute([language], state => {
    let lang = state.facet(language);
    return lang && lang.name ? {
      "data-language": lang.name
    } : {};
  })]
});
class LanguageSupport {
  constructor(language, support) {
    if (support === void 0) {
      support = [];
    }
    this.language = language;
    this.support = support;
    this.extension = [language, support];
  }
}
class LanguageDescription {
  constructor(name, alias, extensions, filename, loadFunc, support) {
    if (support === void 0) {
      support = undefined;
    }
    this.name = name;
    this.alias = alias;
    this.extensions = extensions;
    this.filename = filename;
    this.loadFunc = loadFunc;
    this.support = support;
    this.loading = null;
  }
  load() {
    return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => {
      this.loading = null;
      throw err;
    }));
  }
  static of(spec) {
    let {
      load,
      support
    } = spec;
    if (!load) {
      if (!support) throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
      load = () => Promise.resolve(support);
    }
    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
  }
  static matchFilename(descs, filename) {
    for (var _iterator6 = _createForOfIteratorHelperLoose(descs), _step6; !(_step6 = _iterator6()).done;) {
      let d = _step6.value;
      if (d.filename && d.filename.test(filename)) return d;
    }
    let ext = /\.([^.]+)$/.exec(filename);
    if (ext) {
      for (var _iterator7 = _createForOfIteratorHelperLoose(descs), _step7; !(_step7 = _iterator7()).done;) {
        let d = _step7.value;
        if (d.extensions.indexOf(ext[1]) > -1) return d;
      }
    }
    return null;
  }
  static matchLanguageName(descs, name, fuzzy) {
    if (fuzzy === void 0) {
      fuzzy = true;
    }
    name = name.toLowerCase();
    for (var _iterator8 = _createForOfIteratorHelperLoose(descs), _step8; !(_step8 = _iterator8()).done;) {
      let d = _step8.value;
      if (d.alias.some(a => a == name)) return d;
    }
    if (fuzzy) {
      for (var _iterator9 = _createForOfIteratorHelperLoose(descs), _step9; !(_step9 = _iterator9()).done;) {
        let d = _step9.value;
        for (var _iterator10 = _createForOfIteratorHelperLoose(d.alias), _step10; !(_step10 = _iterator10()).done;) {
          let a = _step10.value;
          let found = name.indexOf(a);
          if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length]))) return d;
        }
      }
    }
    return null;
  }
}
const indentService = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define();
const indentUnit = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
  combine: values => {
    if (!values.length) return "  ";
    let unit = values[0];
    if (!unit || /\S/.test(unit) || Array.from(unit).some(e => e != unit[0])) throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
    return unit;
  }
});
function getIndentUnit(state) {
  let unit = state.facet(indentUnit);
  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
function indentString(state, cols) {
  let result = "",
    ts = state.tabSize,
    ch = state.facet(indentUnit)[0];
  if (ch == "\t") {
    while (cols >= ts) {
      result += "\t";
      cols -= ts;
    }
    ch = " ";
  }
  for (let i = 0; i < cols; i++) result += ch;
  return result;
}
function getIndentation(context, pos) {
  if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .EditorState */ .$t) context = new IndentContext(context);
  for (var _iterator11 = _createForOfIteratorHelperLoose(context.state.facet(indentService)), _step11; !(_step11 = _iterator11()).done;) {
    let service = _step11.value;
    let result = service(context, pos);
    if (result !== undefined) return result;
  }
  let tree = syntaxTree(context.state);
  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
function indentRange(state, from, to) {
  let updated = Object.create(null);
  let context = new IndentContext(state, {
    overrideIndentation: start => {
      var _a;
      return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;
    }
  });
  let changes = [];
  for (let pos = from; pos <= to;) {
    let line = state.doc.lineAt(pos);
    pos = line.to + 1;
    let indent = getIndentation(context, line.from);
    if (indent == null) continue;
    if (!/\S/.test(line.text)) indent = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = indentString(state, indent);
    if (cur != norm) {
      updated[line.from] = indent;
      changes.push({
        from: line.from,
        to: line.from + cur.length,
        insert: norm
      });
    }
  }
  return state.changes(changes);
}
class IndentContext {
  constructor(state, options) {
    if (options === void 0) {
      options = {};
    }
    this.state = state;
    this.options = options;
    this.unit = getIndentUnit(state);
  }
  lineAt(pos, bias) {
    if (bias === void 0) {
      bias = 1;
    }
    let line = this.state.doc.lineAt(pos);
    let {
      simulateBreak,
      simulateDoubleBreak
    } = this.options;
    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
      if (simulateDoubleBreak && simulateBreak == pos) return {
        text: "",
        from: pos
      };else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {
        text: line.text.slice(simulateBreak - line.from),
        from: simulateBreak
      };else return {
        text: line.text.slice(0, simulateBreak - line.from),
        from: line.from
      };
    }
    return line;
  }
  textAfterPos(pos, bias) {
    if (bias === void 0) {
      bias = 1;
    }
    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return "";
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
  }
  column(pos, bias) {
    if (bias === void 0) {
      bias = 1;
    }
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    let result = this.countColumn(text, pos - from);
    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
    if (override > -1) result += override - this.countColumn(text, text.search(/\S|$/));
    return result;
  }
  countColumn(line, pos) {
    if (pos === void 0) {
      pos = line.length;
    }
    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .countColumn */ .y$)(line, this.state.tabSize, pos);
  }
  lineIndent(pos, bias) {
    if (bias === void 0) {
      bias = 1;
    }
    let {
      text,
      from
    } = this.lineAt(pos, bias);
    let override = this.options.overrideIndentation;
    if (override) {
      let overriden = override(from);
      if (overriden > -1) return overriden;
    }
    return this.countColumn(text, text.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const indentNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
function syntaxIndentation(cx, ast, pos) {
  let stack = ast.resolveStack(pos);
  let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);
  if (inner != stack.node) {
    let add = [];
    for (let cur = inner; cur && !(cur.from == stack.node.from && cur.type == stack.node.type); cur = cur.parent) add.push(cur);
    for (let i = add.length - 1; i >= 0; i--) stack = {
      node: add[i],
      next: stack
    };
  }
  return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
  for (let cur = stack; cur; cur = cur.next) {
    let strategy = indentStrategy(cur.node);
    if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));
  }
  return 0;
}
function ignoreClosed(cx) {
  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
  let strategy = tree.type.prop(indentNodeProp);
  if (strategy) return strategy;
  let first = tree.firstChild,
    close;
  if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.closedBy))) {
    let last = tree.lastChild,
      closed = last && close.indexOf(last.name) > -1;
    return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
  }
  return tree.parent == null ? topIndent : null;
}
function topIndent() {
  return 0;
}
class TreeIndentContext extends IndentContext {
  constructor(base, pos, context) {
    super(base.state, base.options);
    this.base = base;
    this.pos = pos;
    this.context = context;
  }
  get node() {
    return this.context.node;
  }
  static create(base, pos, context) {
    return new TreeIndentContext(base, pos, context);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  baseIndentFor(node) {
    let line = this.state.doc.lineAt(node.from);
    for (;;) {
      let atBreak = node.resolve(line.from);
      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;
      if (isParent(atBreak, node)) break;
      line = this.state.doc.lineAt(atBreak.from);
    }
    return this.lineIndent(line.from);
  }
  continue() {
    return indentFor(this.context.next, this.base, this.pos);
  }
}
function isParent(parent, of) {
  for (let cur = of; cur; cur = cur.parent) if (parent == cur) return true;
  return false;
}
function bracketedAligned(context) {
  let tree = context.node;
  let openToken = tree.childAfter(tree.from),
    last = tree.lastChild;
  if (!openToken) return null;
  let sim = context.options.simulateBreak;
  let openLine = context.state.doc.lineAt(openToken.from);
  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
  for (let pos = openToken.to;;) {
    let next = tree.childAfter(pos);
    if (!next || next == last) return null;
    if (!next.type.isSkipped) {
      if (next.from >= lineEnd) return null;
      let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;
      return {
        from: openToken.from,
        to: openToken.to + space
      };
    }
    pos = next.to;
  }
}
function delimitedIndent(_ref) {
  let {
    closing,
    align = true,
    units = 1
  } = _ref;
  return context => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
  let after = context.textAfter,
    space = after.match(/^\s*/)[0].length;
  let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
  let aligned = align ? bracketedAligned(context) : null;
  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);
  return context.baseIndent + (closed ? 0 : context.unit * units);
}
const flatIndent = context => context.baseIndent;
function continuedIndent(_temp) {
  let {
    except,
    units = 1
  } = _temp === void 0 ? {} : _temp;
  return context => {
    let matchExcept = except && except.test(context.textAfter);
    return context.baseIndent + (matchExcept ? 0 : units * context.unit);
  };
}
const DontIndentBeyond = 200;
function indentOnInput() {
  return EditorState.transactionFilter.of(tr => {
    if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete")) return tr;
    let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
    if (!rules.length) return tr;
    let doc = tr.newDoc,
      {
        head
      } = tr.newSelection.main,
      line = doc.lineAt(head);
    if (head > line.from + DontIndentBeyond) return tr;
    let lineStart = doc.sliceString(line.from, head);
    if (!rules.some(r => r.test(lineStart))) return tr;
    let {
        state
      } = tr,
      last = -1,
      changes = [];
    for (var _iterator12 = _createForOfIteratorHelperLoose(state.selection.ranges), _step12; !(_step12 = _iterator12()).done;) {
      let {
        head
      } = _step12.value;
      let line = state.doc.lineAt(head);
      if (line.from == last) continue;
      last = line.from;
      let indent = getIndentation(state, line.from);
      if (indent == null) continue;
      let cur = /^\s*/.exec(line.text)[0];
      let norm = indentString(state, indent);
      if (cur != norm) changes.push({
        from: line.from,
        to: line.from + cur.length,
        insert: norm
      });
    }
    return changes.length ? [tr, {
      changes,
      sequential: true
    }] : tr;
  });
}
const foldService = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define();
const foldNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
function foldInside(node) {
  let first = node.firstChild,
    last = node.lastChild;
  return first && first.to < last.from ? {
    from: first.to,
    to: last.type.isError ? node.to : last.from
  } : null;
}
function syntaxFolding(state, start, end) {
  let tree = syntaxTree(state);
  if (tree.length < end) return null;
  let stack = tree.resolveStack(end, 1);
  let found = null;
  for (let iter = stack; iter; iter = iter.next) {
    let cur = iter.node;
    if (cur.to <= end || cur.from > end) continue;
    if (found && cur.from < start) break;
    let prop = cur.type.prop(foldNodeProp);
    if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
      let value = prop(cur, state);
      if (value && value.from <= end && value.from >= start && value.to > end) found = value;
    }
  }
  return found;
}
function isUnfinished(node) {
  let ch = node.lastChild;
  return ch && ch.to == node.to && ch.type.isError;
}
function foldable(state, lineStart, lineEnd) {
  for (var _iterator13 = _createForOfIteratorHelperLoose(state.facet(foldService)), _step13; !(_step13 = _iterator13()).done;) {
    let service = _step13.value;
    let result = service(state, lineStart, lineEnd);
    if (result) return result;
  }
  return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
  let from = mapping.mapPos(range.from, 1),
    to = mapping.mapPos(range.to, -1);
  return from >= to ? undefined : {
    from,
    to
  };
}
const foldEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.define({
  map: mapRange
});
const unfoldEffect = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.define({
  map: mapRange
});
function selectedLines(view) {
  let lines = [];
  for (var _iterator14 = _createForOfIteratorHelperLoose(view.state.selection.ranges), _step14; !(_step14 = _iterator14()).done;) {
    let {
      head
    } = _step14.value;
    if (lines.some(l => l.from <= head && l.to >= head)) continue;
    lines.push(view.lineBlockAt(head));
  }
  return lines;
}
const foldState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField */ .sU.define({
  create() {
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
  },
  update(folded, tr) {
    folded = folded.map(tr.changes);
    for (var _iterator15 = _createForOfIteratorHelperLoose(tr.effects), _step15; !(_step15 = _iterator15()).done;) {
      let e = _step15.value;
      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
        let {
          preparePlaceholder
        } = tr.state.facet(foldConfig);
        let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.replace({
          widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))
        });
        folded = folded.update({
          add: [widget.range(e.value.from, e.value.to)]
        });
      } else if (e.is(unfoldEffect)) {
        folded = folded.update({
          filter: (from, to) => e.value.from != from || e.value.to != to,
          filterFrom: e.value.from,
          filterTo: e.value.to
        });
      }
    }
    if (tr.selection) {
      let onSelection = false,
        {
          head
        } = tr.selection.main;
      folded.between(head, head, (a, b) => {
        if (a < head && b > head) onSelection = true;
      });
      if (onSelection) folded = folded.update({
        filterFrom: head,
        filterTo: head,
        filter: (a, b) => b <= head || a >= head
      });
    }
    return folded;
  },
  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.decorations.from(f),
  toJSON(folded, state) {
    let ranges = [];
    folded.between(0, state.doc.length, (from, to) => {
      ranges.push(from, to);
    });
    return ranges;
  },
  fromJSON(value) {
    if (!Array.isArray(value) || value.length % 2) throw new RangeError("Invalid JSON for fold state");
    let ranges = [];
    for (let i = 0; i < value.length;) {
      let from = value[i++],
        to = value[i++];
      if (typeof from != "number" || typeof to != "number") throw new RangeError("Invalid JSON for fold state");
      ranges.push(foldWidget.range(from, to));
    }
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.set(ranges, true);
  }
});
function foldedRanges(state) {
  return state.field(foldState, false) || RangeSet.empty;
}
function findFold(state, from, to) {
  var _a;
  let found = null;
  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
    if (!found || found.from > from) found = {
      from,
      to
    };
  });
  return found;
}
function foldExists(folded, from, to) {
  let found = false;
  folded.between(from, from, (a, b) => {
    if (a == from && b == to) found = true;
  });
  return found;
}
function maybeEnable(state, other) {
  return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateEffect */ .Pe.appendConfig.of(codeFolding()));
}
const foldCode = view => {
  for (var _iterator16 = _createForOfIteratorHelperLoose(selectedLines(view)), _step16; !(_step16 = _iterator16()).done;) {
    let line = _step16.value;
    let range = foldable(view.state, line.from, line.to);
    if (range) {
      view.dispatch({
        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])
      });
      return true;
    }
  }
  return false;
};
const unfoldCode = view => {
  if (!view.state.field(foldState, false)) return false;
  let effects = [];
  for (var _iterator17 = _createForOfIteratorHelperLoose(selectedLines(view)), _step17; !(_step17 = _iterator17()).done;) {
    let line = _step17.value;
    let folded = findFold(view.state, line.from, line.to);
    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
  }
  if (effects.length) view.dispatch({
    effects
  });
  return effects.length > 0;
};
function announceFold(view, range, fold) {
  if (fold === void 0) {
    fold = true;
  }
  let lineFrom = view.state.doc.lineAt(range.from).number,
    lineTo = view.state.doc.lineAt(range.to).number;
  return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
const foldAll = view => {
  let {
      state
    } = view,
    effects = [];
  for (let pos = 0; pos < state.doc.length;) {
    let line = view.lineBlockAt(pos),
      range = foldable(state, line.from, line.to);
    if (range) effects.push(foldEffect.of(range));
    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
  }
  if (effects.length) view.dispatch({
    effects: maybeEnable(view.state, effects)
  });
  return !!effects.length;
};
const unfoldAll = view => {
  let field = view.state.field(foldState, false);
  if (!field || !field.size) return false;
  let effects = [];
  field.between(0, view.state.doc.length, (from, to) => {
    effects.push(unfoldEffect.of({
      from,
      to
    }));
  });
  view.dispatch({
    effects
  });
  return true;
};
function foldableContainer(view, lineBlock) {
  for (let line = lineBlock;;) {
    let foldableRegion = foldable(view.state, line.from, line.to);
    if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;
    if (!line.from) return null;
    line = view.lineBlockAt(line.from - 1);
  }
}
const toggleFold = view => {
  let effects = [];
  for (var _iterator18 = _createForOfIteratorHelperLoose(selectedLines(view)), _step18; !(_step18 = _iterator18()).done;) {
    let line = _step18.value;
    let folded = findFold(view.state, line.from, line.to);
    if (folded) {
      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    } else {
      let foldRange = foldableContainer(view, line);
      if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));
    }
  }
  if (effects.length > 0) view.dispatch({
    effects: maybeEnable(view.state, effects)
  });
  return !!effects.length;
};
const foldKeymap = [{
  key: "Ctrl-Shift-[",
  mac: "Cmd-Alt-[",
  run: foldCode
}, {
  key: "Ctrl-Shift-]",
  mac: "Cmd-Alt-]",
  run: unfoldCode
}, {
  key: "Ctrl-Alt-[",
  run: foldAll
}, {
  key: "Ctrl-Alt-]",
  run: unfoldAll
}];
const defaultConfig = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: "…"
};
const foldConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
  combine(values) {
    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .combineConfig */ .QR)(values, defaultConfig);
  }
});
function codeFolding(config) {
  let result = [foldState, baseTheme$1];
  if (config) result.push(foldConfig.of(config));
  return result;
}
function widgetToDOM(view, prepared) {
  let {
      state
    } = view,
    conf = state.facet(foldConfig);
  let onclick = event => {
    let line = view.lineBlockAt(view.posAtDOM(event.target));
    let folded = findFold(view.state, line.from, line.to);
    if (folded) view.dispatch({
      effects: unfoldEffect.of(folded)
    });
    event.preventDefault();
  };
  if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);
  let element = document.createElement("span");
  element.textContent = conf.placeholderText;
  element.setAttribute("aria-label", state.phrase("folded code"));
  element.title = state.phrase("unfold");
  element.className = "cm-foldPlaceholder";
  element.onclick = onclick;
  return element;
}
const foldWidget = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.replace({
  widget: new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .WidgetType */ .xO {
    toDOM(view) {
      return widgetToDOM(view, null);
    }
  }()
});
class PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .WidgetType */ .xO {
  constructor(value) {
    super();
    this.value = value;
  }
  eq(other) {
    return this.value == other.value;
  }
  toDOM(view) {
    return widgetToDOM(view, this.value);
  }
}
const foldGutterDefaults = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => false
};
class FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .GutterMarker */ .wJ {
  constructor(config, open) {
    super();
    this.config = config;
    this.open = open;
  }
  eq(other) {
    return this.config == other.config && this.open == other.open;
  }
  toDOM(view) {
    if (this.config.markerDOM) return this.config.markerDOM(this.open);
    let span = document.createElement("span");
    span.textContent = this.open ? this.config.openText : this.config.closedText;
    span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
    return span;
  }
}
function foldGutter(config) {
  if (config === void 0) {
    config = {};
  }
  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
  let canFold = new FoldMarker(fullConfig, true),
    canUnfold = new FoldMarker(fullConfig, false);
  let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(class {
    constructor(view) {
      this.from = view.viewport.from;
      this.markers = this.buildMarkers(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);
    }
    buildMarkers(view) {
      let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSetBuilder */ .vB();
      for (var _iterator19 = _createForOfIteratorHelperLoose(view.viewportLineBlocks), _step19; !(_step19 = _iterator19()).done;) {
        let line = _step19.value;
        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;
        if (mark) builder.add(line.from, line.from, mark);
      }
      return builder.finish();
    }
  });
  let {
    domEventHandlers
  } = fullConfig;
  return [markers, (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .gutter */ .cU)({
    class: "cm-foldGutter",
    markers(view) {
      var _a;
      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSet */ .om.empty;
    },
    initialSpacer() {
      return new FoldMarker(fullConfig, false);
    },
    domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {
      click: (view, line, event) => {
        if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
          view.dispatch({
            effects: unfoldEffect.of(folded)
          });
          return true;
        }
        let range = foldable(view.state, line.from, line.to);
        if (range) {
          view.dispatch({
            effects: foldEffect.of(range)
          });
          return true;
        }
        return false;
      }
    })
  }), codeFolding()];
}
const baseTheme$1 = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class HighlightStyle {
  constructor(specs, options) {
    this.specs = specs;
    let modSpec;
    function def(spec) {
      let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__/* .StyleModule */ .G.newName();
      (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
      return cls;
    }
    const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
    const scopeOpt = options.scope;
    this.scope = scopeOpt instanceof Language ? type => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? type => type == scopeOpt : undefined;
    this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tagHighlighter */ .az)(specs.map(style => ({
      tag: style.tag,
      class: style.class || def(Object.assign({}, style, {
        tag: null
      }))
    })), {
      all
    }).style;
    this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__/* .StyleModule */ .G(modSpec) : null;
    this.themeType = options.themeType;
  }
  static define(specs, options) {
    return new HighlightStyle(specs, options || {});
  }
}
const highlighterFacet = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define();
const fallbackHighlighter = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
  combine(values) {
    return values.length ? [values[0]] : null;
  }
});
function getHighlighters(state) {
  let main = state.facet(highlighterFacet);
  return main.length ? main : state.facet(fallbackHighlighter);
}
function syntaxHighlighting(highlighter, options) {
  let ext = [treeHighlighter],
    themeType;
  if (highlighter instanceof HighlightStyle) {
    if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.styleModule.of(highlighter.module));
    themeType = highlighter.themeType;
  }
  if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));else if (themeType) ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.darkTheme], state => {
    return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.darkTheme) == (themeType == "dark") ? [highlighter] : [];
  }));else ext.push(highlighterFacet.of(highlighter));
  return ext;
}
function highlightingFor(state, tags, scope) {
  let highlighters = getHighlighters(state);
  let result = null;
  if (highlighters) {
    for (var _iterator20 = _createForOfIteratorHelperLoose(highlighters), _step20; !(_step20 = _iterator20()).done;) {
      let highlighter = _step20.value;
      if (!highlighter.scope || scope && highlighter.scope(scope)) {
        let cls = highlighter.style(tags);
        if (cls) result = result ? result + " " + cls : cls;
      }
    }
  }
  return result;
}
class TreeHighlighter {
  constructor(view) {
    this.markCache = Object.create(null);
    this.tree = syntaxTree(view.state);
    this.decorations = this.buildDeco(view, getHighlighters(view.state));
    this.decoratedTo = view.viewport.to;
  }
  update(update) {
    let tree = syntaxTree(update.state),
      highlighters = getHighlighters(update.state);
    let styleChange = highlighters != getHighlighters(update.startState);
    let {
        viewport
      } = update.view,
      decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);
    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {
      this.decorations = this.decorations.map(update.changes);
      this.decoratedTo = decoratedToMapped;
    } else if (tree != this.tree || update.viewportChanged || styleChange) {
      this.tree = tree;
      this.decorations = this.buildDeco(update.view, highlighters);
      this.decoratedTo = viewport.to;
    }
  }
  buildDeco(view, highlighters) {
    if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
    let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSetBuilder */ .vB();
    for (var _iterator21 = _createForOfIteratorHelperLoose(view.visibleRanges), _step21; !(_step21 = _iterator21()).done;) {
      let {
        from,
        to
      } = _step21.value;
      (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .highlightTree */ .DM)(this.tree, highlighters, (from, to, style) => {
        builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({
          class: style
        })));
      }, from, to);
    }
    return builder.finish();
  }
}
const treeHighlighter = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Prec */ .Nb.high(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(TreeHighlighter, {
  decorations: v => v.decorations
}));
const defaultHighlightStyle = HighlightStyle.define([{
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.meta,
  color: "#404740"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.link,
  textDecoration: "underline"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.heading,
  textDecoration: "underline",
  fontWeight: "bold"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.emphasis,
  fontStyle: "italic"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.strong,
  fontWeight: "bold"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.strikethrough,
  textDecoration: "line-through"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.keyword,
  color: "#708"
}, {
  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.labelName],
  color: "#219"
}, {
  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.inserted],
  color: "#164"
}, {
  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.deleted],
  color: "#a11"
}, {
  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.escape, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.string)],
  color: "#e40"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.variableName),
  color: "#00f"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.variableName),
  color: "#30a"
}, {
  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.namespace],
  color: "#085"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.className,
  color: "#167"
}, {
  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.macroName],
  color: "#256"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.propertyName),
  color: "#00c"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.comment,
  color: "#940"
}, {
  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A.invalid,
  color: "#f00"
}]);
const baseTheme = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.baseTheme({
  "&.cm-focused .cm-matchingBracket": {
    backgroundColor: "#328c8252"
  },
  "&.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bb555544"
  }
});
const DefaultScanDist = 10000,
  DefaultBrackets = "()[]{}";
const bracketMatchingConfig = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
  combine(configs) {
    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .combineConfig */ .QR)(configs, {
      afterCursor: true,
      brackets: DefaultBrackets,
      maxScanDistance: DefaultScanDist,
      renderMatch: defaultRenderMatch
    });
  }
});
const matchingMark = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({
    class: "cm-matchingBracket"
  }),
  nonmatchingMark = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({
    class: "cm-nonmatchingBracket"
  });
function defaultRenderMatch(match) {
  let decorations = [];
  let mark = match.matched ? matchingMark : nonmatchingMark;
  decorations.push(mark.range(match.start.from, match.start.to));
  if (match.end) decorations.push(mark.range(match.end.from, match.end.to));
  return decorations;
}
const bracketMatchingState = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .StateField */ .sU.define({
  create() {
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
  },
  update(deco, tr) {
    if (!tr.docChanged && !tr.selection) return deco;
    let decorations = [];
    let config = tr.state.facet(bracketMatchingConfig);
    for (var _iterator22 = _createForOfIteratorHelperLoose(tr.state.selection.ranges), _step22; !(_step22 = _iterator22()).done;) {
      let range = _step22.value;
      if (!range.empty) continue;
      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));
      if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));
    }
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.set(decorations, true);
  },
  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.decorations.from(f)
});
const bracketMatchingUnique = [bracketMatchingState, baseTheme];
function bracketMatching(config) {
  if (config === void 0) {
    config = {};
  }
  return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}
const bracketMatchingHandle = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
function matchingNodes(node, dir, brackets) {
  let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.closedBy);
  if (byProp) return byProp;
  if (node.name.length == 1) {
    let index = brackets.indexOf(node.name);
    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];
  }
  return null;
}
function findHandle(node) {
  let hasHandle = node.type.prop(bracketMatchingHandle);
  return hasHandle ? hasHandle(node.node) : node;
}
function matchBrackets(state, pos, dir, config) {
  if (config === void 0) {
    config = {};
  }
  let maxScanDistance = config.maxScanDistance || DefaultScanDist,
    brackets = config.brackets || DefaultBrackets;
  let tree = syntaxTree(state),
    node = tree.resolveInner(pos, dir);
  for (let cur = node; cur; cur = cur.parent) {
    let matches = matchingNodes(cur.type, dir, brackets);
    if (matches && cur.from < cur.to) {
      let handle = findHandle(cur);
      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
    }
  }
  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
  let parent = token.parent,
    firstToken = {
      from: handle.from,
      to: handle.to
    };
  let depth = 0,
    cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {
    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
      if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
        let endHandle = findHandle(cursor);
        return {
          start: firstToken,
          end: endHandle ? {
            from: endHandle.from,
            to: endHandle.to
          } : undefined,
          matched: true
        };
      } else if (matchingNodes(cursor.type, dir, brackets)) {
        depth++;
      } else if (matchingNodes(cursor.type, -dir, brackets)) {
        if (depth == 0) {
          let endHandle = findHandle(cursor);
          return {
            start: firstToken,
            end: endHandle && endHandle.from < endHandle.to ? {
              from: endHandle.from,
              to: endHandle.to
            } : undefined,
            matched: false
          };
        }
        depth--;
      }
    }
  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
  return {
    start: firstToken,
    matched: false
  };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
  let bracket = brackets.indexOf(startCh);
  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;
  let startToken = {
    from: dir < 0 ? pos - 1 : pos,
    to: dir > 0 ? pos + 1 : pos
  };
  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),
    depth = 0;
  for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {
    let text = iter.value;
    if (dir < 0) distance += text.length;
    let basePos = pos + distance * dir;
    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
      let found = brackets.indexOf(text[pos]);
      if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;
      if (found % 2 == 0 == dir > 0) {
        depth++;
      } else if (depth == 1) {
        return {
          start: startToken,
          end: {
            from: basePos + pos,
            to: basePos + pos + 1
          },
          matched: found >> 1 == bracket >> 1
        };
      } else {
        depth--;
      }
    }
    if (dir > 0) distance += text.length;
  }
  return iter.done ? {
    start: startToken,
    matched: false
  } : null;
}
function countCol(string, end, tabSize, startIndex, startValue) {
  if (startIndex === void 0) {
    startIndex = 0;
  }
  if (startValue === void 0) {
    startValue = 0;
  }
  if (end == null) {
    end = string.search(/[^\s\u00a0]/);
    if (end == -1) end = string.length;
  }
  let n = startValue;
  for (let i = startIndex; i < end; i++) {
    if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;else n++;
  }
  return n;
}
class StringStream {
  constructor(string, tabSize, indentUnit, overrideIndent) {
    this.string = string;
    this.tabSize = tabSize;
    this.indentUnit = indentUnit;
    this.overrideIndent = overrideIndent;
    this.pos = 0;
    this.start = 0;
    this.lastColumnPos = 0;
    this.lastColumnValue = 0;
  }
  eol() {
    return this.pos >= this.string.length;
  }
  sol() {
    return this.pos == 0;
  }
  peek() {
    return this.string.charAt(this.pos) || undefined;
  }
  next() {
    if (this.pos < this.string.length) return this.string.charAt(this.pos++);
  }
  eat(match) {
    let ch = this.string.charAt(this.pos);
    let ok;
    if (typeof match == "string") ok = ch == match;else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
    if (ok) {
      ++this.pos;
      return ch;
    }
  }
  eatWhile(match) {
    let start = this.pos;
    while (this.eat(match)) {}
    return this.pos > start;
  }
  eatSpace() {
    let start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
    return this.pos > start;
  }
  skipToEnd() {
    this.pos = this.string.length;
  }
  skipTo(ch) {
    let found = this.string.indexOf(ch, this.pos);
    if (found > -1) {
      this.pos = found;
      return true;
    }
  }
  backUp(n) {
    this.pos -= n;
  }
  column() {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue;
  }
  indentation() {
    var _a;
    return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);
  }
  match(pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      let cased = str => caseInsensitive ? str.toLowerCase() : str;
      let substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) this.pos += pattern.length;
        return true;
      } else return null;
    } else {
      let match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) return null;
      if (match && consume !== false) this.pos += match[0].length;
      return match;
    }
  }
  current() {
    return this.string.slice(this.start, this.pos);
  }
}
function fullParser(spec) {
  return {
    name: spec.name || "",
    token: spec.token,
    blankLine: spec.blankLine || (() => {}),
    startState: spec.startState || (() => true),
    copyState: spec.copyState || defaultCopyState,
    indent: spec.indent || (() => null),
    languageData: spec.languageData || {},
    tokenTable: spec.tokenTable || noTokens
  };
}
function defaultCopyState(state) {
  if (typeof state != "object") return state;
  let newState = {};
  for (let prop in state) {
    let val = state[prop];
    newState[prop] = val instanceof Array ? val.slice() : val;
  }
  return newState;
}
const IndentedFrom = new WeakMap();
class StreamLanguage extends Language {
  constructor(parser) {
    let data = defineLanguageFacet(parser.languageData);
    let p = fullParser(parser),
      self;
    let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Parser */ .iX {
      createParse(input, fragments, ranges) {
        return new Parse(self, input, fragments, ranges);
      }
    }();
    super(data, impl, [], parser.name);
    this.topNode = docID(data, this);
    self = this;
    this.streamParser = p;
    this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY({
      perNode: true
    });
    this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
  }
  static define(spec) {
    return new StreamLanguage(spec);
  }
  getIndent(cx) {
    let from = undefined;
    let {
      overrideIndentation
    } = cx.options;
    if (overrideIndentation) {
      from = IndentedFrom.get(cx.state);
      if (from != null && from < cx.pos - 1e4) from = undefined;
    }
    let start = findState(this, cx.node.tree, cx.node.from, cx.node.from, from !== null && from !== void 0 ? from : cx.pos),
      statePos,
      state;
    if (start) {
      state = start.state;
      statePos = start.pos + 1;
    } else {
      state = this.streamParser.startState(cx.unit);
      statePos = cx.node.from;
    }
    if (cx.pos - statePos > 10000) return null;
    while (statePos < cx.pos) {
      let line = cx.state.doc.lineAt(statePos),
        end = Math.min(cx.pos, line.to);
      if (line.length) {
        let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;
        let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);
        while (stream.pos < end - line.from) readToken(this.streamParser.token, stream, state);
      } else {
        this.streamParser.blankLine(state, cx.unit);
      }
      if (end == cx.pos) break;
      statePos = line.to + 1;
    }
    let line = cx.lineAt(cx.pos);
    if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);
    return this.streamParser.indent(state, /^\s*(.*)/.exec(line.text)[1], cx);
  }
  get allowsNesting() {
    return false;
  }
}
function findState(lang, tree, off, startPos, before) {
  let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
  if (state) return {
    state: lang.streamParser.copyState(state),
    pos: off + tree.length
  };
  for (let i = tree.children.length - 1; i >= 0; i--) {
    let child = tree.children[i],
      pos = off + tree.positions[i];
    let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH && pos < before && findState(lang, child, pos, startPos, before);
    if (found) return found;
  }
  return null;
}
function cutTree(lang, tree, from, to, inside) {
  if (inside && from <= 0 && to >= tree.length) return tree;
  if (!inside && from == 0 && tree.type == lang.topNode) inside = true;
  for (let i = tree.children.length - 1; i >= 0; i--) {
    let pos = tree.positions[i],
      child = tree.children[i],
      inner;
    if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH) {
      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;
      return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
    }
  }
  return null;
}
function findStartInFragments(lang, fragments, startPos, endPos, editorState) {
  for (var _iterator23 = _createForOfIteratorHelperLoose(fragments), _step23; !(_step23 = _iterator23()).done;) {
    let f = _step23.value;
    let from = f.from + (f.openStart ? 25 : 0),
      to = f.to - (f.openEnd ? 25 : 0);
    let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to),
      tree;
    if (found && found.pos <= endPos && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {
      state: found.state,
      tree
    };
  }
  return {
    state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),
    tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.empty
  };
}
class Parse {
  constructor(lang, input, fragments, ranges) {
    this.lang = lang;
    this.input = input;
    this.fragments = fragments;
    this.ranges = ranges;
    this.stoppedAt = null;
    this.chunks = [];
    this.chunkPos = [];
    this.chunk = [];
    this.chunkReused = undefined;
    this.rangeIndex = 0;
    this.to = ranges[ranges.length - 1].to;
    let context = ParseContext.get(),
      from = ranges[0].from;
    let {
      state,
      tree
    } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);
    this.state = state;
    this.parsedPos = this.chunkStart = from + tree.length;
    for (let i = 0; i < tree.children.length; i++) {
      this.chunks.push(tree.children[i]);
      this.chunkPos.push(tree.positions[i]);
    }
    if (context && this.parsedPos < context.viewport.from - 100000 && ranges.some(r => r.from <= context.viewport.from && r.to >= context.viewport.from)) {
      this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
      context.skipUntilInView(this.parsedPos, context.viewport.from);
      this.parsedPos = context.viewport.from;
    }
    this.moveRangeIndex();
  }
  advance() {
    let context = ParseContext.get();
    let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
    let end = Math.min(parseEnd, this.chunkStart + 2048);
    if (context) end = Math.min(end, context.viewport.to);
    while (this.parsedPos < end) this.parseLine(context);
    if (this.chunkStart < this.parsedPos) this.finishChunk();
    if (this.parsedPos >= parseEnd) return this.finish();
    if (context && this.parsedPos >= context.viewport.to) {
      context.skipUntilInView(this.parsedPos, parseEnd);
      return this.finish();
    }
    return null;
  }
  stopAt(pos) {
    this.stoppedAt = pos;
  }
  lineAfter(pos) {
    let chunk = this.input.chunk(pos);
    if (!this.input.lineChunks) {
      let eol = chunk.indexOf("\n");
      if (eol > -1) chunk = chunk.slice(0, eol);
    } else if (chunk == "\n") {
      chunk = "";
    }
    return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
  }
  nextLine() {
    let from = this.parsedPos,
      line = this.lineAfter(from),
      end = from + line.length;
    for (let index = this.rangeIndex;;) {
      let rangeEnd = this.ranges[index].to;
      if (rangeEnd >= end) break;
      line = line.slice(0, rangeEnd - (end - line.length));
      index++;
      if (index == this.ranges.length) break;
      let rangeStart = this.ranges[index].from;
      let after = this.lineAfter(rangeStart);
      line += after;
      end = rangeStart + after.length;
    }
    return {
      line,
      end
    };
  }
  skipGapsTo(pos, offset, side) {
    for (;;) {
      let end = this.ranges[this.rangeIndex].to,
        offPos = pos + offset;
      if (side > 0 ? end > offPos : end >= offPos) break;
      let start = this.ranges[++this.rangeIndex].from;
      offset += start - end;
    }
    return offset;
  }
  moveRangeIndex() {
    while (this.ranges[this.rangeIndex].to < this.parsedPos) this.rangeIndex++;
  }
  emitToken(id, from, to, offset) {
    let size = 4;
    if (this.ranges.length > 1) {
      offset = this.skipGapsTo(from, offset, 1);
      from += offset;
      let len0 = this.chunk.length;
      offset = this.skipGapsTo(to, offset, -1);
      to += offset;
      size += this.chunk.length - len0;
    }
    let last = this.chunk.length - 4;
    if (size == 4 && last >= 0 && this.chunk[last] == id && this.chunk[last + 2] == from) this.chunk[last + 2] = to;else this.chunk.push(id, from, to, size);
    return offset;
  }
  parseLine(context) {
    let {
        line,
        end
      } = this.nextLine(),
      offset = 0,
      {
        streamParser
      } = this.lang;
    let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
    if (stream.eol()) {
      streamParser.blankLine(this.state, stream.indentUnit);
    } else {
      while (!stream.eol()) {
        let token = readToken(streamParser.token, stream, this.state);
        if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);
        if (stream.start > 10000) break;
      }
    }
    this.parsedPos = end;
    this.moveRangeIndex();
    if (this.parsedPos < this.to) this.parsedPos++;
  }
  finishChunk() {
    let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH.build({
      buffer: this.chunk,
      start: this.chunkStart,
      length: this.parsedPos - this.chunkStart,
      nodeSet,
      topID: 0,
      maxBufferLength: 2048,
      reused: this.chunkReused
    });
    tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
    this.chunks.push(tree);
    this.chunkPos.push(this.chunkStart - this.ranges[0].from);
    this.chunk = [];
    this.chunkReused = undefined;
    this.chunkStart = this.parsedPos;
  }
  finish() {
    return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .Tree */ .PH(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
  }
}
function readToken(token, stream, state) {
  stream.start = stream.pos;
  for (let i = 0; i < 10; i++) {
    let result = token(stream, state);
    if (stream.pos > stream.start) return result;
  }
  throw new Error("Stream parser failed to advance stream.");
}
const noTokens = Object.create(null);
const typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.none];
const nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeSet */ .fI(typeArray);
const warned = [];
const byTag = Object.create(null);
const defaultTable = Object.create(null);
for (var _i = 0, _arr = [["variable", "variableName"], ["variable-2", "variableName.special"], ["string-2", "string.special"], ["def", "variableName.definition"], ["tag", "tagName"], ["attribute", "attributeName"], ["type", "typeName"], ["builtin", "variableName.standard"], ["qualifier", "modifier"], ["error", "invalid"], ["header", "heading"], ["property", "propertyName"]]; _i < _arr.length; _i++) {
  let [legacyName, name] = _arr[_i];
  defaultTable[legacyName] = createTokenType(noTokens, name);
}
class TokenTable {
  constructor(extra) {
    this.extra = extra;
    this.table = Object.assign(Object.create(null), defaultTable);
  }
  resolve(tag) {
    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
  }
}
const defaultTokenTable = new TokenTable(noTokens);
function warnForPart(part, msg) {
  if (warned.indexOf(part) > -1) return;
  warned.push(part);
  console.warn(msg);
}
function createTokenType(extra, tagStr) {
  let tags$1 = [];
  for (var _iterator24 = _createForOfIteratorHelperLoose(tagStr.split(" ")), _step24; !(_step24 = _iterator24()).done;) {
    let name = _step24.value;
    let found = [];
    for (var _iterator25 = _createForOfIteratorHelperLoose(name.split(".")), _step25; !(_step25 = _iterator25()).done;) {
      let part = _step25.value;
      let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .tags */ ._A[part];
      if (!value) {
        warnForPart(part, `Unknown highlighting tag ${part}`);
      } else if (typeof value == "function") {
        if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);else found = found.map(value);
      } else {
        if (found.length) warnForPart(part, `Tag ${part} used as modifier`);else found = Array.isArray(value) ? value : [value];
      }
    }
    for (var _iterator26 = _createForOfIteratorHelperLoose(found), _step26; !(_step26 = _iterator26()).done;) {
      let tag = _step26.value;
      tags$1.push(tag);
    }
  }
  if (!tags$1.length) return 0;
  let name = tagStr.replace(/ /g, "_"),
    key = name + " " + tags$1.map(t => t.id);
  let known = byTag[key];
  if (known) return known.id;
  let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.define({
    id: typeArray.length,
    name,
    props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__/* .styleTags */ .pn)({
      [name]: tags$1
    })]
  });
  typeArray.push(type);
  return type.id;
}
function docID(data, lang) {
  let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeType */ .Z6.define({
    id: typeArray.length,
    name: "Document",
    props: [languageDataProp.add(() => data), indentNodeProp.add(() => cx => lang.getIndent(cx))],
    top: true
  });
  typeArray.push(type);
  return type;
}
function buildForLine(line) {
  return line.length <= 4096 && /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/.test(line);
}
function textHasRTL(text) {
  for (let i = text.iter(); !i.next().done;) if (buildForLine(i.value)) return true;
  return false;
}
function changeAddsRTL(change) {
  let added = false;
  change.iterChanges((fA, tA, fB, tB, ins) => {
    if (!added && textHasRTL(ins)) added = true;
  });
  return added;
}
const alwaysIsolate = _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Facet */ .sj.define({
  combine: values => values.some(x => x)
});
function bidiIsolates(options) {
  if (options === void 0) {
    options = {};
  }
  let extensions = [isolateMarks];
  if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));
  return extensions;
}
const isolateMarks = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .ViewPlugin */ .Z9.fromClass(class {
  constructor(view) {
    this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.perLineTextDirection);
    this.hasRTL = !this.always && textHasRTL(view.state.doc);
    this.tree = syntaxTree(view.state);
    this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
  }
  update(update) {
    let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.perLineTextDirection);
    if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;
    if (!always && !this.hasRTL) return;
    let tree = syntaxTree(update.state);
    if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {
      this.tree = tree;
      this.always = always;
      this.decorations = buildDeco(update.view, tree, always);
    }
  }
}, {
  provide: plugin => {
    function access(view) {
      var _a, _b;
      return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.none;
    }
    return [_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.outerDecorations.of(access), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .Prec */ .Nb.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .EditorView */ .Lz.bidiIsolatedRanges.of(access))];
  }
});
function buildDeco(view, tree, always) {
  let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__/* .RangeSetBuilder */ .vB();
  let ranges = view.visibleRanges;
  if (!always) ranges = clipRTLLines(ranges, view.state.doc);
  for (var _iterator27 = _createForOfIteratorHelperLoose(ranges), _step27; !(_step27 = _iterator27()).done;) {
    let {
      from,
      to
    } = _step27.value;
    tree.iterate({
      enter: node => {
        let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.isolate);
        if (iso) deco.add(node.from, node.to, marks[iso]);
      },
      from,
      to
    });
  }
  return deco.finish();
}
function clipRTLLines(ranges, doc) {
  let cur = doc.iter(),
    pos = 0,
    result = [],
    last = null;
  for (var _iterator28 = _createForOfIteratorHelperLoose(ranges), _step28; !(_step28 = _iterator28()).done;) {
    let {
      from,
      to
    } = _step28.value;
    if (last && last.to > from) {
      from = last.to;
      if (from >= to) continue;
    }
    if (pos + cur.value.length < from) {
      cur.next(from - (pos + cur.value.length));
      pos = from;
    }
    for (;;) {
      let start = pos,
        end = pos + cur.value.length;
      if (!cur.lineBreak && buildForLine(cur.value)) {
        if (last && last.to > start - 10) last.to = Math.min(to, end);else result.push(last = {
          from: start,
          to: Math.min(to, end)
        });
      }
      if (end >= to) break;
      pos = end;
      cur.next();
    }
  }
  return result;
}
const marks = {
  rtl: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({
    class: "cm-iso",
    inclusive: true,
    attributes: {
      dir: "rtl"
    },
    bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.RTL
  }),
  ltr: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({
    class: "cm-iso",
    inclusive: true,
    attributes: {
      dir: "ltr"
    },
    bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Direction */ .OP.LTR
  }),
  auto: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__/* .Decoration */ .NZ.mark({
    class: "cm-iso",
    inclusive: true,
    attributes: {
      dir: "auto"
    },
    bidiIsolate: null
  })
};


/***/ }),

/***/ 4726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const getSymbolSize = (__webpack_require__(3340).getSymbolSize);
const FINDER_PATTERN_SIZE = 7;
exports.getPositions = function getPositions(version) {
  const size = getSymbolSize(version);
  return [[0, 0], [size - FINDER_PATTERN_SIZE, 0], [0, size - FINDER_PATTERN_SIZE]];
};

/***/ }),

/***/ 4758:
/***/ ((module) => {

"use strict";

var dijkstra = {
  single_source_shortest_paths: function (graph, s, d) {
    var predecessors = {};
    var costs = {};
    costs[s] = 0;
    var open = dijkstra.PriorityQueue.make();
    open.push(s, 0);
    var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
    while (!open.empty()) {
      closest = open.pop();
      u = closest.value;
      cost_of_s_to_u = closest.cost;
      adjacent_nodes = graph[u] || {};
      for (v in adjacent_nodes) {
        if (adjacent_nodes.hasOwnProperty(v)) {
          cost_of_e = adjacent_nodes[v];
          cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
          cost_of_s_to_v = costs[v];
          first_visit = typeof costs[v] === 'undefined';
          if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
            costs[v] = cost_of_s_to_u_plus_cost_of_e;
            open.push(v, cost_of_s_to_u_plus_cost_of_e);
            predecessors[v] = u;
          }
        }
      }
    }
    if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
      throw new Error(msg);
    }
    return predecessors;
  },
  extract_shortest_path_from_predecessor_list: function (predecessors, d) {
    var nodes = [];
    var u = d;
    var predecessor;
    while (u) {
      nodes.push(u);
      predecessor = predecessors[u];
      u = predecessors[u];
    }
    nodes.reverse();
    return nodes;
  },
  find_path: function (graph, s, d) {
    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
    return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
  },
  PriorityQueue: {
    make: function (opts) {
      var T = dijkstra.PriorityQueue,
        t = {},
        key;
      opts = opts || {};
      for (key in T) {
        if (T.hasOwnProperty(key)) {
          t[key] = T[key];
        }
      }
      t.queue = [];
      t.sorter = opts.sorter || T.default_sorter;
      return t;
    },
    default_sorter: function (a, b) {
      return a.cost - b.cost;
    },
    push: function (value, cost) {
      var item = {
        value: value,
        cost: cost
      };
      this.queue.push(item);
      this.queue.sort(this.sorter);
    },
    pop: function () {
      return this.queue.shift();
    },
    empty: function () {
      return this.queue.length === 0;
    }
  }
};
if (true) {
  module.exports = dijkstra;
}

/***/ }),

/***/ 4846:
/***/ ((__unused_webpack_module, exports) => {

const numeric = '[0-9]+';
const alphanumeric = '[A-Z $%*+\\-./:]+';
let kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' + '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' + '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' + '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
kanji = kanji.replace(/u/g, '\\u');
const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';
exports.KANJI = new RegExp(kanji, 'g');
exports.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
exports.BYTE = new RegExp(byte, 'g');
exports.NUMERIC = new RegExp(numeric, 'g');
exports.ALPHANUMERIC = new RegExp(alphanumeric, 'g');
const TEST_KANJI = new RegExp('^' + kanji + '$');
const TEST_NUMERIC = new RegExp('^' + numeric + '$');
const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');
exports.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str);
};
exports.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str);
};
exports.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str);
};

/***/ }),

/***/ 4996:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/ami.svg";

/***/ }),

/***/ 5016:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DM: () => (/* binding */ highlightTree),
/* harmony export */   _A: () => (/* binding */ tags),
/* harmony export */   az: () => (/* binding */ tagHighlighter),
/* harmony export */   pn: () => (/* binding */ styleTags),
/* harmony export */   vw: () => (/* binding */ Tag)
/* harmony export */ });
/* unused harmony exports classHighlighter, getStyleTags, highlightCode */
/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(413);
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

let nextTagID = 0;
class Tag {
  constructor(name, set, base, modified) {
    this.name = name;
    this.set = set;
    this.base = base;
    this.modified = modified;
    this.id = nextTagID++;
  }
  toString() {
    let {
      name
    } = this;
    for (var _iterator = _createForOfIteratorHelperLoose(this.modified), _step; !(_step = _iterator()).done;) {
      let mod = _step.value;
      if (mod.name) name = `${mod.name}(${name})`;
    }
    return name;
  }
  static define(nameOrParent, parent) {
    let name = typeof nameOrParent == "string" ? nameOrParent : "?";
    if (nameOrParent instanceof Tag) parent = nameOrParent;
    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error("Can not derive from a modified tag");
    let tag = new Tag(name, [], null, []);
    tag.set.push(tag);
    if (parent) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(parent.set), _step2; !(_step2 = _iterator2()).done;) {
        let t = _step2.value;
        tag.set.push(t);
      }
    }
    return tag;
  }
  static defineModifier(name) {
    let mod = new Modifier(name);
    return tag => {
      if (tag.modified.indexOf(mod) > -1) return tag;
      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
    };
  }
}
let nextModifierID = 0;
class Modifier {
  constructor(name) {
    this.name = name;
    this.instances = [];
    this.id = nextModifierID++;
  }
  static get(base, mods) {
    if (!mods.length) return base;
    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));
    if (exists) return exists;
    let set = [],
      tag = new Tag(base.name, set, base, mods);
    for (var _iterator3 = _createForOfIteratorHelperLoose(mods), _step3; !(_step3 = _iterator3()).done;) {
      let m = _step3.value;
      m.instances.push(tag);
    }
    let configs = powerSet(mods);
    for (var _iterator4 = _createForOfIteratorHelperLoose(base.set), _step4; !(_step4 = _iterator4()).done;) {
      let parent = _step4.value;
      if (!parent.modified.length) {
        for (var _iterator5 = _createForOfIteratorHelperLoose(configs), _step5; !(_step5 = _iterator5()).done;) {
          let config = _step5.value;
          set.push(Modifier.get(parent, config));
        }
      }
    }
    return tag;
  }
}
function sameArray(a, b) {
  return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
  let sets = [[]];
  for (let i = 0; i < array.length; i++) {
    for (let j = 0, e = sets.length; j < e; j++) {
      sets.push(sets[j].concat(array[i]));
    }
  }
  return sets.sort((a, b) => b.length - a.length);
}
function styleTags(spec) {
  let byName = Object.create(null);
  for (let prop in spec) {
    let tags = spec[prop];
    if (!Array.isArray(tags)) tags = [tags];
    for (var _iterator6 = _createForOfIteratorHelperLoose(prop.split(" ")), _step6; !(_step6 = _iterator6()).done;) {
      let part = _step6.value;
      if (part) {
        let pieces = [],
          mode = 2,
          rest = part;
        for (let pos = 0;;) {
          if (rest == "..." && pos > 0 && pos + 3 == part.length) {
            mode = 1;
            break;
          }
          let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
          if (!m) throw new RangeError("Invalid path: " + part);
          pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
          pos += m[0].length;
          if (pos == part.length) break;
          let next = part[pos++];
          if (pos == part.length && next == "!") {
            mode = 0;
            break;
          }
          if (next != "/") throw new RangeError("Invalid path: " + part);
          rest = part.slice(pos);
        }
        let last = pieces.length - 1,
          inner = pieces[last];
        if (!inner) throw new RangeError("Invalid path: " + part);
        let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
        byName[inner] = rule.sort(byName[inner]);
      }
    }
  }
  return ruleNodeProp.add(byName);
}
const ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY();
class Rule {
  constructor(tags, mode, context, next) {
    this.tags = tags;
    this.mode = mode;
    this.context = context;
    this.next = next;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(other) {
    if (!other || other.depth < this.depth) {
      this.next = other;
      return this;
    }
    other.next = this.sort(other.next);
    return other;
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Rule.empty = new Rule([], 2, null);
function tagHighlighter(tags, options) {
  let map = Object.create(null);
  for (var _iterator7 = _createForOfIteratorHelperLoose(tags), _step7; !(_step7 = _iterator7()).done;) {
    let style = _step7.value;
    if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else {
      for (var _iterator10 = _createForOfIteratorHelperLoose(style.tag), _step10; !(_step10 = _iterator10()).done;) {
        let tag = _step10.value;
        map[tag.id] = style.class;
      }
    }
  }
  let {
    scope,
    all = null
  } = options || {};
  return {
    style: tags => {
      let cls = all;
      for (var _iterator8 = _createForOfIteratorHelperLoose(tags), _step8; !(_step8 = _iterator8()).done;) {
        let tag = _step8.value;
        for (var _iterator9 = _createForOfIteratorHelperLoose(tag.set), _step9; !(_step9 = _iterator9()).done;) {
          let sub = _step9.value;
          let tagClass = map[sub.id];
          if (tagClass) {
            cls = cls ? cls + " " + tagClass : tagClass;
            break;
          }
        }
      }
      return cls;
    },
    scope
  };
}
function highlightTags(highlighters, tags) {
  let result = null;
  for (var _iterator11 = _createForOfIteratorHelperLoose(highlighters), _step11; !(_step11 = _iterator11()).done;) {
    let highlighter = _step11.value;
    let value = highlighter.style(tags);
    if (value) result = result ? result + " " + value : value;
  }
  return result;
}
function highlightTree(tree, highlighter, putStyle, from, to) {
  if (from === void 0) {
    from = 0;
  }
  if (to === void 0) {
    to = tree.length;
  }
  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
  builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
  builder.flush(to);
}
function highlightCode(code, tree, highlighter, putText, putBreak, from, to) {
  if (from === void 0) {
    from = 0;
  }
  if (to === void 0) {
    to = code.length;
  }
  let pos = from;
  function writeTo(p, classes) {
    if (p <= pos) return;
    for (let text = code.slice(pos, p), i = 0;;) {
      let nextBreak = text.indexOf("\n", i);
      let upto = nextBreak < 0 ? text.length : nextBreak;
      if (upto > i) putText(text.slice(i, upto), classes);
      if (nextBreak < 0) break;
      putBreak();
      i = nextBreak + 1;
    }
    pos = p;
  }
  highlightTree(tree, highlighter, (from, to, classes) => {
    writeTo(from, "");
    writeTo(to, classes);
  }, from, to);
  writeTo(to, "");
}
class HighlightBuilder {
  constructor(at, highlighters, span) {
    this.at = at;
    this.highlighters = highlighters;
    this.span = span;
    this.class = "";
  }
  startSpan(at, cls) {
    if (cls != this.class) {
      this.flush(at);
      if (at > this.at) this.at = at;
      this.class = cls;
    }
  }
  flush(to) {
    if (to > this.at && this.class) this.span(this.at, to, this.class);
  }
  highlightRange(cursor, from, to, inheritedClass, highlighters) {
    let {
      type,
      from: start,
      to: end
    } = cursor;
    if (start >= to || end <= from) return;
    if (type.isTop) highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
    let cls = inheritedClass;
    let rule = getStyleTags(cursor) || Rule.empty;
    let tagCls = highlightTags(highlighters, rule.tags);
    if (tagCls) {
      if (cls) cls += " ";
      cls += tagCls;
      if (rule.mode == 1) inheritedClass += (inheritedClass ? " " : "") + tagCls;
    }
    this.startSpan(Math.max(from, start), cls);
    if (rule.opaque) return;
    let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__/* .NodeProp */ .uY.mounted);
    if (mounted && mounted.overlay) {
      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
      let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
      let hasChild = cursor.firstChild();
      for (let i = 0, pos = start;; i++) {
        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
        let nextPos = next ? next.from + start : end;
        let rangeFrom = Math.max(from, pos),
          rangeTo = Math.min(to, nextPos);
        if (rangeFrom < rangeTo && hasChild) {
          while (cursor.from < rangeTo) {
            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
            this.startSpan(Math.min(rangeTo, cursor.to), cls);
            if (cursor.to >= nextPos || !cursor.nextSibling()) break;
          }
        }
        if (!next || nextPos > to) break;
        pos = next.to + start;
        if (pos > from) {
          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
          this.startSpan(Math.min(to, pos), cls);
        }
      }
      if (hasChild) cursor.parent();
    } else if (cursor.firstChild()) {
      if (mounted) inheritedClass = "";
      do {
        if (cursor.to <= from) continue;
        if (cursor.from >= to) break;
        this.highlightRange(cursor, from, to, inheritedClass, highlighters);
        this.startSpan(Math.min(to, cursor.to), cls);
      } while (cursor.nextSibling());
      cursor.parent();
    }
  }
}
function getStyleTags(node) {
  let rule = node.type.prop(ruleNodeProp);
  while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;
  return rule || null;
}
const t = Tag.define;
const comment = t(),
  name = t(),
  typeName = t(name),
  propertyName = t(name),
  literal = t(),
  string = t(literal),
  number = t(literal),
  content = t(),
  heading = t(content),
  keyword = t(),
  operator = t(),
  punctuation = t(),
  bracket = t(punctuation),
  meta = t();
const tags = {
  comment,
  lineComment: t(comment),
  blockComment: t(comment),
  docComment: t(comment),
  name,
  variableName: t(name),
  typeName: typeName,
  tagName: t(typeName),
  propertyName: propertyName,
  attributeName: t(propertyName),
  className: t(name),
  labelName: t(name),
  namespace: t(name),
  macroName: t(name),
  literal,
  string,
  docString: t(string),
  character: t(string),
  attributeValue: t(string),
  number,
  integer: t(number),
  float: t(number),
  bool: t(literal),
  regexp: t(literal),
  escape: t(literal),
  color: t(literal),
  url: t(literal),
  keyword,
  self: t(keyword),
  null: t(keyword),
  atom: t(keyword),
  unit: t(keyword),
  modifier: t(keyword),
  operatorKeyword: t(keyword),
  controlKeyword: t(keyword),
  definitionKeyword: t(keyword),
  moduleKeyword: t(keyword),
  operator,
  derefOperator: t(operator),
  arithmeticOperator: t(operator),
  logicOperator: t(operator),
  bitwiseOperator: t(operator),
  compareOperator: t(operator),
  updateOperator: t(operator),
  definitionOperator: t(operator),
  typeOperator: t(operator),
  controlOperator: t(operator),
  punctuation,
  separator: t(punctuation),
  bracket,
  angleBracket: t(bracket),
  squareBracket: t(bracket),
  paren: t(bracket),
  brace: t(bracket),
  content,
  heading,
  heading1: t(heading),
  heading2: t(heading),
  heading3: t(heading),
  heading4: t(heading),
  heading5: t(heading),
  heading6: t(heading),
  contentSeparator: t(content),
  list: t(content),
  quote: t(content),
  emphasis: t(content),
  strong: t(content),
  link: t(content),
  monospace: t(content),
  strikethrough: t(content),
  inserted: t(),
  deleted: t(),
  changed: t(),
  invalid: t(),
  meta,
  documentMeta: t(meta),
  annotation: t(meta),
  processingInstruction: t(meta),
  definition: Tag.defineModifier("definition"),
  constant: Tag.defineModifier("constant"),
  function: Tag.defineModifier("function"),
  standard: Tag.defineModifier("standard"),
  local: Tag.defineModifier("local"),
  special: Tag.defineModifier("special")
};
for (let name in tags) {
  let val = tags[name];
  if (val instanceof Tag) val.name = name;
}
const classHighlighter = tagHighlighter([{
  tag: tags.link,
  class: "tok-link"
}, {
  tag: tags.heading,
  class: "tok-heading"
}, {
  tag: tags.emphasis,
  class: "tok-emphasis"
}, {
  tag: tags.strong,
  class: "tok-strong"
}, {
  tag: tags.keyword,
  class: "tok-keyword"
}, {
  tag: tags.atom,
  class: "tok-atom"
}, {
  tag: tags.bool,
  class: "tok-bool"
}, {
  tag: tags.url,
  class: "tok-url"
}, {
  tag: tags.labelName,
  class: "tok-labelName"
}, {
  tag: tags.inserted,
  class: "tok-inserted"
}, {
  tag: tags.deleted,
  class: "tok-deleted"
}, {
  tag: tags.literal,
  class: "tok-literal"
}, {
  tag: tags.string,
  class: "tok-string"
}, {
  tag: tags.number,
  class: "tok-number"
}, {
  tag: [tags.regexp, tags.escape, tags.special(tags.string)],
  class: "tok-string2"
}, {
  tag: tags.variableName,
  class: "tok-variableName"
}, {
  tag: tags.local(tags.variableName),
  class: "tok-variableName tok-local"
}, {
  tag: tags.definition(tags.variableName),
  class: "tok-variableName tok-definition"
}, {
  tag: tags.special(tags.variableName),
  class: "tok-variableName2"
}, {
  tag: tags.definition(tags.propertyName),
  class: "tok-propertyName tok-definition"
}, {
  tag: tags.typeName,
  class: "tok-typeName"
}, {
  tag: tags.namespace,
  class: "tok-namespace"
}, {
  tag: tags.className,
  class: "tok-className"
}, {
  tag: tags.macroName,
  class: "tok-macroName"
}, {
  tag: tags.propertyName,
  class: "tok-propertyName"
}, {
  tag: tags.operator,
  class: "tok-operator"
}, {
  tag: tags.comment,
  class: "tok-comment"
}, {
  tag: tags.meta,
  class: "tok-meta"
}, {
  tag: tags.invalid,
  class: "tok-invalid"
}, {
  tag: tags.punctuation,
  class: "tok-punctuation"
}]);


/***/ }),

/***/ 5056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ 5072:
/***/ ((module) => {

"use strict";


var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ 5106:
/***/ ((__unused_webpack_module, exports) => {

exports.Patterns = {
  PATTERN000: 0,
  PATTERN001: 1,
  PATTERN010: 2,
  PATTERN011: 3,
  PATTERN100: 4,
  PATTERN101: 5,
  PATTERN110: 6,
  PATTERN111: 7
};
const PenaltyScores = {
  N1: 3,
  N2: 3,
  N3: 40,
  N4: 10
};
exports.isValid = function isValid(mask) {
  return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;
};
exports.from = function from(value) {
  return exports.isValid(value) ? parseInt(value, 10) : undefined;
};
exports.getPenaltyN1 = function getPenaltyN1(data) {
  const size = data.size;
  let points = 0;
  let sameCountCol = 0;
  let sameCountRow = 0;
  let lastCol = null;
  let lastRow = null;
  for (let row = 0; row < size; row++) {
    sameCountCol = sameCountRow = 0;
    lastCol = lastRow = null;
    for (let col = 0; col < size; col++) {
      let module = data.get(row, col);
      if (module === lastCol) {
        sameCountCol++;
      } else {
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        lastCol = module;
        sameCountCol = 1;
      }
      module = data.get(col, row);
      if (module === lastRow) {
        sameCountRow++;
      } else {
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
        lastRow = module;
        sameCountRow = 1;
      }
    }
    if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
    if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
  }
  return points;
};
exports.getPenaltyN2 = function getPenaltyN2(data) {
  const size = data.size;
  let points = 0;
  for (let row = 0; row < size - 1; row++) {
    for (let col = 0; col < size - 1; col++) {
      const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
      if (last === 4 || last === 0) points++;
    }
  }
  return points * PenaltyScores.N2;
};
exports.getPenaltyN3 = function getPenaltyN3(data) {
  const size = data.size;
  let points = 0;
  let bitsCol = 0;
  let bitsRow = 0;
  for (let row = 0; row < size; row++) {
    bitsCol = bitsRow = 0;
    for (let col = 0; col < size; col++) {
      bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);
      if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;
      bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);
      if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
    }
  }
  return points * PenaltyScores.N3;
};
exports.getPenaltyN4 = function getPenaltyN4(data) {
  let darkCount = 0;
  const modulesCount = data.data.length;
  for (let i = 0; i < modulesCount; i++) darkCount += data.data[i];
  const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
  return k * PenaltyScores.N4;
};
function getMaskAt(maskPattern, i, j) {
  switch (maskPattern) {
    case exports.Patterns.PATTERN000:
      return (i + j) % 2 === 0;
    case exports.Patterns.PATTERN001:
      return i % 2 === 0;
    case exports.Patterns.PATTERN010:
      return j % 3 === 0;
    case exports.Patterns.PATTERN011:
      return (i + j) % 3 === 0;
    case exports.Patterns.PATTERN100:
      return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
    case exports.Patterns.PATTERN101:
      return i * j % 2 + i * j % 3 === 0;
    case exports.Patterns.PATTERN110:
      return (i * j % 2 + i * j % 3) % 2 === 0;
    case exports.Patterns.PATTERN111:
      return (i * j % 3 + (i + j) % 2) % 2 === 0;
    default:
      throw new Error('bad maskPattern:' + maskPattern);
  }
}
exports.applyMask = function applyMask(pattern, data) {
  const size = data.size;
  for (let col = 0; col < size; col++) {
    for (let row = 0; row < size; row++) {
      if (data.isReserved(row, col)) continue;
      data.xor(row, col, getMaskAt(pattern, row, col));
    }
  }
};
exports.getBestMask = function getBestMask(data, setupFormatFunc) {
  const numPatterns = Object.keys(exports.Patterns).length;
  let bestPattern = 0;
  let lowerPenalty = Infinity;
  for (let p = 0; p < numPatterns; p++) {
    setupFormatFunc(p);
    exports.applyMask(p, data);
    const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
    exports.applyMask(p, data);
    if (penalty < lowerPenalty) {
      lowerPenalty = penalty;
      bestPattern = p;
    }
  }
  return bestPattern;
};

/***/ }),

/***/ 5177:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  NZ: () => (/* binding */ Decoration),
  OP: () => (/* binding */ Direction),
  Lz: () => (/* binding */ EditorView),
  wJ: () => (/* binding */ GutterMarker),
  Z9: () => (/* binding */ ViewPlugin),
  xO: () => (/* binding */ WidgetType),
  Eg: () => (/* binding */ getTooltip),
  cU: () => (/* binding */ gutter),
  N$: () => (/* binding */ highlightSpecialChars),
  w4: () => (/* binding */ keymap),
  $K: () => (/* binding */ lineNumbers),
  c_: () => (/* binding */ logException),
  DK: () => (/* binding */ showTooltip)
});

// UNUSED EXPORTS: BidiSpan, BlockInfo, BlockType, MatchDecorator, RectangleMarker, ViewUpdate, __test, closeHoverTooltips, crosshairCursor, drawSelection, dropCursor, getDrawSelectionConfig, getPanel, gutterLineClass, gutterWidgetClass, gutters, hasHoverTooltips, highlightActiveLine, highlightActiveLineGutter, highlightTrailingWhitespace, highlightWhitespace, hoverTooltip, layer, lineNumberMarkers, lineNumberWidgetMarker, panels, placeholder, rectangularSelection, repositionTooltips, runScopeHandlers, scrollPastEnd, showPanel, tooltips

// EXTERNAL MODULE: ./node_modules/@codemirror/state/dist/index.js + 1 modules
var state_dist = __webpack_require__(1001);
// EXTERNAL MODULE: ./node_modules/style-mod/src/style-mod.js
var style_mod = __webpack_require__(1785);
;// ./node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
;// ./node_modules/@codemirror/view/dist/index.js
function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }



function getSelection(root) {
  let target;
  if (root.nodeType == 11) {
    target = root.getSelection ? root : root.ownerDocument;
  } else {
    target = root;
  }
  return target.getSelection();
}
function contains(dom, node) {
  return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function hasSelection(dom, selection) {
  if (!selection.anchorNode) return false;
  try {
    return contains(dom, selection.anchorNode);
  } catch (_) {
    return false;
  }
}
function clientRectsFor(dom) {
  if (dom.nodeType == 3) return textRange(dom, 0, dom.nodeValue.length).getClientRects();else if (dom.nodeType == 1) return dom.getClientRects();else return [];
}
function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode ? scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1) : false;
}
function domIndex(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) return index;
  }
}
function isBlockElement(node) {
  return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true;
    if (off == (dir < 0 ? 0 : maxOffset(node))) {
      if (node.nodeName == "DIV") return false;
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1) return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.nodeType == 1 && node.contentEditable == "false") return false;
      off = dir < 0 ? maxOffset(node) : 0;
    } else {
      return false;
    }
  }
}
function maxOffset(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
  let x = left ? rect.left : rect.right;
  return {
    left: x,
    right: x,
    top: rect.top,
    bottom: rect.bottom
  };
}
function windowRect(win) {
  let vp = win.visualViewport;
  if (vp) return {
    left: 0,
    right: vp.width,
    top: 0,
    bottom: vp.height
  };
  return {
    left: 0,
    right: win.innerWidth,
    top: 0,
    bottom: win.innerHeight
  };
}
function getScale(elt, rect) {
  let scaleX = rect.width / elt.offsetWidth;
  let scaleY = rect.height / elt.offsetHeight;
  if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1) scaleX = 1;
  if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1) scaleY = 1;
  return {
    scaleX,
    scaleY
  };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
  let doc = dom.ownerDocument,
    win = doc.defaultView || window;
  for (let cur = dom, stop = false; cur && !stop;) {
    if (cur.nodeType == 1) {
      let bounding,
        top = cur == doc.body;
      let scaleX = 1,
        scaleY = 1;
      if (top) {
        bounding = windowRect(win);
      } else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position)) stop = true;
        if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
          cur = cur.assignedSlot || cur.parentNode;
          continue;
        }
        let rect = cur.getBoundingClientRect();
        ({
          scaleX,
          scaleY
        } = getScale(cur, rect));
        bounding = {
          left: rect.left,
          right: rect.left + cur.clientWidth * scaleX,
          top: rect.top,
          bottom: rect.top + cur.clientHeight * scaleY
        };
      }
      let moveX = 0,
        moveY = 0;
      if (y == "nearest") {
        if (rect.top < bounding.top) {
          moveY = rect.top - (bounding.top + yMargin);
          if (side > 0 && rect.bottom > bounding.bottom + moveY) moveY = rect.bottom - bounding.bottom + yMargin;
        } else if (rect.bottom > bounding.bottom) {
          moveY = rect.bottom - bounding.bottom + yMargin;
          if (side < 0 && rect.top - moveY < bounding.top) moveY = rect.top - (bounding.top + yMargin);
        }
      } else {
        let rectHeight = rect.bottom - rect.top,
          boundingHeight = bounding.bottom - bounding.top;
        let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 : y == "start" || y == "center" && side < 0 ? rect.top - yMargin : rect.bottom - boundingHeight + yMargin;
        moveY = targetTop - bounding.top;
      }
      if (x == "nearest") {
        if (rect.left < bounding.left) {
          moveX = rect.left - (bounding.left + xMargin);
          if (side > 0 && rect.right > bounding.right + moveX) moveX = rect.right - bounding.right + xMargin;
        } else if (rect.right > bounding.right) {
          moveX = rect.right - bounding.right + xMargin;
          if (side < 0 && rect.left < bounding.left + moveX) moveX = rect.left - (bounding.left + xMargin);
        }
      } else {
        let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 : x == "start" == ltr ? rect.left - xMargin : rect.right - (bounding.right - bounding.left) + xMargin;
        moveX = targetLeft - bounding.left;
      }
      if (moveX || moveY) {
        if (top) {
          win.scrollBy(moveX, moveY);
        } else {
          let movedX = 0,
            movedY = 0;
          if (moveY) {
            let start = cur.scrollTop;
            cur.scrollTop += moveY / scaleY;
            movedY = (cur.scrollTop - start) * scaleY;
          }
          if (moveX) {
            let start = cur.scrollLeft;
            cur.scrollLeft += moveX / scaleX;
            movedX = (cur.scrollLeft - start) * scaleX;
          }
          rect = {
            left: rect.left - movedX,
            top: rect.top - movedY,
            right: rect.right - movedX,
            bottom: rect.bottom - movedY
          };
          if (movedX && Math.abs(movedX - moveX) < 1) x = "nearest";
          if (movedY && Math.abs(movedY - moveY) < 1) y = "nearest";
        }
      }
      if (top) break;
      if (rect.top < bounding.top || rect.bottom > bounding.bottom || rect.left < bounding.left || rect.right > bounding.right) rect = {
        left: Math.max(rect.left, bounding.left),
        right: Math.min(rect.right, bounding.right),
        top: Math.max(rect.top, bounding.top),
        bottom: Math.min(rect.bottom, bounding.bottom)
      };
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
}
function scrollableParents(dom) {
  let doc = dom.ownerDocument,
    x,
    y;
  for (let cur = dom.parentNode; cur;) {
    if (cur == doc.body || x && y) {
      break;
    } else if (cur.nodeType == 1) {
      if (!y && cur.scrollHeight > cur.clientHeight) y = cur;
      if (!x && cur.scrollWidth > cur.clientWidth) x = cur;
      cur = cur.assignedSlot || cur.parentNode;
    } else if (cur.nodeType == 11) {
      cur = cur.host;
    } else {
      break;
    }
  }
  return {
    x,
    y
  };
}
class DOMSelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  eq(domSel) {
    return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset && this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
  }
  setRange(range) {
    let {
      anchorNode,
      focusNode
    } = range;
    this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
  }
  set(anchorNode, anchorOffset, focusNode, focusOffset) {
    this.anchorNode = anchorNode;
    this.anchorOffset = anchorOffset;
    this.focusNode = focusNode;
    this.focusOffset = focusOffset;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive();
  if (preventScrollSupported) return dom.focus(preventScrollSupported);
  let stack = [];
  for (let cur = dom; cur; cur = cur.parentNode) {
    stack.push(cur, cur.scrollTop, cur.scrollLeft);
    if (cur == cur.ownerDocument) break;
  }
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {
        preventScroll: true
      };
      return true;
    }
  } : undefined);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    for (let i = 0; i < stack.length;) {
      let elt = stack[i++],
        top = stack[i++],
        left = stack[i++];
      if (elt.scrollTop != top) elt.scrollTop = top;
      if (elt.scrollLeft != left) elt.scrollLeft = left;
    }
  }
}
let scratchRange;
function textRange(node, from, to) {
  if (to === void 0) {
    to = from;
  }
  let range = scratchRange || (scratchRange = document.createRange());
  range.setEnd(node, to);
  range.setStart(node, from);
  return range;
}
function dispatchKey(elt, name, code, mods) {
  let options = {
    key: name,
    code: name,
    keyCode: code,
    which: code,
    cancelable: true
  };
  if (mods) ({
    altKey: options.altKey,
    ctrlKey: options.ctrlKey,
    shiftKey: options.shiftKey,
    metaKey: options.metaKey
  } = mods);
  let down = new KeyboardEvent("keydown", options);
  down.synthetic = true;
  elt.dispatchEvent(down);
  let up = new KeyboardEvent("keyup", options);
  up.synthetic = true;
  elt.dispatchEvent(up);
  return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
  while (node) {
    if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host)) return node;
    node = node.assignedSlot || node.parentNode;
  }
  return null;
}
function clearAttributes(node) {
  while (node.attributes.length) node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc, selection) {
  let node = selection.focusNode,
    offset = selection.focusOffset;
  if (!node || selection.anchorNode != node || selection.anchorOffset != offset) return false;
  offset = Math.min(offset, maxOffset(node));
  for (;;) {
    if (offset) {
      if (node.nodeType != 1) return false;
      let prev = node.childNodes[offset - 1];
      if (prev.contentEditable == "false") offset--;else {
        node = prev;
        offset = maxOffset(node);
      }
    } else if (node == doc) {
      return true;
    } else {
      offset = domIndex(node);
      node = node.parentNode;
    }
  }
}
function isScrolledToBottom(elt) {
  return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}
function textNodeBefore(startNode, startOffset) {
  for (let node = startNode, offset = startOffset;;) {
    if (node.nodeType == 3 && offset > 0) {
      return {
        node: node,
        offset: offset
      };
    } else if (node.nodeType == 1 && offset > 0) {
      if (node.contentEditable == "false") return null;
      node = node.childNodes[offset - 1];
      offset = maxOffset(node);
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter(startNode, startOffset) {
  for (let node = startNode, offset = startOffset;;) {
    if (node.nodeType == 3 && offset < node.nodeValue.length) {
      return {
        node: node,
        offset: offset
      };
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      if (node.contentEditable == "false") return null;
      node = node.childNodes[offset];
      offset = 0;
    } else if (node.parentNode && !isBlockElement(node)) {
      offset = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
class DOMPos {
  constructor(node, offset, precise) {
    if (precise === void 0) {
      precise = true;
    }
    this.node = node;
    this.offset = offset;
    this.precise = precise;
  }
  static before(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom), precise);
  }
  static after(dom, precise) {
    return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise);
  }
}
const noChildren = [];
class ContentView {
  constructor() {
    this.parent = null;
    this.dom = null;
    this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(view) {
    let pos = this.posAtStart;
    for (var _iterator = _createForOfIteratorHelperLoose(this.children), _step; !(_step = _iterator()).done;) {
      let child = _step.value;
      if (child == view) return pos;
      pos += child.length + child.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(view) {
    return this.posBefore(view) + view.length;
  }
  sync(view, track) {
    if (this.flags & 2) {
      let parent = this.dom;
      let prev = null,
        next;
      for (var _iterator2 = _createForOfIteratorHelperLoose(this.children), _step2; !(_step2 = _iterator2()).done;) {
        let child = _step2.value;
        if (child.flags & 7) {
          if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
            let contentView = ContentView.get(next);
            if (!contentView || !contentView.parent && contentView.canReuseDOM(child)) child.reuseDOM(next);
          }
          child.sync(view, track);
          child.flags &= ~7;
        }
        next = prev ? prev.nextSibling : parent.firstChild;
        if (track && !track.written && track.node == parent && next != child.dom) track.written = true;
        if (child.dom.parentNode == parent) {
          while (next && next != child.dom) next = rm$1(next);
        } else {
          parent.insertBefore(child.dom, next);
        }
        prev = child.dom;
      }
      next = prev ? prev.nextSibling : parent.firstChild;
      if (next && track && track.node == parent) track.written = true;
      while (next) next = rm$1(next);
    } else if (this.flags & 1) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(this.children), _step3; !(_step3 = _iterator3()).done;) {
        let child = _step3.value;
        if (child.flags & 7) {
          child.sync(view, track);
          child.flags &= ~7;
        }
      }
    }
  }
  reuseDOM(_dom) {}
  localPosFromDOM(node, offset) {
    let after;
    if (node == this.dom) {
      after = this.dom.childNodes[offset];
    } else {
      let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
      for (;;) {
        let parent = node.parentNode;
        if (parent == this.dom) break;
        if (bias == 0 && parent.firstChild != parent.lastChild) {
          if (node == parent.firstChild) bias = -1;else bias = 1;
        }
        node = parent;
      }
      if (bias < 0) after = node;else after = node.nextSibling;
    }
    if (after == this.dom.firstChild) return 0;
    while (after && !ContentView.get(after)) after = after.nextSibling;
    if (!after) return this.length;
    for (let i = 0, pos = 0;; i++) {
      let child = this.children[i];
      if (child.dom == after) return pos;
      pos += child.length + child.breakAfter;
    }
  }
  domBoundsAround(from, to, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    let fromI = -1,
      fromStart = -1,
      toI = -1,
      toEnd = -1;
    for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
      let child = this.children[i],
        end = pos + child.length;
      if (pos < from && end > to) return child.domBoundsAround(from, to, pos);
      if (end >= from && fromI == -1) {
        fromI = i;
        fromStart = pos;
      }
      if (pos > to && child.dom.parentNode == this.dom) {
        toI = i;
        toEnd = prevEnd;
        break;
      }
      prevEnd = end;
      pos = end + child.breakAfter;
    }
    return {
      from: fromStart,
      to: toEnd < 0 ? offset + this.length : toEnd,
      startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null
    };
  }
  markDirty(andParent) {
    if (andParent === void 0) {
      andParent = false;
    }
    this.flags |= 2;
    this.markParentsDirty(andParent);
  }
  markParentsDirty(childList) {
    for (let parent = this.parent; parent; parent = parent.parent) {
      if (childList) parent.flags |= 2;
      if (parent.flags & 1) return;
      parent.flags |= 1;
      childList = false;
    }
  }
  setParent(parent) {
    if (this.parent != parent) {
      this.parent = parent;
      if (this.flags & 7) this.markParentsDirty(true);
    }
  }
  setDOM(dom) {
    if (this.dom == dom) return;
    if (this.dom) this.dom.cmView = null;
    this.dom = dom;
    dom.cmView = this;
  }
  get rootView() {
    for (let v = this;;) {
      let parent = v.parent;
      if (!parent) return v;
      v = parent;
    }
  }
  replaceChildren(from, to, children) {
    if (children === void 0) {
      children = noChildren;
    }
    this.markDirty();
    for (let i = from; i < to; i++) {
      let child = this.children[i];
      if (child.parent == this && children.indexOf(child) < 0) child.destroy();
    }
    if (children.length < 250) this.children.splice(from, to - from, ...children);else this.children = [].concat(this.children.slice(0, from), children, this.children.slice(to));
    for (let i = 0; i < children.length; i++) children[i].setParent(this);
  }
  ignoreMutation(_rec) {
    return false;
  }
  ignoreEvent(_event) {
    return false;
  }
  childCursor(pos) {
    if (pos === void 0) {
      pos = this.length;
    }
    return new ChildCursor(this.children, pos, this.children.length);
  }
  childPos(pos, bias) {
    if (bias === void 0) {
      bias = 1;
    }
    return this.childCursor().findPos(pos, bias);
  }
  toString() {
    let name = this.constructor.name.replace("View", "");
    return name + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(node) {
    return node.cmView;
  }
  get isEditable() {
    return true;
  }
  get isWidget() {
    return false;
  }
  get isHidden() {
    return false;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    return false;
  }
  become(other) {
    return false;
  }
  canReuseDOM(other) {
    return other.constructor == this.constructor && !((this.flags | other.flags) & 8);
  }
  getSide() {
    return 0;
  }
  destroy() {
    for (var _iterator4 = _createForOfIteratorHelperLoose(this.children), _step4; !(_step4 = _iterator4()).done;) {
      let child = _step4.value;
      if (child.parent == this) child.destroy();
    }
    this.parent = null;
  }
}
ContentView.prototype.breakAfter = 0;
function rm$1(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ChildCursor {
  constructor(children, pos, i) {
    this.children = children;
    this.pos = pos;
    this.i = i;
    this.off = 0;
  }
  findPos(pos, bias) {
    if (bias === void 0) {
      bias = 1;
    }
    for (;;) {
      if (pos > this.pos || pos == this.pos && (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
        this.off = pos - this.pos;
        return this;
      }
      let next = this.children[--this.i];
      this.pos -= next.length + next.breakAfter;
    }
  }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
  let {
    children
  } = parent;
  let before = children.length ? children[fromI] : null;
  let last = insert.length ? insert[insert.length - 1] : null;
  let breakAtEnd = last ? last.breakAfter : breakAtStart;
  if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 && before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd)) return;
  if (toI < children.length) {
    let after = children[toI];
    if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
      if (fromI == toI) {
        after = after.split(toOff);
        toOff = 0;
      }
      if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
        insert[insert.length - 1] = after;
      } else {
        if (toOff || after.children.length && !after.children[0].length) after.merge(0, toOff, null, false, 0, openEnd);
        insert.push(after);
      }
    } else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
      if (last) last.breakAfter = 1;else breakAtStart = 1;
    }
    toI++;
  }
  if (before) {
    before.breakAfter = breakAtStart;
    if (fromOff > 0) {
      if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
        before.breakAfter = insert.shift().breakAfter;
      } else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
        before.merge(fromOff, before.length, null, false, openStart, 0);
      }
      fromI++;
    }
  }
  while (fromI < toI && insert.length) {
    if (children[toI - 1].become(insert[insert.length - 1])) {
      toI--;
      insert.pop();
      openEnd = insert.length ? 0 : openStart;
    } else if (children[fromI].become(insert[0])) {
      fromI++;
      insert.shift();
      openStart = insert.length ? 0 : openEnd;
    } else {
      break;
    }
  }
  if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter && children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd)) fromI--;
  if (fromI < toI || insert.length) parent.replaceChildren(fromI, toI, insert);
}
function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
  let cur = parent.childCursor();
  let {
    i: toI,
    off: toOff
  } = cur.findPos(to, 1);
  let {
    i: fromI,
    off: fromOff
  } = cur.findPos(from, -1);
  let dLen = from - to;
  for (var _iterator5 = _createForOfIteratorHelperLoose(insert), _step5; !(_step5 = _iterator5()).done;) {
    let view = _step5.value;
    dLen += view.length;
  }
  parent.length += dLen;
  replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
}
let nav = typeof navigator != "undefined" ? navigator : {
  userAgent: "",
  vendor: "",
  platform: ""
};
let doc = typeof document != "undefined" ? document : {
  documentElement: {
    style: {}
  }
};
const ie_edge = /Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /MSIE \d/.test(nav.userAgent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const dist_ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !dist_ie && /gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !dist_ie && /Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !dist_ie && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
  mac: ios || /Mac/.test(nav.platform),
  windows: /Win/.test(nav.platform),
  linux: /Linux|X11/.test(nav.platform),
  ie: dist_ie,
  ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
  gecko,
  gecko_version: gecko ? +(/Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  chrome: !!chrome,
  chrome_version: chrome ? +chrome[1] : 0,
  ios,
  android: /Android\b/.test(nav.userAgent),
  webkit,
  safari,
  webkit_version: webkit ? +(/\bAppleWebKit\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
  tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const MaxJoinLen = 256;
class TextView extends ContentView {
  constructor(text) {
    super();
    this.text = text;
  }
  get length() {
    return this.text.length;
  }
  createDOM(textDOM) {
    this.setDOM(textDOM || document.createTextNode(this.text));
  }
  sync(view, track) {
    if (!this.dom) this.createDOM();
    if (this.dom.nodeValue != this.text) {
      if (track && track.node == this.dom) track.written = true;
      this.dom.nodeValue = this.text;
    }
  }
  reuseDOM(dom) {
    if (dom.nodeType == 3) this.createDOM(dom);
  }
  merge(from, to, source) {
    if (this.flags & 8 || source && (!(source instanceof TextView) || this.length - (to - from) + source.length > MaxJoinLen || source.flags & 8)) return false;
    this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = new TextView(this.text.slice(from));
    this.text = this.text.slice(0, from);
    this.markDirty();
    result.flags |= this.flags & 8;
    return result;
  }
  localPosFromDOM(node, offset) {
    return node == this.dom ? offset : offset ? this.text.length : 0;
  }
  domAtPos(pos) {
    return new DOMPos(this.dom, pos);
  }
  domBoundsAround(_from, _to, offset) {
    return {
      from: offset,
      to: offset + this.length,
      startDOM: this.dom,
      endDOM: this.dom.nextSibling
    };
  }
  coordsAt(pos, side) {
    return textCoords(this.dom, pos, side);
  }
}
class MarkView extends ContentView {
  constructor(mark, children, length) {
    if (children === void 0) {
      children = [];
    }
    if (length === void 0) {
      length = 0;
    }
    super();
    this.mark = mark;
    this.children = children;
    this.length = length;
    for (var _iterator6 = _createForOfIteratorHelperLoose(children), _step6; !(_step6 = _iterator6()).done;) {
      let ch = _step6.value;
      ch.setParent(this);
    }
  }
  setAttrs(dom) {
    clearAttributes(dom);
    if (this.mark.class) dom.className = this.mark.class;
    if (this.mark.attrs) for (let name in this.mark.attrs) dom.setAttribute(name, this.mark.attrs[name]);
    return dom;
  }
  canReuseDOM(other) {
    return super.canReuseDOM(other) && !((this.flags | other.flags) & 8);
  }
  reuseDOM(node) {
    if (node.nodeName == this.mark.tagName.toUpperCase()) {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    if (!this.dom) this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));else if (this.flags & 4) this.setAttrs(this.dom);
    super.sync(view, track);
  }
  merge(from, to, source, _hasStart, openStart, openEnd) {
    if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) || from && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
    this.markDirty();
    return true;
  }
  split(from) {
    let result = [],
      off = 0,
      detachFrom = -1,
      i = 0;
    for (var _iterator7 = _createForOfIteratorHelperLoose(this.children), _step7; !(_step7 = _iterator7()).done;) {
      let elt = _step7.value;
      let end = off + elt.length;
      if (end > from) result.push(off < from ? elt.split(from - off) : elt);
      if (detachFrom < 0 && off >= from) detachFrom = i;
      off = end;
      i++;
    }
    let length = this.length - from;
    this.length = from;
    if (detachFrom > -1) {
      this.children.length = detachFrom;
      this.markDirty();
    }
    return new MarkView(this.mark, result, length);
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  coordsAt(pos, side) {
    return coordsInChildren(this, pos, side);
  }
}
function textCoords(text, pos, side) {
  let length = text.nodeValue.length;
  if (pos > length) pos = length;
  let from = pos,
    to = pos,
    flatten = 0;
  if (pos == 0 && side < 0 || pos == length && side >= 0) {
    if (!(browser.chrome || browser.gecko)) {
      if (pos) {
        from--;
        flatten = 1;
      } else if (to < length) {
        to++;
        flatten = -1;
      }
    }
  } else {
    if (side < 0) from--;else if (to < length) to++;
  }
  let rects = textRange(text, from, to).getClientRects();
  if (!rects.length) return null;
  let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
  if (browser.safari && !flatten && rect.width == 0) rect = Array.prototype.find.call(rects, r => r.width) || rect;
  return flatten ? flattenRect(rect, flatten < 0) : rect || null;
}
class WidgetView extends ContentView {
  static create(widget, length, side) {
    return new WidgetView(widget, length, side);
  }
  constructor(widget, length, side) {
    super();
    this.widget = widget;
    this.length = length;
    this.side = side;
    this.prevWidget = null;
  }
  split(from) {
    let result = WidgetView.create(this.widget, this.length - from, this.side);
    this.length -= from;
    return result;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable) this.dom.contentEditable = "false";
    }
  }
  getSide() {
    return this.side;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  become(other) {
    if (other instanceof WidgetView && other.side == this.side && this.widget.constructor == other.widget.constructor) {
      if (!this.widget.compare(other.widget)) this.markDirty(true);
      if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get overrideDOMText() {
    if (this.length == 0) return state_dist/* Text */.EY.empty;
    let top = this;
    while (top.parent) top = top.parent;
    let {
        view
      } = top,
      text = view && view.state.doc,
      start = this.posAtStart;
    return text ? text.slice(start, start + this.length) : state_dist/* Text */.EY.empty;
  }
  domAtPos(pos) {
    return (this.length ? pos == 0 : this.side > 0) ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom) return custom;
    let rects = this.dom.getClientRects(),
      rect = null;
    if (!rects.length) return null;
    let fromBack = this.side ? this.side < 0 : pos > 0;
    for (let i = fromBack ? rects.length - 1 : 0;; i += fromBack ? -1 : 1) {
      rect = rects[i];
      if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom) break;
    }
    return flattenRect(rect, !fromBack);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy();
    if (this.dom) this.widget.destroy(this.dom);
  }
}
class WidgetBufferView extends ContentView {
  constructor(side) {
    super();
    this.side = side;
  }
  get length() {
    return 0;
  }
  merge() {
    return false;
  }
  become(other) {
    return other instanceof WidgetBufferView && other.side == this.side;
  }
  split() {
    return new WidgetBufferView(this.side);
  }
  sync() {
    if (!this.dom) {
      let dom = document.createElement("img");
      dom.className = "cm-widgetBuffer";
      dom.setAttribute("aria-hidden", "true");
      this.setDOM(dom);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(pos) {
    return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(pos) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return state_dist/* Text */.EY.empty;
  }
  get isHidden() {
    return true;
  }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
  let dom = parent.dom,
    {
      children
    } = parent,
    i = 0;
  for (let off = 0; i < children.length; i++) {
    let child = children[i],
      end = off + child.length;
    if (end == off && child.getSide() <= 0) continue;
    if (pos > off && pos < end && child.dom.parentNode == dom) return child.domAtPos(pos - off);
    if (pos <= off) break;
    off = end;
  }
  for (let j = i; j > 0; j--) {
    let prev = children[j - 1];
    if (prev.dom.parentNode == dom) return prev.domAtPos(prev.length);
  }
  for (let j = i; j < children.length; j++) {
    let next = children[j];
    if (next.dom.parentNode == dom) return next.domAtPos(0);
  }
  return new DOMPos(dom, 0);
}
function joinInlineInto(parent, view, open) {
  let last,
    {
      children
    } = parent;
  if (open > 0 && view instanceof MarkView && children.length && (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
    joinInlineInto(last, view.children[0], open - 1);
  } else {
    children.push(view);
    view.setParent(parent);
  }
  parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
  let before = null,
    beforePos = -1,
    after = null,
    afterPos = -1;
  function scan(view, pos) {
    for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
      let child = view.children[i],
        end = off + child.length;
      if (end >= pos) {
        if (child.children.length) {
          scan(child, pos - off);
        } else if ((!after || after.isHidden && side > 0) && (end > pos || off == end && child.getSide() > 0)) {
          after = child;
          afterPos = pos - off;
        } else if (off < pos || off == end && child.getSide() < 0 && !child.isHidden) {
          before = child;
          beforePos = pos - off;
        }
      }
      off = end;
    }
  }
  scan(view, pos);
  let target = (side < 0 ? before : after) || before || after;
  if (target) return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
  return fallbackRect(view);
}
function fallbackRect(view) {
  let last = view.dom.lastChild;
  if (!last) return view.dom.getBoundingClientRect();
  let rects = clientRectsFor(last);
  return rects[rects.length - 1] || null;
}
function combineAttrs(source, target) {
  for (let name in source) {
    if (name == "class" && target.class) target.class += " " + source.class;else if (name == "style" && target.style) target.style += ";" + source.style;else target[name] = source[name];
  }
  return target;
}
const noAttrs = Object.create(null);
function attrsEq(a, b, ignore) {
  if (a == b) return true;
  if (!a) a = noAttrs;
  if (!b) b = noAttrs;
  let keysA = Object.keys(a),
    keysB = Object.keys(b);
  if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) != keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0)) return false;
  for (var _i = 0, _keysA = keysA; _i < _keysA.length; _i++) {
    let key = _keysA[_i];
    if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key])) return false;
  }
  return true;
}
function updateAttrs(dom, prev, attrs) {
  let changed = false;
  if (prev) for (let name in prev) if (!(attrs && name in attrs)) {
    changed = true;
    if (name == "style") dom.style.cssText = "";else dom.removeAttribute(name);
  }
  if (attrs) for (let name in attrs) if (!(prev && prev[name] == attrs[name])) {
    changed = true;
    if (name == "style") dom.style.cssText = attrs[name];else dom.setAttribute(name, attrs[name]);
  }
  return changed;
}
function getAttrs(dom) {
  let attrs = Object.create(null);
  for (let i = 0; i < dom.attributes.length; i++) {
    let attr = dom.attributes[i];
    attrs[attr.name] = attr.value;
  }
  return attrs;
}
class WidgetType {
  eq(widget) {
    return false;
  }
  updateDOM(dom, view) {
    return false;
  }
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  get estimatedHeight() {
    return -1;
  }
  get lineBreaks() {
    return 0;
  }
  ignoreEvent(event) {
    return true;
  }
  coordsAt(dom, pos, side) {
    return null;
  }
  get isHidden() {
    return false;
  }
  get editable() {
    return false;
  }
  destroy(dom) {}
}
var BlockType = function (BlockType) {
  BlockType[BlockType["Text"] = 0] = "Text";
  BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
  BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
  BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
  return BlockType;
}(BlockType || (BlockType = {}));
class Decoration extends state_dist/* RangeValue */.FB {
  constructor(startSide, endSide, widget, spec) {
    super();
    this.startSide = startSide;
    this.endSide = endSide;
    this.widget = widget;
    this.spec = spec;
  }
  get heightRelevant() {
    return false;
  }
  static mark(spec) {
    return new MarkDecoration(spec);
  }
  static widget(spec) {
    let side = Math.max(-10000, Math.min(10000, spec.side || 0)),
      block = !!spec.block;
    side += block && !spec.inlineOrder ? side > 0 ? 300000000 : -400000000 : side > 0 ? 100000000 : -100000000;
    return new PointDecoration(spec, side, side, block, spec.widget || null, false);
  }
  static replace(spec) {
    let block = !!spec.block,
      startSide,
      endSide;
    if (spec.isBlockGap) {
      startSide = -500000000;
      endSide = 400000000;
    } else {
      let {
        start,
        end
      } = getInclusive(spec, block);
      startSide = (start ? block ? -300000000 : -1 : 500000000) - 1;
      endSide = (end ? block ? 200000000 : 1 : -600000000) + 1;
    }
    return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
  }
  static line(spec) {
    return new LineDecoration(spec);
  }
  static set(of, sort) {
    if (sort === void 0) {
      sort = false;
    }
    return state_dist/* RangeSet */.om.of(of, sort);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : false;
  }
}
Decoration.none = state_dist/* RangeSet */.om.empty;
class MarkDecoration extends Decoration {
  constructor(spec) {
    let {
      start,
      end
    } = getInclusive(spec);
    super(start ? -1 : 500000000, end ? 1 : -600000000, null, spec);
    this.tagName = spec.tagName || "span";
    this.class = spec.class || "";
    this.attrs = spec.attributes || null;
  }
  eq(other) {
    var _a, _b;
    return this == other || other instanceof MarkDecoration && this.tagName == other.tagName && (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) && attrsEq(this.attrs, other.attrs, "class");
  }
  range(from, to) {
    if (to === void 0) {
      to = from;
    }
    if (from >= to) throw new RangeError("Mark decorations may not be empty");
    return super.range(from, to);
  }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
  constructor(spec) {
    super(-200000000, -200000000, null, spec);
  }
  eq(other) {
    return other instanceof LineDecoration && this.spec.class == other.spec.class && attrsEq(this.spec.attributes, other.spec.attributes);
  }
  range(from, to) {
    if (to === void 0) {
      to = from;
    }
    if (to != from) throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(from, to);
  }
}
LineDecoration.prototype.mapMode = state_dist/* MapMode */.iR.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
  constructor(spec, startSide, endSide, block, widget, isReplace) {
    super(startSide, endSide, widget, spec);
    this.block = block;
    this.isReplace = isReplace;
    this.mapMode = !block ? state_dist/* MapMode */.iR.TrackDel : startSide <= 0 ? state_dist/* MapMode */.iR.TrackBefore : state_dist/* MapMode */.iR.TrackAfter;
  }
  get type() {
    return this.startSide != this.endSide ? BlockType.WidgetRange : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(other) {
    return other instanceof PointDecoration && widgetsEq(this.widget, other.widget) && this.block == other.block && this.startSide == other.startSide && this.endSide == other.endSide;
  }
  range(from, to) {
    if (to === void 0) {
      to = from;
    }
    if (this.isReplace && (from > to || from == to && this.startSide > 0 && this.endSide <= 0)) throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && to != from) throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(from, to);
  }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block) {
  if (block === void 0) {
    block = false;
  }
  let {
    inclusiveStart: start,
    inclusiveEnd: end
  } = spec;
  if (start == null) start = spec.inclusive;
  if (end == null) end = spec.inclusive;
  return {
    start: start !== null && start !== void 0 ? start : block,
    end: end !== null && end !== void 0 ? end : block
  };
}
function widgetsEq(a, b) {
  return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  let last = ranges.length - 1;
  if (last >= 0 && ranges[last] + margin >= from) ranges[last] = Math.max(ranges[last], to);else ranges.push(from, to);
}
class LineView extends ContentView {
  constructor() {
    super(...arguments);
    this.children = [];
    this.length = 0;
    this.prevAttrs = undefined;
    this.attrs = null;
    this.breakAfter = 0;
  }
  merge(from, to, source, hasStart, openStart, openEnd) {
    if (source) {
      if (!(source instanceof LineView)) return false;
      if (!this.dom) source.transferDOM(this);
    }
    if (hasStart) this.setDeco(source ? source.attrs : null);
    mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
    return true;
  }
  split(at) {
    let end = new LineView();
    end.breakAfter = this.breakAfter;
    if (this.length == 0) return end;
    let {
      i,
      off
    } = this.childPos(at);
    if (off) {
      end.append(this.children[i].split(off), 0);
      this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
      i++;
    }
    for (let j = i; j < this.children.length; j++) end.append(this.children[j], 0);
    while (i > 0 && this.children[i - 1].length == 0) this.children[--i].destroy();
    this.children.length = i;
    this.markDirty();
    this.length = at;
    return end;
  }
  transferDOM(other) {
    if (!this.dom) return;
    this.markDirty();
    other.setDOM(this.dom);
    other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
    this.prevAttrs = undefined;
    this.dom = null;
  }
  setDeco(attrs) {
    if (!attrsEq(this.attrs, attrs)) {
      if (this.dom) {
        this.prevAttrs = this.attrs;
        this.markDirty();
      }
      this.attrs = attrs;
    }
  }
  append(child, openStart) {
    joinInlineInto(this, child, openStart);
  }
  addLineDeco(deco) {
    let attrs = deco.spec.attributes,
      cls = deco.spec.class;
    if (attrs) this.attrs = combineAttrs(attrs, this.attrs || {});
    if (cls) this.attrs = combineAttrs({
      class: cls
    }, this.attrs || {});
  }
  domAtPos(pos) {
    return inlineDOMAtPos(this, pos);
  }
  reuseDOM(node) {
    if (node.nodeName == "DIV") {
      this.setDOM(node);
      this.flags |= 4 | 2;
    }
  }
  sync(view, track) {
    var _a;
    if (!this.dom) {
      this.setDOM(document.createElement("div"));
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : undefined;
    } else if (this.flags & 4) {
      clearAttributes(this.dom);
      this.dom.className = "cm-line";
      this.prevAttrs = this.attrs ? null : undefined;
    }
    if (this.prevAttrs !== undefined) {
      updateAttrs(this.dom, this.prevAttrs, this.attrs);
      this.dom.classList.add("cm-line");
      this.prevAttrs = undefined;
    }
    super.sync(view, track);
    let last = this.dom.lastChild;
    while (last && ContentView.get(last) instanceof MarkView) last = last.lastChild;
    if (!last || !this.length || last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false && (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
      let hack = document.createElement("BR");
      hack.cmIgnore = true;
      this.dom.appendChild(hack);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20) return null;
    let totalWidth = 0,
      textHeight;
    for (var _iterator8 = _createForOfIteratorHelperLoose(this.children), _step8; !(_step8 = _iterator8()).done;) {
      let child = _step8.value;
      if (!(child instanceof TextView) || /[^ -~]/.test(child.text)) return null;
      let rects = clientRectsFor(child.dom);
      if (rects.length != 1) return null;
      totalWidth += rects[0].width;
      textHeight = rects[0].height;
    }
    return !totalWidth ? null : {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: totalWidth / this.length,
      textHeight
    };
  }
  coordsAt(pos, side) {
    let rect = coordsInChildren(this, pos, side);
    if (!this.children.length && rect && this.parent) {
      let {
          heightOracle
        } = this.parent.view.viewState,
        height = rect.bottom - rect.top;
      if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
        let dist = (height - heightOracle.textHeight) / 2;
        return {
          top: rect.top + dist,
          bottom: rect.bottom - dist,
          left: rect.left,
          right: rect.left
        };
      }
    }
    return rect;
  }
  become(other) {
    return other instanceof LineView && this.children.length == 0 && other.children.length == 0 && attrsEq(this.attrs, other.attrs) && this.breakAfter == other.breakAfter;
  }
  covers() {
    return true;
  }
  static find(docView, pos) {
    for (let i = 0, off = 0; i < docView.children.length; i++) {
      let block = docView.children[i],
        end = off + block.length;
      if (end >= pos) {
        if (block instanceof LineView) return block;
        if (end > pos) break;
      }
      off = end + block.breakAfter;
    }
    return null;
  }
}
class BlockWidgetView extends ContentView {
  constructor(widget, length, deco) {
    super();
    this.widget = widget;
    this.length = length;
    this.deco = deco;
    this.breakAfter = 0;
    this.prevWidget = null;
  }
  merge(from, to, source, _takeDeco, openStart, openEnd) {
    if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) || from > 0 && openStart <= 0 || to < this.length && openEnd <= 0)) return false;
    this.length = from + (source ? source.length : 0) + (this.length - to);
    return true;
  }
  domAtPos(pos) {
    return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
  }
  split(at) {
    let len = this.length - at;
    this.length = at;
    let end = new BlockWidgetView(this.widget, len, this.deco);
    end.breakAfter = this.breakAfter;
    return end;
  }
  get children() {
    return noChildren;
  }
  sync(view) {
    if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
      if (this.dom && this.prevWidget) this.prevWidget.destroy(this.dom);
      this.prevWidget = null;
      this.setDOM(this.widget.toDOM(view));
      if (!this.widget.editable) this.dom.contentEditable = "false";
    }
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : state_dist/* Text */.EY.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(other) {
    if (other instanceof BlockWidgetView && other.widget.constructor == this.widget.constructor) {
      if (!other.widget.compare(this.widget)) this.markDirty(true);
      if (this.dom && !this.prevWidget) this.prevWidget = this.widget;
      this.widget = other.widget;
      this.length = other.length;
      this.deco = other.deco;
      this.breakAfter = other.breakAfter;
      return true;
    }
    return false;
  }
  ignoreMutation() {
    return true;
  }
  ignoreEvent(event) {
    return this.widget.ignoreEvent(event);
  }
  get isEditable() {
    return false;
  }
  get isWidget() {
    return true;
  }
  coordsAt(pos, side) {
    let custom = this.widget.coordsAt(this.dom, pos, side);
    if (custom) return custom;
    if (this.widget instanceof BlockGapWidget) return null;
    return flattenRect(this.dom.getBoundingClientRect(), this.length ? pos == 0 : side <= 0);
  }
  destroy() {
    super.destroy();
    if (this.dom) this.widget.destroy(this.dom);
  }
  covers(side) {
    let {
      startSide,
      endSide
    } = this.deco;
    return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
  }
}
class BlockGapWidget extends WidgetType {
  constructor(height) {
    super();
    this.height = height;
  }
  toDOM() {
    let elt = document.createElement("div");
    elt.className = "cm-gap";
    this.updateDOM(elt);
    return elt;
  }
  eq(other) {
    return other.height == this.height;
  }
  updateDOM(elt) {
    elt.style.height = this.height + "px";
    return true;
  }
  get editable() {
    return true;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return false;
  }
}
class ContentBuilder {
  constructor(doc, pos, end, disallowBlockEffectsFor) {
    this.doc = doc;
    this.pos = pos;
    this.end = end;
    this.disallowBlockEffectsFor = disallowBlockEffectsFor;
    this.content = [];
    this.curLine = null;
    this.breakAtStart = 0;
    this.pendingBuffer = 0;
    this.bufferMarks = [];
    this.atCursorPos = true;
    this.openStart = -1;
    this.openEnd = -1;
    this.text = "";
    this.textOff = 0;
    this.cursor = doc.iter();
    this.skip = pos;
  }
  posCovered() {
    if (this.content.length == 0) return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let last = this.content[this.content.length - 1];
    return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
  }
  getLine() {
    if (!this.curLine) {
      this.content.push(this.curLine = new LineView());
      this.atCursorPos = true;
    }
    return this.curLine;
  }
  flushBuffer(active) {
    if (active === void 0) {
      active = this.bufferMarks;
    }
    if (this.pendingBuffer) {
      this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
      this.pendingBuffer = 0;
    }
  }
  addBlockWidget(view) {
    this.flushBuffer();
    this.curLine = null;
    this.content.push(view);
  }
  finish(openEnd) {
    if (this.pendingBuffer && openEnd <= this.bufferMarks.length) this.flushBuffer();else this.pendingBuffer = 0;
    if (!this.posCovered() && !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView)) this.getLine();
  }
  buildText(length, active, openStart) {
    while (length > 0) {
      if (this.textOff == this.text.length) {
        let {
          value,
          lineBreak,
          done
        } = this.cursor.next(this.skip);
        this.skip = 0;
        if (done) throw new Error("Ran out of text content when drawing inline views");
        if (lineBreak) {
          if (!this.posCovered()) this.getLine();
          if (this.content.length) this.content[this.content.length - 1].breakAfter = 1;else this.breakAtStart = 1;
          this.flushBuffer();
          this.curLine = null;
          this.atCursorPos = true;
          length--;
          continue;
        } else {
          this.text = value;
          this.textOff = 0;
        }
      }
      let take = Math.min(this.text.length - this.textOff, length, 512);
      this.flushBuffer(active.slice(active.length - openStart));
      this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
      this.atCursorPos = true;
      this.textOff += take;
      length -= take;
      openStart = 0;
    }
  }
  span(from, to, active, openStart) {
    this.buildText(to - from, active, openStart);
    this.pos = to;
    if (this.openStart < 0) this.openStart = openStart;
  }
  point(from, to, deco, active, openStart, index) {
    if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
      if (deco.block) throw new RangeError("Block decorations may not be specified via plugins");
      if (to > this.doc.lineAt(this.pos).to) throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let len = to - from;
    if (deco instanceof PointDecoration) {
      if (deco.block) {
        if (deco.startSide > 0 && !this.posCovered()) this.getLine();
        this.addBlockWidget(new BlockWidgetView(deco.widget || NullWidget.block, len, deco));
      } else {
        let view = WidgetView.create(deco.widget || NullWidget.inline, len, len ? 0 : deco.startSide);
        let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length && (from < to || deco.startSide > 0);
        let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
        let line = this.getLine();
        if (this.pendingBuffer == 2 && !cursorBefore && !view.isEditable) this.pendingBuffer = 0;
        this.flushBuffer(active);
        if (cursorBefore) {
          line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
          openStart = active.length + Math.max(0, openStart - active.length);
        }
        line.append(wrapMarks(view, active), openStart);
        this.atCursorPos = cursorAfter;
        this.pendingBuffer = !cursorAfter ? 0 : from < to || openStart > active.length ? 1 : 2;
        if (this.pendingBuffer) this.bufferMarks = active.slice();
      }
    } else if (this.doc.lineAt(this.pos).from == this.pos) {
      this.getLine().addLineDeco(deco);
    }
    if (len) {
      if (this.textOff + len <= this.text.length) {
        this.textOff += len;
      } else {
        this.skip += len - (this.text.length - this.textOff);
        this.text = "";
        this.textOff = 0;
      }
      this.pos = to;
    }
    if (this.openStart < 0) this.openStart = openStart;
  }
  static build(text, from, to, decorations, dynamicDecorationMap) {
    let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
    builder.openEnd = state_dist/* RangeSet */.om.spans(decorations, from, to, builder);
    if (builder.openStart < 0) builder.openStart = builder.openEnd;
    builder.finish(builder.openEnd);
    return builder;
  }
}
function wrapMarks(view, active) {
  for (var _iterator9 = _createForOfIteratorHelperLoose(active), _step9; !(_step9 = _iterator9()).done;) {
    let mark = _step9.value;
    view = new MarkView(mark, [view], view.length);
  }
  return view;
}
class NullWidget extends WidgetType {
  constructor(tag) {
    super();
    this.tag = tag;
  }
  eq(other) {
    return other.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(elt) {
    return elt.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return true;
  }
}
NullWidget.inline = new NullWidget("span");
NullWidget.block = new NullWidget("div");
var Direction = function (Direction) {
  Direction[Direction["LTR"] = 0] = "LTR";
  Direction[Direction["RTL"] = 1] = "RTL";
  return Direction;
}(Direction || (Direction = {}));
const LTR = Direction.LTR,
  RTL = Direction.RTL;
function dec(str) {
  let result = [];
  for (let i = 0; i < str.length; i++) result.push(1 << +str[i]);
  return result;
}
const LowTypes = dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
const ArabicTypes = dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = Object.create(null),
  BracketStack = [];
for (var _i2 = 0, _arr = ["()", "[]", "{}"]; _i2 < _arr.length; _i2++) {
  let p = _arr[_i2];
  let l = p.charCodeAt(0),
    r = p.charCodeAt(1);
  Brackets[l] = r;
  Brackets[r] = -l;
}
function charType(ch) {
  return ch <= 0xf7 ? LowTypes[ch] : 0x590 <= ch && ch <= 0x5f4 ? 2 : 0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] : 0x6ee <= ch && ch <= 0x8ac ? 4 : 0x2000 <= ch && ch <= 0x200c ? 256 : 0xfb50 <= ch && ch <= 0xfdff ? 4 : 1;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class BidiSpan {
  get dir() {
    return this.level % 2 ? RTL : LTR;
  }
  constructor(from, to, level) {
    this.from = from;
    this.to = to;
    this.level = level;
  }
  side(end, dir) {
    return this.dir == dir == end ? this.to : this.from;
  }
  forward(forward, dir) {
    return forward == (this.dir == dir);
  }
  static find(order, index, level, assoc) {
    let maybe = -1;
    for (let i = 0; i < order.length; i++) {
      let span = order[i];
      if (span.from <= index && span.to >= index) {
        if (span.level == level) return i;
        if (maybe < 0 || (assoc != 0 ? assoc < 0 ? span.from < index : span.to > index : order[maybe].level > span.level)) maybe = i;
      }
    }
    if (maybe < 0) throw new RangeError("Index out of range");
    return maybe;
  }
}
function isolatesEq(a, b) {
  if (a.length != b.length) return false;
  for (let i = 0; i < a.length; i++) {
    let iA = a[i],
      iB = b[i];
    if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner)) return false;
  }
  return true;
}
const types = [];
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
  for (let iI = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom,
      to = iI < isolates.length ? isolates[iI].from : rTo;
    let prevType = iI ? 256 : outerType;
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = charType(line.charCodeAt(i));
      if (type == 512) type = prev;else if (type == 8 && prevStrong == 4) type = 16;
      types[i] = type == 4 ? 2 : type;
      if (type & 7) prevStrong = type;
      prev = type;
    }
    for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
      let type = types[i];
      if (type == 128) {
        if (i < to - 1 && prev == types[i + 1] && prev & 24) type = types[i] = prev;else types[i] = 256;
      } else if (type == 64) {
        let end = i + 1;
        while (end < to && types[end] == 64) end++;
        let replace = i && prev == 8 || end < rTo && types[end] == 8 ? prevStrong == 1 ? 1 : 8 : 256;
        for (let j = i; j < end; j++) types[j] = replace;
        i = end - 1;
      } else if (type == 8 && prevStrong == 1) {
        types[i] = 1;
      }
      prev = type;
      if (type & 7) prevStrong = type;
    }
  }
}
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
  let oppositeType = outerType == 1 ? 2 : 1;
  for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom,
      to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from, ch, br, type; i < to; i++) {
      if (br = Brackets[ch = line.charCodeAt(i)]) {
        if (br < 0) {
          for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
            if (BracketStack[sJ + 1] == -br) {
              let flags = BracketStack[sJ + 2];
              let type = flags & 2 ? outerType : !(flags & 4) ? 0 : flags & 1 ? oppositeType : outerType;
              if (type) types[i] = types[BracketStack[sJ]] = type;
              sI = sJ;
              break;
            }
          }
        } else if (BracketStack.length == 189) {
          break;
        } else {
          BracketStack[sI++] = i;
          BracketStack[sI++] = ch;
          BracketStack[sI++] = context;
        }
      } else if ((type = types[i]) == 2 || type == 1) {
        let embed = type == outerType;
        context = embed ? 0 : 1;
        for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
          let cur = BracketStack[sJ + 2];
          if (cur & 2) break;
          if (embed) {
            BracketStack[sJ + 2] |= 2;
          } else {
            if (cur & 4) break;
            BracketStack[sJ + 2] |= 4;
          }
        }
      }
    }
  }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
  for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
    let from = iI ? isolates[iI - 1].to : rFrom,
      to = iI < isolates.length ? isolates[iI].from : rTo;
    for (let i = from; i < to;) {
      let type = types[i];
      if (type == 256) {
        let end = i + 1;
        for (;;) {
          if (end == to) {
            if (iI == isolates.length) break;
            end = isolates[iI++].to;
            to = iI < isolates.length ? isolates[iI].from : rTo;
          } else if (types[end] == 256) {
            end++;
          } else {
            break;
          }
        }
        let beforeL = prev == 1;
        let afterL = (end < rTo ? types[end] : outerType) == 1;
        let replace = beforeL == afterL ? beforeL ? 1 : 2 : outerType;
        for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
          if (j == fromJ) {
            j = isolates[--jI].from;
            fromJ = jI ? isolates[jI - 1].to : rFrom;
          }
          types[--j] = replace;
        }
        i = end;
      } else {
        prev = type;
        i++;
      }
    }
  }
}
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
  let ourType = level % 2 ? 2 : 1;
  if (level % 2 == baseLevel % 2) {
    for (let iCh = from, iI = 0; iCh < to;) {
      let sameDir = true,
        isNum = false;
      if (iI == isolates.length || iCh < isolates[iI].from) {
        let next = types[iCh];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (;;) {
        if (iI < isolates.length && iScan == isolates[iI].from) {
          if (isNum) break run;
          let iso = isolates[iI];
          if (!sameDir) for (let upto = iso.to, jI = iI + 1;;) {
            if (upto == to) break run;
            if (jI < isolates.length && isolates[jI].from == upto) upto = isolates[jI++].to;else if (types[upto] == ourType) break run;else break;
          }
          iI++;
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.from > iCh) order.push(new BidiSpan(iCh, iso.from, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.to;
          }
          iScan = iso.to;
        } else if (iScan == to || (sameDir ? types[iScan] != ourType : types[iScan] == ourType)) {
          break;
        } else {
          iScan++;
        }
      }
      if (recurse) emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);else if (iCh < iScan) order.push(new BidiSpan(iCh, iScan, localLevel));
      iCh = iScan;
    }
  } else {
    for (let iCh = to, iI = isolates.length; iCh > from;) {
      let sameDir = true,
        isNum = false;
      if (!iI || iCh > isolates[iI - 1].to) {
        let next = types[iCh - 1];
        if (next != ourType) {
          sameDir = false;
          isNum = next == 16;
        }
      }
      let recurse = !sameDir && ourType == 1 ? [] : null;
      let localLevel = sameDir ? level : level + 1;
      let iScan = iCh;
      run: for (;;) {
        if (iI && iScan == isolates[iI - 1].to) {
          if (isNum) break run;
          let iso = isolates[--iI];
          if (!sameDir) for (let upto = iso.from, jI = iI;;) {
            if (upto == from) break run;
            if (jI && isolates[jI - 1].to == upto) upto = isolates[--jI].from;else if (types[upto - 1] == ourType) break run;else break;
          }
          if (recurse) {
            recurse.push(iso);
          } else {
            if (iso.to < iCh) order.push(new BidiSpan(iso.to, iCh, localLevel));
            let dirSwap = iso.direction == LTR != !(localLevel % 2);
            computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
            iCh = iso.from;
          }
          iScan = iso.from;
        } else if (iScan == from || (sameDir ? types[iScan - 1] != ourType : types[iScan - 1] == ourType)) {
          break;
        } else {
          iScan--;
        }
      }
      if (recurse) emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);else if (iScan < iCh) order.push(new BidiSpan(iScan, iCh, localLevel));
      iCh = iScan;
    }
  }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
  let outerType = level % 2 ? 2 : 1;
  computeCharTypes(line, from, to, isolates, outerType);
  processBracketPairs(line, from, to, isolates, outerType);
  processNeutrals(from, to, isolates, outerType);
  emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
  if (!line) return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
  if (direction == LTR && !isolates.length && !BidiRE.test(line)) return trivialOrder(line.length);
  if (isolates.length) while (line.length > types.length) types[types.length] = 256;
  let order = [],
    level = direction == LTR ? 0 : 1;
  computeSectionOrder(line, level, level, isolates, 0, line.length, order);
  return order;
}
function trivialOrder(length) {
  return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
  var _a;
  let startIndex = start.head - line.from;
  let spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
  let span = order[spanI],
    spanEnd = span.side(forward, dir);
  if (startIndex == spanEnd) {
    let nextI = spanI += forward ? 1 : -1;
    if (nextI < 0 || nextI >= order.length) return null;
    span = order[spanI = nextI];
    startIndex = span.side(!forward, dir);
    spanEnd = span.side(forward, dir);
  }
  let nextIndex = (0,state_dist/* findClusterBreak */.zK)(line.text, startIndex, span.forward(forward, dir));
  if (nextIndex < span.from || nextIndex > span.to) nextIndex = spanEnd;
  movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
  let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
  if (nextSpan && nextIndex == spanEnd && nextSpan.level + (forward ? 0 : 1) < span.level) return state_dist/* EditorSelection */.OF.cursor(nextSpan.side(!forward, dir) + line.from, nextSpan.forward(forward, dir) ? 1 : -1, nextSpan.level);
  return state_dist/* EditorSelection */.OF.cursor(nextIndex + line.from, span.forward(forward, dir) ? -1 : 1, span.level);
}
function autoDirection(text, from, to) {
  for (let i = from; i < to; i++) {
    let type = charType(text.charCodeAt(i));
    if (type == 1) return LTR;
    if (type == 2 || type == 4) return RTL;
  }
  return LTR;
}
const clickAddsSelectionRange = state_dist/* Facet */.sj.define();
const dragMovesSelection$1 = state_dist/* Facet */.sj.define();
const mouseSelectionStyle = state_dist/* Facet */.sj.define();
const exceptionSink = state_dist/* Facet */.sj.define();
const updateListener = state_dist/* Facet */.sj.define();
const inputHandler = state_dist/* Facet */.sj.define();
const focusChangeEffect = state_dist/* Facet */.sj.define();
const clipboardInputFilter = state_dist/* Facet */.sj.define();
const clipboardOutputFilter = state_dist/* Facet */.sj.define();
const perLineTextDirection = state_dist/* Facet */.sj.define({
  combine: values => values.some(x => x)
});
const nativeSelectionHidden = state_dist/* Facet */.sj.define({
  combine: values => values.some(x => x)
});
const scrollHandler = state_dist/* Facet */.sj.define();
class ScrollTarget {
  constructor(range, y, x, yMargin, xMargin, isSnapshot) {
    if (y === void 0) {
      y = "nearest";
    }
    if (x === void 0) {
      x = "nearest";
    }
    if (yMargin === void 0) {
      yMargin = 5;
    }
    if (xMargin === void 0) {
      xMargin = 5;
    }
    if (isSnapshot === void 0) {
      isSnapshot = false;
    }
    this.range = range;
    this.y = y;
    this.x = x;
    this.yMargin = yMargin;
    this.xMargin = xMargin;
    this.isSnapshot = isSnapshot;
  }
  map(changes) {
    return changes.empty ? this : new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(state) {
    return this.range.to <= state.doc.length ? this : new ScrollTarget(state_dist/* EditorSelection */.OF.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const scrollIntoView = state_dist/* StateEffect */.Pe.define({
  map: (t, ch) => t.map(ch)
});
const setEditContextFormatting = state_dist/* StateEffect */.Pe.define();
function logException(state, exception, context) {
  let handler = state.facet(exceptionSink);
  if (handler.length) handler[0](exception);else if (window.onerror) window.onerror(String(exception), context, undefined, undefined, exception);else if (context) console.error(context + ":", exception);else console.error(exception);
}
const editable = state_dist/* Facet */.sj.define({
  combine: values => values.length ? values[0] : true
});
let nextPluginID = 0;
const viewPlugin = state_dist/* Facet */.sj.define();
class ViewPlugin {
  constructor(id, create, domEventHandlers, domEventObservers, buildExtensions) {
    this.id = id;
    this.create = create;
    this.domEventHandlers = domEventHandlers;
    this.domEventObservers = domEventObservers;
    this.extension = buildExtensions(this);
  }
  static define(create, spec) {
    const {
      eventHandlers,
      eventObservers,
      provide,
      decorations: deco
    } = spec || {};
    return new ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin => {
      let ext = [viewPlugin.of(plugin)];
      if (deco) ext.push(decorations.of(view => {
        let pluginInst = view.plugin(plugin);
        return pluginInst ? deco(pluginInst) : Decoration.none;
      }));
      if (provide) ext.push(provide(plugin));
      return ext;
    });
  }
  static fromClass(cls, spec) {
    return ViewPlugin.define(view => new cls(view), spec);
  }
}
class PluginInstance {
  constructor(spec) {
    this.spec = spec;
    this.mustUpdate = null;
    this.value = null;
  }
  update(view) {
    if (!this.value) {
      if (this.spec) {
        try {
          this.value = this.spec.create(view);
        } catch (e) {
          logException(view.state, e, "CodeMirror plugin crashed");
          this.deactivate();
        }
      }
    } else if (this.mustUpdate) {
      let update = this.mustUpdate;
      this.mustUpdate = null;
      if (this.value.update) {
        try {
          this.value.update(update);
        } catch (e) {
          logException(update.state, e, "CodeMirror plugin crashed");
          if (this.value.destroy) try {
            this.value.destroy();
          } catch (_) {}
          this.deactivate();
        }
      }
    }
    return this;
  }
  destroy(view) {
    var _a;
    if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
      try {
        this.value.destroy();
      } catch (e) {
        logException(view.state, e, "CodeMirror plugin crashed");
      }
    }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const editorAttributes = state_dist/* Facet */.sj.define();
const contentAttributes = state_dist/* Facet */.sj.define();
const decorations = state_dist/* Facet */.sj.define();
const outerDecorations = state_dist/* Facet */.sj.define();
const atomicRanges = state_dist/* Facet */.sj.define();
const bidiIsolatedRanges = state_dist/* Facet */.sj.define();
function getIsolatedRanges(view, line) {
  let isolates = view.state.facet(bidiIsolatedRanges);
  if (!isolates.length) return isolates;
  let sets = isolates.map(i => i instanceof Function ? i(view) : i);
  let result = [];
  state_dist/* RangeSet */.om.spans(sets, line.from, line.to, {
    point() {},
    span(fromDoc, toDoc, active, open) {
      let from = fromDoc - line.from,
        to = toDoc - line.from;
      let level = result;
      for (let i = active.length - 1; i >= 0; i--, open--) {
        let direction = active[i].spec.bidiIsolate,
          update;
        if (direction == null) direction = autoDirection(line.text, from, to);
        if (open > 0 && level.length && (update = level[level.length - 1]).to == from && update.direction == direction) {
          update.to = to;
          level = update.inner;
        } else {
          let add = {
            from,
            to,
            direction,
            inner: []
          };
          level.push(add);
          level = add.inner;
        }
      }
    }
  });
  return result;
}
const scrollMargins = state_dist/* Facet */.sj.define();
function getScrollMargins(view) {
  let left = 0,
    right = 0,
    top = 0,
    bottom = 0;
  for (var _iterator10 = _createForOfIteratorHelperLoose(view.state.facet(scrollMargins)), _step10; !(_step10 = _iterator10()).done;) {
    let source = _step10.value;
    let m = source(view);
    if (m) {
      if (m.left != null) left = Math.max(left, m.left);
      if (m.right != null) right = Math.max(right, m.right);
      if (m.top != null) top = Math.max(top, m.top);
      if (m.bottom != null) bottom = Math.max(bottom, m.bottom);
    }
  }
  return {
    left,
    right,
    top,
    bottom
  };
}
const styleModule = state_dist/* Facet */.sj.define();
class ChangedRange {
  constructor(fromA, toA, fromB, toB) {
    this.fromA = fromA;
    this.toA = toA;
    this.fromB = fromB;
    this.toB = toB;
  }
  join(other) {
    return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
  }
  addToSet(set) {
    let i = set.length,
      me = this;
    for (; i > 0; i--) {
      let range = set[i - 1];
      if (range.fromA > me.toA) continue;
      if (range.toA < me.fromA) break;
      me = me.join(range);
      set.splice(i - 1, 1);
    }
    set.splice(i, 0, me);
    return set;
  }
  static extendWithRanges(diff, ranges) {
    if (ranges.length == 0) return diff;
    let result = [];
    for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
      let next = dI == diff.length ? null : diff[dI],
        off = posA - posB;
      let end = next ? next.fromB : 1e9;
      while (rI < ranges.length && ranges[rI] < end) {
        let from = ranges[rI],
          to = ranges[rI + 1];
        let fromB = Math.max(posB, from),
          toB = Math.min(end, to);
        if (fromB <= toB) new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
        if (to > end) break;else rI += 2;
      }
      if (!next) return result;
      new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
      posA = next.toA;
      posB = next.toB;
    }
  }
}
class ViewUpdate {
  constructor(view, state, transactions) {
    this.view = view;
    this.state = state;
    this.transactions = transactions;
    this.flags = 0;
    this.startState = view.state;
    this.changes = state_dist/* ChangeSet */.VR.empty(this.startState.doc.length);
    for (var _iterator11 = _createForOfIteratorHelperLoose(transactions), _step11; !(_step11 = _iterator11()).done;) {
      let tr = _step11.value;
      this.changes = this.changes.compose(tr.changes);
    }
    let changedRanges = [];
    this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
    this.changedRanges = changedRanges;
  }
  static create(view, state, transactions) {
    return new ViewUpdate(view, state, transactions);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get viewportMoved() {
    return (this.flags & 8) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & (16 | 2)) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some(tr => tr.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class DocView extends ContentView {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(view) {
    super();
    this.view = view;
    this.decorations = [];
    this.dynamicDecorationMap = [false];
    this.domChanged = null;
    this.hasComposition = null;
    this.markedForComposition = new Set();
    this.editContextFormatting = Decoration.none;
    this.lastCompositionAfterCursor = false;
    this.minWidth = 0;
    this.minWidthFrom = 0;
    this.minWidthTo = 0;
    this.impreciseAnchor = null;
    this.impreciseHead = null;
    this.forceSelection = false;
    this.lastUpdate = Date.now();
    this.setDOM(view.contentDOM);
    this.children = [new LineView()];
    this.children[0].setParent(this);
    this.updateDeco();
    this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
  }
  update(update) {
    var _a;
    let changedRanges = update.changedRanges;
    if (this.minWidth > 0 && changedRanges.length) {
      if (!changedRanges.every(_ref => {
        let {
          fromA,
          toA
        } = _ref;
        return toA < this.minWidthFrom || fromA > this.minWidthTo;
      })) {
        this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
      } else {
        this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
        this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
      }
    }
    this.updateEditContextFormatting(update);
    let readCompositionAt = -1;
    if (this.view.inputState.composing >= 0 && !this.view.observer.editContext) {
      if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel) readCompositionAt = this.domChanged.newSel.head;else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet) readCompositionAt = update.state.selection.main.head;
    }
    let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
    this.domChanged = null;
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let {
        from,
        to
      } = this.hasComposition;
      changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1)).addToSet(changedRanges.slice());
    }
    this.hasComposition = composition ? {
      from: composition.range.fromB,
      to: composition.range.toB
    } : null;
    if ((browser.ie || browser.chrome) && !composition && update && update.state.doc.lines != update.startState.doc.lines) this.forceSelection = true;
    let prevDeco = this.decorations,
      deco = this.updateDeco();
    let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
    changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
    if (!(this.flags & 7) && changedRanges.length == 0) {
      return false;
    } else {
      this.updateInner(changedRanges, update.startState.doc.length, composition);
      if (update.transactions.length) this.lastUpdate = Date.now();
      return true;
    }
  }
  updateInner(changes, oldLength, composition) {
    this.view.viewState.mustMeasureContent = true;
    this.updateChildren(changes, oldLength, composition);
    let {
      observer
    } = this.view;
    observer.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
      this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let track = browser.chrome || browser.ios ? {
        node: observer.selectionRange.focusNode,
        written: false
      } : undefined;
      this.sync(this.view, track);
      this.flags &= ~7;
      if (track && (track.written || observer.selectionRange.focusNode != track.node)) this.forceSelection = true;
      this.dom.style.height = "";
    });
    this.markedForComposition.forEach(cView => cView.flags &= ~8);
    let gaps = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length) {
      for (var _iterator12 = _createForOfIteratorHelperLoose(this.children), _step12; !(_step12 = _iterator12()).done;) {
        let child = _step12.value;
        if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget) gaps.push(child.dom);
      }
    }
    observer.updateGaps(gaps);
  }
  updateChildren(changes, oldLength, composition) {
    let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
    let cursor = this.childCursor(oldLength);
    for (let i = ranges.length - 1;; i--) {
      let next = i >= 0 ? ranges[i] : null;
      if (!next) break;
      let {
          fromA,
          toA,
          fromB,
          toB
        } = next,
        content,
        breakAtStart,
        openStart,
        openEnd;
      if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
        let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
        let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
        breakAtStart = before.breakAtStart;
        openStart = before.openStart;
        openEnd = after.openEnd;
        let compLine = this.compositionView(composition);
        if (after.breakAtStart) {
          compLine.breakAfter = 1;
        } else if (after.content.length && compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
          compLine.breakAfter = after.content[0].breakAfter;
          after.content.shift();
        }
        if (before.content.length && compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
          before.content.pop();
        }
        content = before.content.concat(compLine).concat(after.content);
      } else {
        ({
          content,
          breakAtStart,
          openStart,
          openEnd
        } = ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
      }
      let {
        i: toI,
        off: toOff
      } = cursor.findPos(toA, 1);
      let {
        i: fromI,
        off: fromOff
      } = cursor.findPos(fromA, -1);
      replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
    }
    if (composition) this.fixCompositionDOM(composition);
  }
  updateEditContextFormatting(update) {
    this.editContextFormatting = this.editContextFormatting.map(update.changes);
    for (var _iterator13 = _createForOfIteratorHelperLoose(update.transactions), _step13; !(_step13 = _iterator13()).done;) {
      let tr = _step13.value;
      for (var _iterator14 = _createForOfIteratorHelperLoose(tr.effects), _step14; !(_step14 = _iterator14()).done;) {
        let effect = _step14.value;
        if (effect.is(setEditContextFormatting)) {
          this.editContextFormatting = effect.value;
        }
      }
    }
  }
  compositionView(composition) {
    let cur = new TextView(composition.text.nodeValue);
    cur.flags |= 8;
    for (var _iterator15 = _createForOfIteratorHelperLoose(composition.marks), _step15; !(_step15 = _iterator15()).done;) {
      let {
        deco
      } = _step15.value;
      cur = new MarkView(deco, [cur], cur.length);
    }
    let line = new LineView();
    line.append(cur, 0);
    return line;
  }
  fixCompositionDOM(composition) {
    let fix = (dom, cView) => {
      cView.flags |= 8 | (cView.children.some(c => c.flags & 7) ? 1 : 0);
      this.markedForComposition.add(cView);
      let prev = ContentView.get(dom);
      if (prev && prev != cView) prev.dom = null;
      cView.setDOM(dom);
    };
    let pos = this.childPos(composition.range.fromB, 1);
    let cView = this.children[pos.i];
    fix(composition.line, cView);
    for (let i = composition.marks.length - 1; i >= -1; i--) {
      pos = cView.childPos(pos.off, 1);
      cView = cView.children[pos.i];
      fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
    }
  }
  updateSelection(mustRead, fromPointer) {
    if (mustRead === void 0) {
      mustRead = false;
    }
    if (fromPointer === void 0) {
      fromPointer = false;
    }
    if (mustRead || !this.view.observer.selectionRange.focusNode) this.view.observer.readSelectionRange();
    let activeElt = this.view.root.activeElement,
      focused = activeElt == this.dom;
    let selectionNotFocus = !focused && !(this.view.state.facet(editable) || this.dom.tabIndex > -1) && hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
    if (!(focused || fromPointer || selectionNotFocus)) return;
    let force = this.forceSelection;
    this.forceSelection = false;
    let main = this.view.state.selection.main;
    let anchor = this.moveToLine(this.domAtPos(main.anchor));
    let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
    if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
      let dummy = document.createTextNode("");
      this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
      anchor = head = new DOMPos(dummy, 0);
      force = true;
    }
    let domSel = this.view.observer.selectionRange;
    if (force || !domSel.focusNode || (!isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) || !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) && !this.suppressWidgetCursorChange(domSel, main)) {
      this.view.observer.ignore(() => {
        if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) && inUneditable(domSel.focusNode, this.dom)) {
          this.dom.blur();
          this.dom.focus({
            preventScroll: true
          });
        }
        let rawSel = getSelection(this.view.root);
        if (!rawSel) ;else if (main.empty) {
          if (browser.gecko) {
            let nextTo = nextToUneditable(anchor.node, anchor.offset);
            if (nextTo && nextTo != (1 | 2)) {
              let text = (nextTo == 1 ? textNodeBefore : textNodeAfter)(anchor.node, anchor.offset);
              if (text) anchor = new DOMPos(text.node, text.offset);
            }
          }
          rawSel.collapse(anchor.node, anchor.offset);
          if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined) rawSel.caretBidiLevel = main.bidiLevel;
        } else if (rawSel.extend) {
          rawSel.collapse(anchor.node, anchor.offset);
          try {
            rawSel.extend(head.node, head.offset);
          } catch (_) {}
        } else {
          let range = document.createRange();
          if (main.anchor > main.head) [anchor, head] = [head, anchor];
          range.setEnd(head.node, head.offset);
          range.setStart(anchor.node, anchor.offset);
          rawSel.removeAllRanges();
          rawSel.addRange(range);
        }
        if (selectionNotFocus && this.view.root.activeElement == this.dom) {
          this.dom.blur();
          if (activeElt) activeElt.focus();
        }
      });
      this.view.observer.setSelectionRange(anchor, head);
    }
    this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
    this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
  }
  suppressWidgetCursorChange(sel, cursor) {
    return this.hasComposition && cursor.empty && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset) && this.posFromDOM(sel.focusNode, sel.focusOffset) == cursor.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition) return;
    let {
        view
      } = this,
      cursor = view.state.selection.main;
    let sel = getSelection(view.root);
    let {
      anchorNode,
      anchorOffset
    } = view.observer.selectionRange;
    if (!sel || !cursor.empty || !cursor.assoc || !sel.modify) return;
    let line = LineView.find(this, cursor.head);
    if (!line) return;
    let lineStart = line.posAtStart;
    if (cursor.head == lineStart || cursor.head == lineStart + line.length) return;
    let before = this.coordsAt(cursor.head, -1),
      after = this.coordsAt(cursor.head, 1);
    if (!before || !after || before.bottom > after.top) return;
    let dom = this.domAtPos(cursor.head + cursor.assoc);
    sel.collapse(dom.node, dom.offset);
    sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
    view.observer.readSelectionRange();
    let newRange = view.observer.selectionRange;
    if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from) sel.collapse(anchorNode, anchorOffset);
  }
  moveToLine(pos) {
    let dom = this.dom,
      newPos;
    if (pos.node != dom) return pos;
    for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
      let view = ContentView.get(dom.childNodes[i]);
      if (view instanceof LineView) newPos = view.domAtPos(0);
    }
    for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
      let view = ContentView.get(dom.childNodes[i]);
      if (view instanceof LineView) newPos = view.domAtPos(view.length);
    }
    return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
  }
  nearest(dom) {
    for (let cur = dom; cur;) {
      let domView = ContentView.get(cur);
      if (domView && domView.rootView == this) return domView;
      cur = cur.parentNode;
    }
    return null;
  }
  posFromDOM(node, offset) {
    let view = this.nearest(node);
    if (!view) throw new RangeError("Trying to find position for a DOM position outside of the document");
    return view.localPosFromDOM(node, offset) + view.posAtStart;
  }
  domAtPos(pos) {
    let {
      i,
      off
    } = this.childCursor().findPos(pos, -1);
    for (; i < this.children.length - 1;) {
      let child = this.children[i];
      if (off < child.length || child instanceof LineView) break;
      i++;
      off = 0;
    }
    return this.children[i].domAtPos(off);
  }
  coordsAt(pos, side) {
    let best = null,
      bestPos = 0;
    for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
      let child = this.children[i],
        end = off - child.breakAfter,
        start = end - child.length;
      if (end < pos) break;
      if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) && (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
        best = child;
        bestPos = start;
      } else if (best && start == pos && end == pos && child instanceof BlockWidgetView && Math.abs(side) < 2) {
        if (child.deco.startSide < 0) break;else if (i) best = null;
      }
      off = start;
    }
    return best ? best.coordsAt(pos - bestPos, side) : null;
  }
  coordsForChar(pos) {
    let {
        i,
        off
      } = this.childPos(pos, 1),
      child = this.children[i];
    if (!(child instanceof LineView)) return null;
    while (child.children.length) {
      let {
        i,
        off: childOff
      } = child.childPos(off, 1);
      for (;; i++) {
        if (i == child.children.length) return null;
        if ((child = child.children[i]).length) break;
      }
      off = childOff;
    }
    if (!(child instanceof TextView)) return null;
    let end = (0,state_dist/* findClusterBreak */.zK)(child.text, off);
    if (end == off) return null;
    let rects = textRange(child.dom, off, end).getClientRects();
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right) return rect;
    }
    return null;
  }
  measureVisibleLineHeights(viewport) {
    let result = [],
      {
        from,
        to
      } = viewport;
    let contentWidth = this.view.contentDOM.clientWidth;
    let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
    let widest = -1,
      ltr = this.view.textDirection == Direction.LTR;
    for (let pos = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i],
        end = pos + child.length;
      if (end > to) break;
      if (pos >= from) {
        let childRect = child.dom.getBoundingClientRect();
        result.push(childRect.height);
        if (isWider) {
          let last = child.dom.lastChild;
          let rects = last ? clientRectsFor(last) : [];
          if (rects.length) {
            let rect = rects[rects.length - 1];
            let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
            if (width > widest) {
              widest = width;
              this.minWidth = contentWidth;
              this.minWidthFrom = pos;
              this.minWidthTo = end;
            }
          }
        }
      }
      pos = end + child.breakAfter;
    }
    return result;
  }
  textDirectionAt(pos) {
    let {
      i
    } = this.childPos(pos, 1);
    return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
  }
  measureTextSize() {
    for (var _iterator16 = _createForOfIteratorHelperLoose(this.children), _step16; !(_step16 = _iterator16()).done;) {
      let child = _step16.value;
      if (child instanceof LineView) {
        let measure = child.measureTextSize();
        if (measure) return measure;
      }
    }
    let dummy = document.createElement("div"),
      lineHeight,
      charWidth,
      textHeight;
    dummy.className = "cm-line";
    dummy.style.width = "99999px";
    dummy.style.position = "absolute";
    dummy.textContent = "abc def ghi jkl mno pqr stu";
    this.view.observer.ignore(() => {
      this.dom.appendChild(dummy);
      let rect = clientRectsFor(dummy.firstChild)[0];
      lineHeight = dummy.getBoundingClientRect().height;
      charWidth = rect ? rect.width / 27 : 7;
      textHeight = rect ? rect.height : lineHeight;
      dummy.remove();
    });
    return {
      lineHeight,
      charWidth,
      textHeight
    };
  }
  childCursor(pos) {
    if (pos === void 0) {
      pos = this.length;
    }
    let i = this.children.length;
    if (i) pos -= this.children[--i].length;
    return new ChildCursor(this.children, pos, i);
  }
  computeBlockGapDeco() {
    let deco = [],
      vs = this.view.viewState;
    for (let pos = 0, i = 0;; i++) {
      let next = i == vs.viewports.length ? null : vs.viewports[i];
      let end = next ? next.from - 1 : this.length;
      if (end > pos) {
        let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
        deco.push(Decoration.replace({
          widget: new BlockGapWidget(height),
          block: true,
          inclusive: true,
          isBlockGap: true
        }).range(pos, end));
      }
      if (!next) break;
      pos = next.to + 1;
    }
    return Decoration.set(deco);
  }
  updateDeco() {
    let i = 1;
    let allDeco = this.view.state.facet(decorations).map(d => {
      let dynamic = this.dynamicDecorationMap[i++] = typeof d == "function";
      return dynamic ? d(this.view) : d;
    });
    let dynamicOuter = false,
      outerDeco = this.view.state.facet(outerDecorations).map((d, i) => {
        let dynamic = typeof d == "function";
        if (dynamic) dynamicOuter = true;
        return dynamic ? d(this.view) : d;
      });
    if (outerDeco.length) {
      this.dynamicDecorationMap[i++] = dynamicOuter;
      allDeco.push(state_dist/* RangeSet */.om.join(outerDeco));
    }
    this.decorations = [this.editContextFormatting, ...allDeco, this.computeBlockGapDeco(), this.view.viewState.lineGapDeco];
    while (i < this.decorations.length) this.dynamicDecorationMap[i++] = false;
    return this.decorations;
  }
  scrollIntoView(target) {
    if (target.isSnapshot) {
      let ref = this.view.viewState.lineBlockAt(target.range.head);
      this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
      this.view.scrollDOM.scrollLeft = target.xMargin;
      return;
    }
    for (var _iterator17 = _createForOfIteratorHelperLoose(this.view.state.facet(scrollHandler)), _step17; !(_step17 = _iterator17()).done;) {
      let handler = _step17.value;
      try {
        if (handler(this.view, target.range, target)) return true;
      } catch (e) {
        logException(this.view.state, e, "scroll handler");
      }
    }
    let {
      range
    } = target;
    let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1),
      other;
    if (!rect) return;
    if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1))) rect = {
      left: Math.min(rect.left, other.left),
      top: Math.min(rect.top, other.top),
      right: Math.max(rect.right, other.right),
      bottom: Math.max(rect.bottom, other.bottom)
    };
    let margins = getScrollMargins(this.view);
    let targetRect = {
      left: rect.left - margins.left,
      top: rect.top - margins.top,
      right: rect.right + margins.right,
      bottom: rect.bottom + margins.bottom
    };
    let {
      offsetWidth,
      offsetHeight
    } = this.view.scrollDOM;
    scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
  }
}
function betweenUneditable(pos) {
  return pos.node.nodeType == 1 && pos.node.firstChild && (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") && (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
function findCompositionNode(view, headPos) {
  let sel = view.observer.selectionRange;
  if (!sel.focusNode) return null;
  let textBefore = textNodeBefore(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter(sel.focusNode, sel.focusOffset);
  let textNode = textBefore || textAfter;
  if (textAfter && textBefore && textAfter.node != textBefore.node) {
    let descAfter = ContentView.get(textAfter.node);
    if (!descAfter || descAfter instanceof TextView && descAfter.text != textAfter.node.nodeValue) {
      textNode = textAfter;
    } else if (view.docView.lastCompositionAfterCursor) {
      let descBefore = ContentView.get(textBefore.node);
      if (!(!descBefore || descBefore instanceof TextView && descBefore.text != textBefore.node.nodeValue)) textNode = textAfter;
    }
  }
  view.docView.lastCompositionAfterCursor = textNode != textBefore;
  if (!textNode) return null;
  let from = headPos - textNode.offset;
  return {
    from,
    to: from + textNode.node.nodeValue.length,
    node: textNode.node
  };
}
function findCompositionRange(view, changes, headPos) {
  let found = findCompositionNode(view, headPos);
  if (!found) return null;
  let {
      node: textNode,
      from,
      to
    } = found,
    text = textNode.nodeValue;
  if (/[\n\r]/.test(text)) return null;
  if (view.state.doc.sliceString(found.from, found.to) != text) return null;
  let inv = changes.invertedDesc;
  let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
  let marks = [];
  for (let parent = textNode.parentNode;; parent = parent.parentNode) {
    let parentView = ContentView.get(parent);
    if (parentView instanceof MarkView) marks.push({
      node: parent,
      deco: parentView.mark
    });else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM) return {
      range,
      text: textNode,
      marks,
      line: parent
    };else if (parent != view.contentDOM) marks.push({
      node: parent,
      deco: new MarkDecoration({
        inclusive: true,
        attributes: getAttrs(parent),
        tagName: parent.tagName.toLowerCase()
      })
    });else return null;
  }
}
function nextToUneditable(node, offset) {
  if (node.nodeType != 1) return 0;
  return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 : 0) | (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 : 0);
}
let DecorationComparator$1 = class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange(from, to) {
    addRange(from, to, this.changes);
  }
  comparePoint(from, to) {
    addRange(from, to, this.changes);
  }
  boundChange(pos) {
    addRange(pos, pos, this.changes);
  }
};
function findChangedDeco(a, b, diff) {
  let comp = new DecorationComparator$1();
  state_dist/* RangeSet */.om.compare(a, b, diff, comp);
  return comp.changes;
}
function inUneditable(node, inside) {
  for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
    if (cur.nodeType == 1 && cur.contentEditable == 'false') {
      return true;
    }
  }
  return false;
}
function touchesComposition(changes, composition) {
  let touched = false;
  if (composition) changes.iterChangedRanges((from, to) => {
    if (from < composition.to && to > composition.from) touched = true;
  });
  return touched;
}
function groupAt(state, pos, bias) {
  if (bias === void 0) {
    bias = 1;
  }
  let categorize = state.charCategorizer(pos);
  let line = state.doc.lineAt(pos),
    linePos = pos - line.from;
  if (line.length == 0) return state_dist/* EditorSelection */.OF.cursor(pos);
  if (linePos == 0) bias = 1;else if (linePos == line.length) bias = -1;
  let from = linePos,
    to = linePos;
  if (bias < 0) from = (0,state_dist/* findClusterBreak */.zK)(line.text, linePos, false);else to = (0,state_dist/* findClusterBreak */.zK)(line.text, linePos);
  let cat = categorize(line.text.slice(from, to));
  while (from > 0) {
    let prev = (0,state_dist/* findClusterBreak */.zK)(line.text, from, false);
    if (categorize(line.text.slice(prev, from)) != cat) break;
    from = prev;
  }
  while (to < line.length) {
    let next = (0,state_dist/* findClusterBreak */.zK)(line.text, to);
    if (categorize(line.text.slice(to, next)) != cat) break;
    to = next;
  }
  return state_dist/* EditorSelection */.OF.range(from + line.from, to + line.from);
}
function getdx(x, rect) {
  return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
  return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
  return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
  return top < rect.top ? {
    top,
    left: rect.left,
    right: rect.right,
    bottom: rect.bottom
  } : rect;
}
function upBot(rect, bottom) {
  return bottom > rect.bottom ? {
    top: rect.top,
    left: rect.left,
    right: rect.right,
    bottom
  } : rect;
}
function domPosAtCoords(parent, x, y) {
  let closest,
    closestRect,
    closestX,
    closestY,
    closestOverlap = false;
  let above, below, aboveRect, belowRect;
  for (let child = parent.firstChild; child; child = child.nextSibling) {
    let rects = clientRectsFor(child);
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (closestRect && yOverlap(closestRect, rect)) rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
      let dx = getdx(x, rect),
        dy = getdy(y, rect);
      if (dx == 0 && dy == 0) return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
      if (!closest || closestY > dy || closestY == dy && closestX > dx) {
        closest = child;
        closestRect = rect;
        closestX = dx;
        closestY = dy;
        let side = dy ? y < rect.top ? -1 : 1 : dx ? x < rect.left ? -1 : 1 : 0;
        closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
      }
      if (dx == 0) {
        if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
          above = child;
          aboveRect = rect;
        } else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
          below = child;
          belowRect = rect;
        }
      } else if (aboveRect && yOverlap(aboveRect, rect)) {
        aboveRect = upBot(aboveRect, rect.bottom);
      } else if (belowRect && yOverlap(belowRect, rect)) {
        belowRect = upTop(belowRect, rect.top);
      }
    }
  }
  if (aboveRect && aboveRect.bottom >= y) {
    closest = above;
    closestRect = aboveRect;
  } else if (belowRect && belowRect.top <= y) {
    closest = below;
    closestRect = belowRect;
  }
  if (!closest) return {
    node: parent,
    offset: 0
  };
  let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
  if (closest.nodeType == 3) return domPosInText(closest, clipX, y);
  if (closestOverlap && closest.contentEditable != "false") return domPosAtCoords(closest, clipX, y);
  let offset = Array.prototype.indexOf.call(parent.childNodes, closest) + (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
  return {
    node: parent,
    offset
  };
}
function domPosInText(node, x, y) {
  let len = node.nodeValue.length;
  let closestOffset = -1,
    closestDY = 1e9,
    generalSide = 0;
  for (let i = 0; i < len; i++) {
    let rects = textRange(node, i, i + 1).getClientRects();
    for (let j = 0; j < rects.length; j++) {
      let rect = rects[j];
      if (rect.top == rect.bottom) continue;
      if (!generalSide) generalSide = x - rect.left;
      let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
      if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
        let right = x >= (rect.left + rect.right) / 2,
          after = right;
        if (browser.chrome || browser.gecko) {
          let rectBefore = textRange(node, i).getBoundingClientRect();
          if (rectBefore.left == rect.right) after = !right;
        }
        if (dy <= 0) return {
          node,
          offset: i + (after ? 1 : 0)
        };
        closestOffset = i + (after ? 1 : 0);
        closestDY = dy;
      }
    }
  }
  return {
    node,
    offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0
  };
}
function posAtCoords(view, coords, precise, bias) {
  if (bias === void 0) {
    bias = -1;
  }
  var _a, _b;
  let content = view.contentDOM.getBoundingClientRect(),
    docTop = content.top + view.viewState.paddingTop;
  let block,
    {
      docHeight
    } = view.viewState;
  let {
      x,
      y
    } = coords,
    yOffset = y - docTop;
  if (yOffset < 0) return 0;
  if (yOffset > docHeight) return view.state.doc.length;
  for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
    block = view.elementAtHeight(yOffset);
    if (block.type == BlockType.Text) break;
    for (;;) {
      yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
      if (yOffset >= 0 && yOffset <= docHeight) break;
      if (bounced) return precise ? null : 0;
      bounced = true;
      bias = -bias;
    }
  }
  y = docTop + yOffset;
  let lineStart = block.from;
  if (lineStart < view.viewport.from) return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
  if (lineStart > view.viewport.to) return view.viewport.to == view.state.doc.length ? view.state.doc.length : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
  let doc = view.dom.ownerDocument;
  let root = view.root.elementFromPoint ? view.root : doc;
  let element = root.elementFromPoint(x, y);
  if (element && !view.contentDOM.contains(element)) element = null;
  if (!element) {
    x = Math.max(content.left + 1, Math.min(content.right - 1, x));
    element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element)) element = null;
  }
  let node,
    offset = -1;
  if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
    if (doc.caretPositionFromPoint) {
      let pos = doc.caretPositionFromPoint(x, y);
      if (pos) ({
        offsetNode: node,
        offset
      } = pos);
    } else if (doc.caretRangeFromPoint) {
      let range = doc.caretRangeFromPoint(x, y);
      if (range) {
        ({
          startContainer: node,
          startOffset: offset
        } = range);
        if (!view.contentDOM.contains(node) || browser.safari && isSuspiciousSafariCaretResult(node, offset, x) || browser.chrome && isSuspiciousChromeCaretResult(node, offset, x)) node = undefined;
      }
    }
    if (node) offset = Math.min(maxOffset(node), offset);
  }
  if (!node || !view.docView.dom.contains(node)) {
    let line = LineView.find(view.docView, lineStart);
    if (!line) return yOffset > block.top + block.height / 2 ? block.to : block.from;
    ({
      node,
      offset
    } = domPosAtCoords(line.dom, x, y));
  }
  let nearest = view.docView.nearest(node);
  if (!nearest) return null;
  if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
    let rect = nearest.dom.getBoundingClientRect();
    return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2 ? nearest.posAtStart : nearest.posAtEnd;
  } else {
    return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
  }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
  let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
  if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
    let textHeight = view.viewState.heightOracle.textHeight;
    let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
    into += line * view.viewState.heightOracle.lineLength;
  }
  let content = view.state.sliceDoc(block.from, block.to);
  return block.from + (0,state_dist/* findColumn */.kn)(content, into, view.state.tabSize);
}
function isSuspiciousSafariCaretResult(node, offset, x) {
  let len;
  if (node.nodeType != 3 || offset != (len = node.nodeValue.length)) return false;
  for (let next = node.nextSibling; next; next = next.nextSibling) if (next.nodeType != 1 || next.nodeName != "BR") return false;
  return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
function isSuspiciousChromeCaretResult(node, offset, x) {
  if (offset != 0) return false;
  for (let cur = node;;) {
    let parent = cur.parentNode;
    if (!parent || parent.nodeType != 1 || parent.firstChild != cur) return false;
    if (parent.classList.contains("cm-line")) break;
    cur = parent;
  }
  let rect = node.nodeType == 1 ? node.getBoundingClientRect() : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
  return x - rect.left > 5;
}
function blockAt(view, pos) {
  let line = view.lineBlockAt(pos);
  if (Array.isArray(line.type)) {
    for (var _iterator18 = _createForOfIteratorHelperLoose(line.type), _step18; !(_step18 = _iterator18()).done;) {
      let l = _step18.value;
      if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text)) return l;
    }
  }
  return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
  let line = blockAt(view, start.head);
  let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
  if (coords) {
    let editorRect = view.dom.getBoundingClientRect();
    let direction = view.textDirectionAt(line.from);
    let pos = view.posAtCoords({
      x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
      y: (coords.top + coords.bottom) / 2
    });
    if (pos != null) return state_dist/* EditorSelection */.OF.cursor(pos, forward ? -1 : 1);
  }
  return state_dist/* EditorSelection */.OF.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
  let line = view.state.doc.lineAt(start.head),
    spans = view.bidiSpans(line);
  let direction = view.textDirectionAt(line.from);
  for (let cur = start, check = null;;) {
    let next = moveVisually(line, spans, direction, cur, forward),
      char = movedOver;
    if (!next) {
      if (line.number == (forward ? view.state.doc.lines : 1)) return cur;
      char = "\n";
      line = view.state.doc.line(line.number + (forward ? 1 : -1));
      spans = view.bidiSpans(line);
      next = view.visualLineSide(line, !forward);
    }
    if (!check) {
      if (!by) return next;
      check = by(char);
    } else if (!check(char)) {
      return cur;
    }
    cur = next;
  }
}
function byGroup(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start);
  return next => {
    let nextCat = categorize(next);
    if (cat == state_dist/* CharCategory */.Je.Space) cat = nextCat;
    return cat == nextCat;
  };
}
function moveVertically(view, start, forward, distance) {
  let startPos = start.head,
    dir = forward ? 1 : -1;
  if (startPos == (forward ? view.state.doc.length : 0)) return state_dist/* EditorSelection */.OF.cursor(startPos, start.assoc);
  let goal = start.goalColumn,
    startY;
  let rect = view.contentDOM.getBoundingClientRect();
  let startCoords = view.coordsAtPos(startPos, start.assoc || -1),
    docTop = view.documentTop;
  if (startCoords) {
    if (goal == null) goal = startCoords.left - rect.left;
    startY = dir < 0 ? startCoords.top : startCoords.bottom;
  } else {
    let line = view.viewState.lineBlockAt(startPos);
    if (goal == null) goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
    startY = (dir < 0 ? line.top : line.bottom) + docTop;
  }
  let resolvedGoal = rect.left + goal;
  let dist = distance !== null && distance !== void 0 ? distance : view.viewState.heightOracle.textHeight >> 1;
  for (let extra = 0;; extra += 10) {
    let curY = startY + (dist + extra) * dir;
    let pos = posAtCoords(view, {
      x: resolvedGoal,
      y: curY
    }, false, dir);
    if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
      let charRect = view.docView.coordsForChar(pos);
      let assoc = !charRect || curY < charRect.top ? -1 : 1;
      return state_dist/* EditorSelection */.OF.cursor(pos, assoc, undefined, goal);
    }
  }
}
function skipAtomicRanges(atoms, pos, bias) {
  for (;;) {
    let moved = 0;
    for (var _iterator19 = _createForOfIteratorHelperLoose(atoms), _step19; !(_step19 = _iterator19()).done;) {
      let set = _step19.value;
      set.between(pos - 1, pos + 1, (from, to, value) => {
        if (pos > from && pos < to) {
          let side = moved || bias || (pos - from < to - pos ? -1 : 1);
          pos = side < 0 ? from : to;
          moved = side;
        }
      });
    }
    if (!moved) return pos;
  }
}
function skipAtoms(view, oldPos, pos) {
  let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
  return newPos == pos.from ? pos : state_dist/* EditorSelection */.OF.cursor(newPos, newPos < pos.from ? 1 : -1);
}
const LineBreakPlaceholder = "\uffff";
class DOMReader {
  constructor(points, state) {
    this.points = points;
    this.text = "";
    this.lineSeparator = state.facet(state_dist/* EditorState */.$t.lineSeparator);
  }
  append(text) {
    this.text += text;
  }
  lineBreak() {
    this.text += LineBreakPlaceholder;
  }
  readRange(start, end) {
    if (!start) return this;
    let parent = start.parentNode;
    for (let cur = start;;) {
      this.findPointBefore(parent, cur);
      let oldLen = this.text.length;
      this.readNode(cur);
      let next = cur.nextSibling;
      if (next == end) break;
      let view = ContentView.get(cur),
        nextView = ContentView.get(next);
      if (view && nextView ? view.breakAfter : (view ? view.breakAfter : isBlockElement(cur)) || isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen) this.lineBreak();
      cur = next;
    }
    this.findPointBefore(parent, end);
    return this;
  }
  readTextNode(node) {
    let text = node.nodeValue;
    for (var _iterator20 = _createForOfIteratorHelperLoose(this.points), _step20; !(_step20 = _iterator20()).done;) {
      let point = _step20.value;
      if (point.node == node) point.pos = this.text.length + Math.min(point.offset, text.length);
    }
    for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
      let nextBreak = -1,
        breakSize = 1,
        m;
      if (this.lineSeparator) {
        nextBreak = text.indexOf(this.lineSeparator, off);
        breakSize = this.lineSeparator.length;
      } else if (m = re.exec(text)) {
        nextBreak = m.index;
        breakSize = m[0].length;
      }
      this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
      if (nextBreak < 0) break;
      this.lineBreak();
      if (breakSize > 1) {
        for (var _iterator21 = _createForOfIteratorHelperLoose(this.points), _step21; !(_step21 = _iterator21()).done;) {
          let point = _step21.value;
          if (point.node == node && point.pos > this.text.length) point.pos -= breakSize - 1;
        }
      }
      off = nextBreak + breakSize;
    }
  }
  readNode(node) {
    if (node.cmIgnore) return;
    let view = ContentView.get(node);
    let fromView = view && view.overrideDOMText;
    if (fromView != null) {
      this.findPointInside(node, fromView.length);
      for (let i = fromView.iter(); !i.next().done;) {
        if (i.lineBreak) this.lineBreak();else this.append(i.value);
      }
    } else if (node.nodeType == 3) {
      this.readTextNode(node);
    } else if (node.nodeName == "BR") {
      if (node.nextSibling) this.lineBreak();
    } else if (node.nodeType == 1) {
      this.readRange(node.firstChild, null);
    }
  }
  findPointBefore(node, next) {
    for (var _iterator22 = _createForOfIteratorHelperLoose(this.points), _step22; !(_step22 = _iterator22()).done;) {
      let point = _step22.value;
      if (point.node == node && node.childNodes[point.offset] == next) point.pos = this.text.length;
    }
  }
  findPointInside(node, length) {
    for (var _iterator23 = _createForOfIteratorHelperLoose(this.points), _step23; !(_step23 = _iterator23()).done;) {
      let point = _step23.value;
      if (node.nodeType == 3 ? point.node == node : node.contains(point.node)) point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
  }
}
function isAtEnd(parent, node, offset) {
  for (;;) {
    if (!node || offset < maxOffset(node)) return false;
    if (node == parent) return true;
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
}
class DOMPoint {
  constructor(node, offset) {
    this.node = node;
    this.offset = offset;
    this.pos = -1;
  }
}
class DOMChange {
  constructor(view, start, end, typeOver) {
    this.typeOver = typeOver;
    this.bounds = null;
    this.text = "";
    this.domChanged = start > -1;
    let {
      impreciseHead: iHead,
      impreciseAnchor: iAnchor
    } = view.docView;
    if (view.state.readOnly && start > -1) {
      this.newSel = null;
    } else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
      let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
      let reader = new DOMReader(selPoints, view.state);
      reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
      this.text = reader.text;
      this.newSel = selectionFromPoints(selPoints, this.bounds.from);
    } else {
      let domSel = view.observer.selectionRange;
      let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset || !contains(view.contentDOM, domSel.focusNode) ? view.state.selection.main.head : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
      let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset || !contains(view.contentDOM, domSel.anchorNode) ? view.state.selection.main.anchor : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
      let vp = view.viewport;
      if ((browser.ios || browser.chrome) && view.state.selection.main.empty && head != anchor && (vp.from > 0 || vp.to < view.state.doc.length)) {
        let from = Math.min(head, anchor),
          to = Math.max(head, anchor);
        let offFrom = vp.from - from,
          offTo = vp.to - to;
        if ((offFrom == 0 || offFrom == 1 || from == 0) && (offTo == 0 || offTo == -1 || to == view.state.doc.length)) {
          head = 0;
          anchor = view.state.doc.length;
        }
      }
      this.newSel = state_dist/* EditorSelection */.OF.single(anchor, head);
    }
  }
}
function applyDOMChange(view, domChange) {
  let change;
  let {
      newSel
    } = domChange,
    sel = view.state.selection.main;
  let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
  if (domChange.bounds) {
    let {
      from,
      to
    } = domChange.bounds;
    let preferredPos = sel.from,
      preferredSide = null;
    if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
      preferredPos = sel.to;
      preferredSide = "end";
    }
    let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
    if (diff) {
      if (browser.chrome && lastKey == 13 && diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder) diff.toB--;
      change = {
        from: from + diff.from,
        to: from + diff.toA,
        insert: state_dist/* Text */.EY.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder))
      };
    }
  } else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
    newSel = null;
  }
  if (!change && !newSel) return false;
  if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, sel.to)
    };
  } else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 && /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
    if (newSel && change.insert.length == 2) newSel = state_dist/* EditorSelection */.OF.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = {
      from: change.from,
      to: change.to,
      insert: state_dist/* Text */.EY.of([change.insert.toString().replace(".", " ")])
    };
  } else if (change && change.from >= sel.from && change.to <= sel.to && (change.from != sel.from || change.to != sel.to) && sel.to - sel.from - (change.to - change.from) <= 4) {
    change = {
      from: sel.from,
      to: sel.to,
      insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
    };
  } else if (browser.chrome && change && change.from == change.to && change.from == sel.head && change.insert.toString() == "\n " && view.lineWrapping) {
    if (newSel) newSel = state_dist/* EditorSelection */.OF.single(newSel.main.anchor - 1, newSel.main.head - 1);
    change = {
      from: sel.from,
      to: sel.to,
      insert: state_dist/* Text */.EY.of([" "])
    };
  }
  if (change) {
    return applyDOMChangeInner(view, change, newSel, lastKey);
  } else if (newSel && !newSel.main.eq(sel)) {
    let scrollIntoView = false,
      userEvent = "select";
    if (view.inputState.lastSelectionTime > Date.now() - 50) {
      if (view.inputState.lastSelectionOrigin == "select") scrollIntoView = true;
      userEvent = view.inputState.lastSelectionOrigin;
    }
    view.dispatch({
      selection: newSel,
      scrollIntoView,
      userEvent
    });
    return true;
  } else {
    return false;
  }
}
function applyDOMChangeInner(view, change, newSel, lastKey) {
  if (lastKey === void 0) {
    lastKey = -1;
  }
  if (browser.ios && view.inputState.flushIOSKey(change)) return true;
  let sel = view.state.selection.main;
  if (browser.android && (change.to == sel.to && (change.from == sel.from || change.from == sel.from - 1 && view.state.sliceDoc(change.from, sel.from) == " ") && change.insert.length == 1 && change.insert.lines == 2 && dispatchKey(view.contentDOM, "Enter", 13) || (change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 || lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) && dispatchKey(view.contentDOM, "Backspace", 8) || change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 && dispatchKey(view.contentDOM, "Delete", 46))) return true;
  let text = change.insert.toString();
  if (view.inputState.composing >= 0) view.inputState.composing++;
  let defaultTr;
  let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
  if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert))) view.dispatch(defaultInsert());
  return true;
}
function applyDefaultInsert(view, change, newSel) {
  let tr,
    startState = view.state,
    sel = startState.selection.main;
  if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 && (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) && view.inputState.composing < 0) {
    let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
    let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
    tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
  } else {
    let changes = startState.changes(change);
    let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
    if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 && change.to <= sel.to && change.to >= sel.to - 10) {
      let replaced = view.state.sliceDoc(change.from, change.to);
      let compositionRange,
        composition = newSel && findCompositionNode(view, newSel.main.head);
      if (composition) {
        let dLen = change.insert.length - (change.to - change.from);
        compositionRange = {
          from: composition.from,
          to: composition.to - dLen
        };
      } else {
        compositionRange = view.state.doc.lineAt(sel.head);
      }
      let offset = sel.to - change.to,
        size = sel.to - sel.from;
      tr = startState.changeByRange(range => {
        if (range.from == sel.from && range.to == sel.to) return {
          changes,
          range: mainSel || range.map(changes)
        };
        let to = range.to - offset,
          from = to - replaced.length;
        if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced || range.to >= compositionRange.from && range.from <= compositionRange.to) return {
          range
        };
        let rangeChanges = startState.changes({
            from,
            to,
            insert: change.insert
          }),
          selOff = range.to - sel.to;
        return {
          changes: rangeChanges,
          range: !mainSel ? range.map(rangeChanges) : state_dist/* EditorSelection */.OF.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
        };
      });
    } else {
      tr = {
        changes,
        selection: mainSel && startState.selection.replaceRange(mainSel)
      };
    }
  }
  let userEvent = "input.type";
  if (view.composing || view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
    view.inputState.compositionPendingChange = false;
    userEvent += ".compose";
    if (view.inputState.compositionFirstChange) {
      userEvent += ".start";
      view.inputState.compositionFirstChange = false;
    }
  }
  return startState.update(tr, {
    userEvent,
    scrollIntoView: true
  });
}
function findDiff(a, b, preferredPos, preferredSide) {
  let minLen = Math.min(a.length, b.length);
  let from = 0;
  while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from)) from++;
  if (from == minLen && a.length == b.length) return null;
  let toA = a.length,
    toB = b.length;
  while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
    toA--;
    toB--;
  }
  if (preferredSide == "end") {
    let adjust = Math.max(0, from - Math.min(toA, toB));
    preferredPos -= toA + adjust - from;
  }
  if (toA < from && a.length < b.length) {
    let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
    from -= move;
    toB = from + (toB - toA);
    toA = from;
  } else if (toB < from) {
    let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
    from -= move;
    toA = from + (toA - toB);
    toB = from;
  }
  return {
    from,
    toA,
    toB
  };
}
function selectionPoints(view) {
  let result = [];
  if (view.root.activeElement != view.contentDOM) return result;
  let {
    anchorNode,
    anchorOffset,
    focusNode,
    focusOffset
  } = view.observer.selectionRange;
  if (anchorNode) {
    result.push(new DOMPoint(anchorNode, anchorOffset));
    if (focusNode != anchorNode || focusOffset != anchorOffset) result.push(new DOMPoint(focusNode, focusOffset));
  }
  return result;
}
function selectionFromPoints(points, base) {
  if (points.length == 0) return null;
  let anchor = points[0].pos,
    head = points.length == 2 ? points[1].pos : anchor;
  return anchor > -1 && head > -1 ? state_dist/* EditorSelection */.OF.single(anchor + base, head + base) : null;
}
class InputState {
  setSelectionOrigin(origin) {
    this.lastSelectionOrigin = origin;
    this.lastSelectionTime = Date.now();
  }
  constructor(view) {
    this.view = view;
    this.lastKeyCode = 0;
    this.lastKeyTime = 0;
    this.lastTouchTime = 0;
    this.lastFocusTime = 0;
    this.lastScrollTop = 0;
    this.lastScrollLeft = 0;
    this.pendingIOSKey = undefined;
    this.tabFocusMode = -1;
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastContextMenu = 0;
    this.scrollHandlers = [];
    this.handlers = Object.create(null);
    this.composing = -1;
    this.compositionFirstChange = null;
    this.compositionEndedAt = 0;
    this.compositionPendingKey = false;
    this.compositionPendingChange = false;
    this.mouseSelection = null;
    this.draggedContent = null;
    this.handleEvent = this.handleEvent.bind(this);
    this.notifiedFocused = view.hasFocus;
    if (browser.safari) view.contentDOM.addEventListener("input", () => null);
    if (browser.gecko) firefoxCopyCutHack(view.contentDOM.ownerDocument);
  }
  handleEvent(event) {
    if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event)) return;
    if (event.type == "keydown" && this.keydown(event)) return;
    if (this.view.updateState != 0) Promise.resolve().then(() => this.runHandlers(event.type, event));else this.runHandlers(event.type, event);
  }
  runHandlers(type, event) {
    let handlers = this.handlers[type];
    if (handlers) {
      for (var _iterator24 = _createForOfIteratorHelperLoose(handlers.observers), _step24; !(_step24 = _iterator24()).done;) {
        let observer = _step24.value;
        observer(this.view, event);
      }
      for (var _iterator25 = _createForOfIteratorHelperLoose(handlers.handlers), _step25; !(_step25 = _iterator25()).done;) {
        let handler = _step25.value;
        if (event.defaultPrevented) break;
        if (handler(this.view, event)) {
          event.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(plugins) {
    let handlers = computeHandlers(plugins),
      prev = this.handlers,
      dom = this.view.contentDOM;
    for (let type in handlers) if (type != "scroll") {
      let passive = !handlers[type].handlers.length;
      let exists = prev[type];
      if (exists && passive != !exists.handlers.length) {
        dom.removeEventListener(type, this.handleEvent);
        exists = null;
      }
      if (!exists) dom.addEventListener(type, this.handleEvent, {
        passive
      });
    }
    for (let type in prev) if (type != "scroll" && !handlers[type]) dom.removeEventListener(type, this.handleEvent);
    this.handlers = handlers;
  }
  keydown(event) {
    this.lastKeyCode = event.keyCode;
    this.lastKeyTime = Date.now();
    if (event.keyCode == 9 && this.tabFocusMode > -1 && (!this.tabFocusMode || Date.now() <= this.tabFocusMode)) return true;
    if (this.tabFocusMode > 0 && event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0) this.tabFocusMode = -1;
    if (browser.android && browser.chrome && !event.synthetic && (event.keyCode == 13 || event.keyCode == 8)) {
      this.view.observer.delayAndroidKey(event.key, event.keyCode);
      return true;
    }
    let pending;
    if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey && ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey || EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
      this.pendingIOSKey = pending || event;
      setTimeout(() => this.flushIOSKey(), 250);
      return true;
    }
    if (event.keyCode != 229) this.view.observer.forceFlush();
    return false;
  }
  flushIOSKey(change) {
    let key = this.pendingIOSKey;
    if (!key) return false;
    if (key.key == "Enter" && change && change.from < change.to && /^\S+$/.test(change.insert.toString())) return false;
    this.pendingIOSKey = undefined;
    return dispatchKey(this.view.contentDOM, key.key, key.keyCode, key instanceof KeyboardEvent ? key : undefined);
  }
  ignoreDuringComposition(event) {
    if (!/^key/.test(event.type)) return false;
    if (this.composing > 0) return true;
    if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
      this.compositionPendingKey = false;
      return true;
    }
    return false;
  }
  startMouseSelection(mouseSelection) {
    if (this.mouseSelection) this.mouseSelection.destroy();
    this.mouseSelection = mouseSelection;
  }
  update(update) {
    this.view.observer.update(update);
    if (this.mouseSelection) this.mouseSelection.update(update);
    if (this.draggedContent && update.docChanged) this.draggedContent = this.draggedContent.map(update.changes);
    if (update.transactions.length) this.lastKeyCode = this.lastSelectionTime = 0;
  }
  destroy() {
    if (this.mouseSelection) this.mouseSelection.destroy();
  }
}
function bindHandler(plugin, handler) {
  return (view, event) => {
    try {
      return handler.call(plugin, event, view);
    } catch (e) {
      logException(view.state, e);
    }
  };
}
function computeHandlers(plugins) {
  let result = Object.create(null);
  function record(type) {
    return result[type] || (result[type] = {
      observers: [],
      handlers: []
    });
  }
  for (var _iterator26 = _createForOfIteratorHelperLoose(plugins), _step26; !(_step26 = _iterator26()).done;) {
    let plugin = _step26.value;
    let spec = plugin.spec;
    if (spec && spec.domEventHandlers) for (let type in spec.domEventHandlers) {
      let f = spec.domEventHandlers[type];
      if (f) record(type).handlers.push(bindHandler(plugin.value, f));
    }
    if (spec && spec.domEventObservers) for (let type in spec.domEventObservers) {
      let f = spec.domEventObservers[type];
      if (f) record(type).observers.push(bindHandler(plugin.value, f));
    }
  }
  for (let type in handlers) record(type).handlers.push(handlers[type]);
  for (let type in observers) record(type).observers.push(observers[type]);
  return result;
}
const PendingKeys = [{
  key: "Backspace",
  keyCode: 8,
  inputType: "deleteContentBackward"
}, {
  key: "Enter",
  keyCode: 13,
  inputType: "insertParagraph"
}, {
  key: "Enter",
  keyCode: 13,
  inputType: "insertLineBreak"
}, {
  key: "Delete",
  keyCode: 46,
  inputType: "deleteContentForward"
}];
const EmacsyPendingKeys = "dthko";
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist) {
  return Math.max(0, dist) * 0.7 + 8;
}
function dist(a, b) {
  return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
  constructor(view, startEvent, style, mustSelect) {
    this.view = view;
    this.startEvent = startEvent;
    this.style = style;
    this.mustSelect = mustSelect;
    this.scrollSpeed = {
      x: 0,
      y: 0
    };
    this.scrolling = -1;
    this.lastEvent = startEvent;
    this.scrollParents = scrollableParents(view.contentDOM);
    this.atoms = view.state.facet(atomicRanges).map(f => f(view));
    let doc = view.contentDOM.ownerDocument;
    doc.addEventListener("mousemove", this.move = this.move.bind(this));
    doc.addEventListener("mouseup", this.up = this.up.bind(this));
    this.extend = startEvent.shiftKey;
    this.multiple = view.state.facet(state_dist/* EditorState */.$t.allowMultipleSelections) && addsSelectionRange(view, startEvent);
    this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
  }
  start(event) {
    if (this.dragging === false) this.select(event);
  }
  move(event) {
    if (event.buttons == 0) return this.destroy();
    if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10) return;
    this.select(this.lastEvent = event);
    let sx = 0,
      sy = 0;
    let left = 0,
      top = 0,
      right = this.view.win.innerWidth,
      bottom = this.view.win.innerHeight;
    if (this.scrollParents.x) ({
      left,
      right
    } = this.scrollParents.x.getBoundingClientRect());
    if (this.scrollParents.y) ({
      top,
      bottom
    } = this.scrollParents.y.getBoundingClientRect());
    let margins = getScrollMargins(this.view);
    if (event.clientX - margins.left <= left + dragScrollMargin) sx = -dragScrollSpeed(left - event.clientX);else if (event.clientX + margins.right >= right - dragScrollMargin) sx = dragScrollSpeed(event.clientX - right);
    if (event.clientY - margins.top <= top + dragScrollMargin) sy = -dragScrollSpeed(top - event.clientY);else if (event.clientY + margins.bottom >= bottom - dragScrollMargin) sy = dragScrollSpeed(event.clientY - bottom);
    this.setScrollSpeed(sx, sy);
  }
  up(event) {
    if (this.dragging == null) this.select(this.lastEvent);
    if (!this.dragging) event.preventDefault();
    this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let doc = this.view.contentDOM.ownerDocument;
    doc.removeEventListener("mousemove", this.move);
    doc.removeEventListener("mouseup", this.up);
    this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(sx, sy) {
    this.scrollSpeed = {
      x: sx,
      y: sy
    };
    if (sx || sy) {
      if (this.scrolling < 0) this.scrolling = setInterval(() => this.scroll(), 50);
    } else if (this.scrolling > -1) {
      clearInterval(this.scrolling);
      this.scrolling = -1;
    }
  }
  scroll() {
    let {
      x,
      y
    } = this.scrollSpeed;
    if (x && this.scrollParents.x) {
      this.scrollParents.x.scrollLeft += x;
      x = 0;
    }
    if (y && this.scrollParents.y) {
      this.scrollParents.y.scrollTop += y;
      y = 0;
    }
    if (x || y) this.view.win.scrollBy(x, y);
    if (this.dragging === false) this.select(this.lastEvent);
  }
  skipAtoms(sel) {
    let ranges = null;
    for (let i = 0; i < sel.ranges.length; i++) {
      let range = sel.ranges[i],
        updated = null;
      if (range.empty) {
        let pos = skipAtomicRanges(this.atoms, range.from, 0);
        if (pos != range.from) updated = state_dist/* EditorSelection */.OF.cursor(pos, -1);
      } else {
        let from = skipAtomicRanges(this.atoms, range.from, -1);
        let to = skipAtomicRanges(this.atoms, range.to, 1);
        if (from != range.from || to != range.to) updated = state_dist/* EditorSelection */.OF.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
      }
      if (updated) {
        if (!ranges) ranges = sel.ranges.slice();
        ranges[i] = updated;
      }
    }
    return ranges ? state_dist/* EditorSelection */.OF.create(ranges, sel.mainIndex) : sel;
  }
  select(event) {
    let {
        view
      } = this,
      selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
    if (this.mustSelect || !selection.eq(view.state.selection, this.dragging === false)) this.view.dispatch({
      selection,
      userEvent: "select.pointer"
    });
    this.mustSelect = false;
  }
  update(update) {
    if (update.transactions.some(tr => tr.isUserEvent("input.type"))) this.destroy();else if (this.style.update(update)) setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function addsSelectionRange(view, event) {
  let facet = view.state.facet(clickAddsSelectionRange);
  return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
  let facet = view.state.facet(dragMovesSelection$1);
  return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
  let {
    main
  } = view.state.selection;
  if (main.empty) return false;
  let sel = getSelection(view.root);
  if (!sel || sel.rangeCount == 0) return true;
  let rects = sel.getRangeAt(0).getClientRects();
  for (let i = 0; i < rects.length; i++) {
    let rect = rects[i];
    if (rect.left <= event.clientX && rect.right >= event.clientX && rect.top <= event.clientY && rect.bottom >= event.clientY) return true;
  }
  return false;
}
function eventBelongsToEditor(view, event) {
  if (!event.bubbles) return true;
  if (event.defaultPrevented) return false;
  for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode) if (!node || node.nodeType == 11 || (cView = ContentView.get(node)) && cView.ignoreEvent(event)) return false;
  return true;
}
const handlers = Object.create(null);
const observers = Object.create(null);
const brokenClipboardAPI = browser.ie && browser.ie_version < 15 || browser.ios && browser.webkit_version < 604;
function capturePaste(view) {
  let parent = view.dom.parentNode;
  if (!parent) return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(() => {
    view.focus();
    target.remove();
    doPaste(view, target.value);
  }, 50);
}
function textFilter(state, facet, text) {
  for (var _iterator27 = _createForOfIteratorHelperLoose(state.facet(facet)), _step27; !(_step27 = _iterator27()).done;) {
    let filter = _step27.value;
    text = filter(text, state);
  }
  return text;
}
function doPaste(view, input) {
  input = textFilter(view.state, clipboardInputFilter, input);
  let {
      state
    } = view,
    changes,
    i = 1,
    text = state.toText(input);
  let byLine = text.lines == state.selection.ranges.length;
  let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
  if (linewise) {
    let lastLine = -1;
    changes = state.changeByRange(range => {
      let line = state.doc.lineAt(range.from);
      if (line.from == lastLine) return {
        range
      };
      lastLine = line.from;
      let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
      return {
        changes: {
          from: line.from,
          insert
        },
        range: state_dist/* EditorSelection */.OF.cursor(range.from + insert.length)
      };
    });
  } else if (byLine) {
    changes = state.changeByRange(range => {
      let line = text.line(i++);
      return {
        changes: {
          from: range.from,
          to: range.to,
          insert: line.text
        },
        range: state_dist/* EditorSelection */.OF.cursor(range.from + line.length)
      };
    });
  } else {
    changes = state.replaceSelection(text);
  }
  view.dispatch(changes, {
    userEvent: "input.paste",
    scrollIntoView: true
  });
}
observers.scroll = view => {
  view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
  view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
  view.inputState.setSelectionOrigin("select");
  if (event.keyCode == 27 && view.inputState.tabFocusMode != 0) view.inputState.tabFocusMode = Date.now() + 2000;
  return false;
};
observers.touchstart = (view, e) => {
  view.inputState.lastTouchTime = Date.now();
  view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = view => {
  view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
  view.observer.flush();
  if (view.inputState.lastTouchTime > Date.now() - 2000) return false;
  let style = null;
  for (var _iterator28 = _createForOfIteratorHelperLoose(view.state.facet(mouseSelectionStyle)), _step28; !(_step28 = _iterator28()).done;) {
    let makeStyle = _step28.value;
    style = makeStyle(view, event);
    if (style) break;
  }
  if (!style && event.button == 0) style = basicMouseSelection(view, event);
  if (style) {
    let mustFocus = !view.hasFocus;
    view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
    if (mustFocus) view.observer.ignore(() => {
      focusPreventScroll(view.contentDOM);
      let active = view.root.activeElement;
      if (active && !active.contains(view.contentDOM)) active.blur();
    });
    let mouseSel = view.inputState.mouseSelection;
    if (mouseSel) {
      mouseSel.start(event);
      return mouseSel.dragging === false;
    }
  }
  return false;
};
function rangeForClick(view, pos, bias, type) {
  if (type == 1) {
    return state_dist/* EditorSelection */.OF.cursor(pos, bias);
  } else if (type == 2) {
    return groupAt(view.state, pos, bias);
  } else {
    let visual = LineView.find(view.docView, pos),
      line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
    let from = visual ? visual.posAtStart : line.from,
      to = visual ? visual.posAtEnd : line.to;
    if (to < view.state.doc.length && to == line.to) to++;
    return state_dist/* EditorSelection */.OF.range(from, to);
  }
}
let inside = (x, y, rect) => y >= rect.top && y <= rect.bottom && x >= rect.left && x <= rect.right;
function findPositionSide(view, pos, x, y) {
  let line = LineView.find(view.docView, pos);
  if (!line) return 1;
  let off = pos - line.posAtStart;
  if (off == 0) return 1;
  if (off == line.length) return -1;
  let before = line.coordsAt(off, -1);
  if (before && inside(x, y, before)) return -1;
  let after = line.coordsAt(off, 1);
  if (after && inside(x, y, after)) return 1;
  return before && before.bottom >= y ? -1 : 1;
}
function queryPos(view, event) {
  let pos = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  return {
    pos,
    bias: findPositionSide(view, pos, event.clientX, event.clientY)
  };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null,
  lastMouseDownCount = 0,
  lastMouseDownTime = 0;
function getClickType(event) {
  if (!BadMouseDetail) return event.detail;
  let last = lastMouseDown,
    lastTime = lastMouseDownTime;
  lastMouseDown = event;
  lastMouseDownTime = Date.now();
  return lastMouseDownCount = !last || lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 && Math.abs(last.clientY - event.clientY) < 2 ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
  let start = queryPos(view, event),
    type = getClickType(event);
  let startSel = view.state.selection;
  return {
    update(update) {
      if (update.docChanged) {
        start.pos = update.changes.mapPos(start.pos);
        startSel = startSel.map(update.changes);
      }
    },
    get(event, extend, multiple) {
      let cur = queryPos(view, event),
        removed;
      let range = rangeForClick(view, cur.pos, cur.bias, type);
      if (start.pos != cur.pos && !extend) {
        let startRange = rangeForClick(view, start.pos, start.bias, type);
        let from = Math.min(startRange.from, range.from),
          to = Math.max(startRange.to, range.to);
        range = from < range.from ? state_dist/* EditorSelection */.OF.range(from, to) : state_dist/* EditorSelection */.OF.range(to, from);
      }
      if (extend) return startSel.replaceRange(startSel.main.extend(range.from, range.to));else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos))) return removed;else if (multiple) return startSel.addRange(range);else return state_dist/* EditorSelection */.OF.create([range]);
    }
  };
}
function removeRangeAround(sel, pos) {
  for (let i = 0; i < sel.ranges.length; i++) {
    let {
      from,
      to
    } = sel.ranges[i];
    if (from <= pos && to >= pos) return state_dist/* EditorSelection */.OF.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
  }
  return null;
}
handlers.dragstart = (view, event) => {
  let {
    selection: {
      main: range
    }
  } = view.state;
  if (event.target.draggable) {
    let cView = view.docView.nearest(event.target);
    if (cView && cView.isWidget) {
      let from = cView.posAtStart,
        to = from + cView.length;
      if (from >= range.to || to <= range.from) range = state_dist/* EditorSelection */.OF.range(from, to);
    }
  }
  let {
    inputState
  } = view;
  if (inputState.mouseSelection) inputState.mouseSelection.dragging = true;
  inputState.draggedContent = range;
  if (event.dataTransfer) {
    event.dataTransfer.setData("Text", textFilter(view.state, clipboardOutputFilter, view.state.sliceDoc(range.from, range.to)));
    event.dataTransfer.effectAllowed = "copyMove";
  }
  return false;
};
handlers.dragend = view => {
  view.inputState.draggedContent = null;
  return false;
};
function dropText(view, event, text, direct) {
  text = textFilter(view.state, clipboardInputFilter, text);
  if (!text) return;
  let dropPos = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  let {
    draggedContent
  } = view.inputState;
  let del = direct && draggedContent && dragMovesSelection(view, event) ? {
    from: draggedContent.from,
    to: draggedContent.to
  } : null;
  let ins = {
    from: dropPos,
    insert: text
  };
  let changes = view.state.changes(del ? [del, ins] : ins);
  view.focus();
  view.dispatch({
    changes,
    selection: {
      anchor: changes.mapPos(dropPos, -1),
      head: changes.mapPos(dropPos, 1)
    },
    userEvent: del ? "move.drop" : "input.drop"
  });
  view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
  if (!event.dataTransfer) return false;
  if (view.state.readOnly) return true;
  let files = event.dataTransfer.files;
  if (files && files.length) {
    let text = Array(files.length),
      read = 0;
    let finishFile = () => {
      if (++read == files.length) dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
    };
    for (let i = 0; i < files.length; i++) {
      let reader = new FileReader();
      reader.onerror = finishFile;
      reader.onload = () => {
        if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result)) text[i] = reader.result;
        finishFile();
      };
      reader.readAsText(files[i]);
    }
    return true;
  } else {
    let text = event.dataTransfer.getData("Text");
    if (text) {
      dropText(view, event, text, true);
      return true;
    }
  }
  return false;
};
handlers.paste = (view, event) => {
  if (view.state.readOnly) return true;
  view.observer.flush();
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    doPaste(view, data.getData("text/plain") || data.getData("text/uri-list"));
    return true;
  } else {
    capturePaste(view);
    return false;
  }
};
function captureCopy(view, text) {
  let parent = view.dom.parentNode;
  if (!parent) return;
  let target = parent.appendChild(document.createElement("textarea"));
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.value = text;
  target.focus();
  target.selectionEnd = text.length;
  target.selectionStart = 0;
  setTimeout(() => {
    target.remove();
    view.focus();
  }, 50);
}
function copiedRange(state) {
  let content = [],
    ranges = [],
    linewise = false;
  for (var _iterator29 = _createForOfIteratorHelperLoose(state.selection.ranges), _step29; !(_step29 = _iterator29()).done;) {
    let range = _step29.value;
    if (!range.empty) {
      content.push(state.sliceDoc(range.from, range.to));
      ranges.push(range);
    }
  }
  if (!content.length) {
    let upto = -1;
    for (var _iterator30 = _createForOfIteratorHelperLoose(state.selection.ranges), _step30; !(_step30 = _iterator30()).done;) {
      let {
        from
      } = _step30.value;
      let line = state.doc.lineAt(from);
      if (line.number > upto) {
        content.push(line.text);
        ranges.push({
          from: line.from,
          to: Math.min(state.doc.length, line.to + 1)
        });
      }
      upto = line.number;
    }
    linewise = true;
  }
  return {
    text: textFilter(state, clipboardOutputFilter, content.join(state.lineBreak)),
    ranges,
    linewise
  };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
  let {
    text,
    ranges,
    linewise
  } = copiedRange(view.state);
  if (!text && !linewise) return false;
  lastLinewiseCopy = linewise ? text : null;
  if (event.type == "cut" && !view.state.readOnly) view.dispatch({
    changes: ranges,
    scrollIntoView: true,
    userEvent: "delete.cut"
  });
  let data = brokenClipboardAPI ? null : event.clipboardData;
  if (data) {
    data.clearData();
    data.setData("text/plain", text);
    return true;
  } else {
    captureCopy(view, text);
    return false;
  }
};
const isFocusChange = state_dist/* Annotation */.YH.define();
function focusChangeTransaction(state, focus) {
  let effects = [];
  for (var _iterator31 = _createForOfIteratorHelperLoose(state.facet(focusChangeEffect)), _step31; !(_step31 = _iterator31()).done;) {
    let getEffect = _step31.value;
    let effect = getEffect(state, focus);
    if (effect) effects.push(effect);
  }
  return effects ? state.update({
    effects,
    annotations: isFocusChange.of(true)
  }) : null;
}
function updateForFocusChange(view) {
  setTimeout(() => {
    let focus = view.hasFocus;
    if (focus != view.inputState.notifiedFocused) {
      let tr = focusChangeTransaction(view.state, focus);
      if (tr) view.dispatch(tr);else view.update([]);
    }
  }, 10);
}
observers.focus = view => {
  view.inputState.lastFocusTime = Date.now();
  if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
    view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
    view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
  }
  updateForFocusChange(view);
};
observers.blur = view => {
  view.observer.clearSelectionRange();
  updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = view => {
  if (view.observer.editContext) return;
  if (view.inputState.compositionFirstChange == null) view.inputState.compositionFirstChange = true;
  if (view.inputState.composing < 0) {
    view.inputState.composing = 0;
  }
};
observers.compositionend = view => {
  if (view.observer.editContext) return;
  view.inputState.composing = -1;
  view.inputState.compositionEndedAt = Date.now();
  view.inputState.compositionPendingKey = true;
  view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
  view.inputState.compositionFirstChange = null;
  if (browser.chrome && browser.android) {
    view.observer.flushSoon();
  } else if (view.inputState.compositionPendingChange) {
    Promise.resolve().then(() => view.observer.flush());
  } else {
    setTimeout(() => {
      if (view.inputState.composing < 0 && view.docView.hasComposition) view.update([]);
    }, 50);
  }
};
observers.contextmenu = view => {
  view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
  var _a, _b;
  if (event.inputType == "insertReplacementText" && view.observer.editContext) {
    let text = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData("text/plain"),
      ranges = event.getTargetRanges();
    if (text && ranges.length) {
      let r = ranges[0];
      let from = view.posAtDOM(r.startContainer, r.startOffset),
        to = view.posAtDOM(r.endContainer, r.endOffset);
      applyDOMChangeInner(view, {
        from,
        to,
        insert: view.state.toText(text)
      }, null);
      return true;
    }
  }
  let pending;
  if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
    view.observer.delayAndroidKey(pending.key, pending.keyCode);
    if (pending.key == "Backspace" || pending.key == "Delete") {
      let startViewHeight = ((_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.height) || 0;
      setTimeout(() => {
        var _a;
        if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
          view.contentDOM.blur();
          view.focus();
        }
      }, 100);
    }
  }
  if (browser.ios && event.inputType == "deleteContentForward") {
    view.observer.flushSoon();
  }
  if (browser.safari && event.inputType == "insertText" && view.inputState.composing >= 0) {
    setTimeout(() => observers.compositionend(view, event), 20);
  }
  return false;
};
const appliedFirefoxHack = new Set();
function firefoxCopyCutHack(doc) {
  if (!appliedFirefoxHack.has(doc)) {
    appliedFirefoxHack.add(doc);
    doc.addEventListener("copy", () => {});
    doc.addEventListener("cut", () => {});
  }
}
const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
let heightChangeFlag = false;
function clearHeightChangeFlag() {
  heightChangeFlag = false;
}
class HeightOracle {
  constructor(lineWrapping) {
    this.lineWrapping = lineWrapping;
    this.doc = state_dist/* Text */.EY.empty;
    this.heightSamples = {};
    this.lineHeight = 14;
    this.charWidth = 7;
    this.textHeight = 14;
    this.lineLength = 30;
  }
  heightForGap(from, to) {
    let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
    if (this.lineWrapping) lines += Math.max(0, Math.ceil((to - from - lines * this.lineLength * 0.5) / this.lineLength));
    return this.lineHeight * lines;
  }
  heightForLine(length) {
    if (!this.lineWrapping) return this.lineHeight;
    let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
    return lines * this.lineHeight;
  }
  setDoc(doc) {
    this.doc = doc;
    return this;
  }
  mustRefreshForWrapping(whiteSpace) {
    return wrappingWhiteSpace.indexOf(whiteSpace) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(lineHeights) {
    let newHeight = false;
    for (let i = 0; i < lineHeights.length; i++) {
      let h = lineHeights[i];
      if (h < 0) {
        i++;
      } else if (!this.heightSamples[Math.floor(h * 10)]) {
        newHeight = true;
        this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return newHeight;
  }
  refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
    let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
    let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
    this.lineWrapping = lineWrapping;
    this.lineHeight = lineHeight;
    this.charWidth = charWidth;
    this.textHeight = textHeight;
    this.lineLength = lineLength;
    if (changed) {
      this.heightSamples = {};
      for (let i = 0; i < knownHeights.length; i++) {
        let h = knownHeights[i];
        if (h < 0) i++;else this.heightSamples[Math.floor(h * 10)] = true;
      }
    }
    return changed;
  }
}
class MeasuredHeights {
  constructor(from, heights) {
    this.from = from;
    this.heights = heights;
    this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class BlockInfo {
  constructor(from, length, top, height, _content) {
    this.from = from;
    this.length = length;
    this.top = top;
    this.height = height;
    this._content = _content;
  }
  get type() {
    return typeof this._content == "number" ? BlockType.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  get widget() {
    return this._content instanceof PointDecoration ? this._content.widget : null;
  }
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  join(other) {
    let content = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(other._content) ? other._content : [other]);
    return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
  }
}
var QueryType = function (QueryType) {
  QueryType[QueryType["ByPos"] = 0] = "ByPos";
  QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
  QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
  return QueryType;
}(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
  constructor(length, height, flags) {
    if (flags === void 0) {
      flags = 2;
    }
    this.length = length;
    this.height = height;
    this.flags = flags;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(value) {
    this.flags = (value ? 2 : 0) | this.flags & ~2;
  }
  setHeight(height) {
    if (this.height != height) {
      if (Math.abs(this.height - height) > Epsilon) heightChangeFlag = true;
      this.height = height;
    }
  }
  replace(_from, _to, nodes) {
    return HeightMap.of(nodes);
  }
  decomposeLeft(_to, result) {
    result.push(this);
  }
  decomposeRight(_from, result) {
    result.push(this);
  }
  applyChanges(decorations, oldDoc, oracle, changes) {
    let me = this,
      doc = oracle.doc;
    for (let i = changes.length - 1; i >= 0; i--) {
      let {
        fromA,
        toA,
        fromB,
        toB
      } = changes[i];
      let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
      let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
      toB += end.to - toA;
      toA = end.to;
      while (i > 0 && start.from <= changes[i - 1].toA) {
        fromA = changes[i - 1].fromA;
        fromB = changes[i - 1].fromB;
        i--;
        if (fromA < start.from) start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
      }
      fromB += start.from - fromA;
      fromA = start.from;
      let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
      me = replace(me, me.replace(fromA, toA, nodes));
    }
    return me.updateHeight(oracle, 0);
  }
  static empty() {
    return new HeightMapText(0, 0);
  }
  static of(nodes) {
    if (nodes.length == 1) return nodes[0];
    let i = 0,
      j = nodes.length,
      before = 0,
      after = 0;
    for (;;) {
      if (i == j) {
        if (before > after * 2) {
          let split = nodes[i - 1];
          if (split.break) nodes.splice(--i, 1, split.left, null, split.right);else nodes.splice(--i, 1, split.left, split.right);
          j += 1 + split.break;
          before -= split.size;
        } else if (after > before * 2) {
          let split = nodes[j];
          if (split.break) nodes.splice(j, 1, split.left, null, split.right);else nodes.splice(j, 1, split.left, split.right);
          j += 2 + split.break;
          after -= split.size;
        } else {
          break;
        }
      } else if (before < after) {
        let next = nodes[i++];
        if (next) before += next.size;
      } else {
        let next = nodes[--j];
        if (next) after += next.size;
      }
    }
    let brk = 0;
    if (nodes[i - 1] == null) {
      brk = 1;
      i--;
    } else if (nodes[i] == null) {
      brk = 1;
      j++;
    }
    return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
  }
}
function replace(old, val) {
  if (old == val) return old;
  if (old.constructor != val.constructor) heightChangeFlag = true;
  return val;
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
  constructor(length, height, deco) {
    super(length, height);
    this.deco = deco;
  }
  blockAt(_height, _oracle, top, offset) {
    return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
  }
  lineAt(_value, _type, oracle, top, offset) {
    return this.blockAt(0, oracle, top, offset);
  }
  forEachLine(from, to, oracle, top, offset, f) {
    if (from <= offset + this.length && to >= offset) f(this.blockAt(0, oracle, top, offset));
  }
  updateHeight(oracle, offset, _force, measured) {
    if (offset === void 0) {
      offset = 0;
    }
    if (_force === void 0) {
      _force = false;
    }
    if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);
    this.outdated = false;
    return this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class HeightMapText extends HeightMapBlock {
  constructor(length, height) {
    super(length, height, null);
    this.collapsed = 0;
    this.widgetHeight = 0;
    this.breaks = 0;
  }
  blockAt(_height, _oracle, top, offset) {
    return new BlockInfo(offset, this.length, top, this.height, this.breaks);
  }
  replace(_from, _to, nodes) {
    let node = nodes[0];
    if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && node.flags & 4) && Math.abs(this.length - node.length) < 10) {
      if (node instanceof HeightMapGap) node = new HeightMapText(node.length, this.height);else node.height = this.height;
      if (!this.outdated) node.outdated = false;
      return node;
    } else {
      return HeightMap.of(nodes);
    }
  }
  updateHeight(oracle, offset, force, measured) {
    if (offset === void 0) {
      offset = 0;
    }
    if (force === void 0) {
      force = false;
    }
    if (measured && measured.from <= offset && measured.more) this.setHeight(measured.heights[measured.index++]);else if (force || this.outdated) this.setHeight(Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) + this.breaks * oracle.lineHeight);
    this.outdated = false;
    return this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class HeightMapGap extends HeightMap {
  constructor(length) {
    super(length, 0);
  }
  heightMetrics(oracle, offset) {
    let firstLine = oracle.doc.lineAt(offset).number,
      lastLine = oracle.doc.lineAt(offset + this.length).number;
    let lines = lastLine - firstLine + 1;
    let perLine,
      perChar = 0;
    if (oracle.lineWrapping) {
      let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
      perLine = totalPerLine / lines;
      if (this.length > lines + 1) perChar = (this.height - totalPerLine) / (this.length - lines - 1);
    } else {
      perLine = this.height / lines;
    }
    return {
      firstLine,
      lastLine,
      perLine,
      perChar
    };
  }
  blockAt(height, oracle, top, offset) {
    let {
      firstLine,
      lastLine,
      perLine,
      perChar
    } = this.heightMetrics(oracle, offset);
    if (oracle.lineWrapping) {
      let guess = offset + (height < oracle.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length));
      let line = oracle.doc.lineAt(guess),
        lineHeight = perLine + line.length * perChar;
      let lineTop = Math.max(top, height - lineHeight / 2);
      return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
    } else {
      let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
      let {
        from,
        length
      } = oracle.doc.line(firstLine + line);
      return new BlockInfo(from, length, top + perLine * line, perLine, 0);
    }
  }
  lineAt(value, type, oracle, top, offset) {
    if (type == QueryType.ByHeight) return this.blockAt(value, oracle, top, offset);
    if (type == QueryType.ByPosNoHeight) {
      let {
        from,
        to
      } = oracle.doc.lineAt(value);
      return new BlockInfo(from, to - from, 0, 0, 0);
    }
    let {
      firstLine,
      perLine,
      perChar
    } = this.heightMetrics(oracle, offset);
    let line = oracle.doc.lineAt(value),
      lineHeight = perLine + line.length * perChar;
    let linesAbove = line.number - firstLine;
    let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
    return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
  }
  forEachLine(from, to, oracle, top, offset, f) {
    from = Math.max(from, offset);
    to = Math.min(to, offset + this.length);
    let {
      firstLine,
      perLine,
      perChar
    } = this.heightMetrics(oracle, offset);
    for (let pos = from, lineTop = top; pos <= to;) {
      let line = oracle.doc.lineAt(pos);
      if (pos == from) {
        let linesAbove = line.number - firstLine;
        lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
      }
      let lineHeight = perLine + perChar * line.length;
      f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
      lineTop += lineHeight;
      pos = line.to + 1;
    }
  }
  replace(from, to, nodes) {
    let after = this.length - to;
    if (after > 0) {
      let last = nodes[nodes.length - 1];
      if (last instanceof HeightMapGap) nodes[nodes.length - 1] = new HeightMapGap(last.length + after);else nodes.push(null, new HeightMapGap(after - 1));
    }
    if (from > 0) {
      let first = nodes[0];
      if (first instanceof HeightMapGap) nodes[0] = new HeightMapGap(from + first.length);else nodes.unshift(new HeightMapGap(from - 1), null);
    }
    return HeightMap.of(nodes);
  }
  decomposeLeft(to, result) {
    result.push(new HeightMapGap(to - 1), null);
  }
  decomposeRight(from, result) {
    result.push(null, new HeightMapGap(this.length - from - 1));
  }
  updateHeight(oracle, offset, force, measured) {
    if (offset === void 0) {
      offset = 0;
    }
    if (force === void 0) {
      force = false;
    }
    let end = offset + this.length;
    if (measured && measured.from <= offset + this.length && measured.more) {
      let nodes = [],
        pos = Math.max(offset, measured.from),
        singleHeight = -1;
      if (measured.from > offset) nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
      while (pos <= end && measured.more) {
        let len = oracle.doc.lineAt(pos).length;
        if (nodes.length) nodes.push(null);
        let height = measured.heights[measured.index++];
        if (singleHeight == -1) singleHeight = height;else if (Math.abs(height - singleHeight) >= Epsilon) singleHeight = -2;
        let line = new HeightMapText(len, height);
        line.outdated = false;
        nodes.push(line);
        pos += len + 1;
      }
      if (pos <= end) nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
      let result = HeightMap.of(nodes);
      if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon || Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon) heightChangeFlag = true;
      return replace(this, result);
    } else if (force || this.outdated) {
      this.setHeight(oracle.heightForGap(offset, offset + this.length));
      this.outdated = false;
    }
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class HeightMapBranch extends HeightMap {
  constructor(left, brk, right) {
    super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 : 0));
    this.left = left;
    this.right = right;
    this.size = left.size + right.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(height, oracle, top, offset) {
    let mid = top + this.left.height;
    return height < mid ? this.left.blockAt(height, oracle, top, offset) : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
  }
  lineAt(value, type, oracle, top, offset) {
    let rightTop = top + this.left.height,
      rightOffset = offset + this.left.length + this.break;
    let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
    let base = left ? this.left.lineAt(value, type, oracle, top, offset) : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
    if (this.break || (left ? base.to < rightOffset : base.from > rightOffset)) return base;
    let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
    if (left) return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));else return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
  }
  forEachLine(from, to, oracle, top, offset, f) {
    let rightTop = top + this.left.height,
      rightOffset = offset + this.left.length + this.break;
    if (this.break) {
      if (from < rightOffset) this.left.forEachLine(from, to, oracle, top, offset, f);
      if (to >= rightOffset) this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
    } else {
      let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
      if (from < mid.from) this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
      if (mid.to >= from && mid.from <= to) f(mid);
      if (to > mid.to) this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
    }
  }
  replace(from, to, nodes) {
    let rightStart = this.left.length + this.break;
    if (to < rightStart) return this.balanced(this.left.replace(from, to, nodes), this.right);
    if (from > this.left.length) return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
    let result = [];
    if (from > 0) this.decomposeLeft(from, result);
    let left = result.length;
    for (var _iterator32 = _createForOfIteratorHelperLoose(nodes), _step32; !(_step32 = _iterator32()).done;) {
      let node = _step32.value;
      result.push(node);
    }
    if (from > 0) mergeGaps(result, left - 1);
    if (to < this.length) {
      let right = result.length;
      this.decomposeRight(to, result);
      mergeGaps(result, right);
    }
    return HeightMap.of(result);
  }
  decomposeLeft(to, result) {
    let left = this.left.length;
    if (to <= left) return this.left.decomposeLeft(to, result);
    result.push(this.left);
    if (this.break) {
      left++;
      if (to >= left) result.push(null);
    }
    if (to > left) this.right.decomposeLeft(to - left, result);
  }
  decomposeRight(from, result) {
    let left = this.left.length,
      right = left + this.break;
    if (from >= right) return this.right.decomposeRight(from - right, result);
    if (from < left) this.left.decomposeRight(from, result);
    if (this.break && from < right) result.push(null);
    result.push(this.right);
  }
  balanced(left, right) {
    if (left.size > 2 * right.size || right.size > 2 * left.size) return HeightMap.of(this.break ? [left, null, right] : [left, right]);
    this.left = replace(this.left, left);
    this.right = replace(this.right, right);
    this.setHeight(left.height + right.height);
    this.outdated = left.outdated || right.outdated;
    this.size = left.size + right.size;
    this.length = left.length + this.break + right.length;
    return this;
  }
  updateHeight(oracle, offset, force, measured) {
    if (offset === void 0) {
      offset = 0;
    }
    if (force === void 0) {
      force = false;
    }
    let {
        left,
        right
      } = this,
      rightStart = offset + left.length + this.break,
      rebalance = null;
    if (measured && measured.from <= offset + left.length && measured.more) rebalance = left = left.updateHeight(oracle, offset, force, measured);else left.updateHeight(oracle, offset, force);
    if (measured && measured.from <= rightStart + right.length && measured.more) rebalance = right = right.updateHeight(oracle, rightStart, force, measured);else right.updateHeight(oracle, rightStart, force);
    if (rebalance) return this.balanced(left, right);
    this.height = this.left.height + this.right.height;
    this.outdated = false;
    return this;
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function mergeGaps(nodes, around) {
  let before, after;
  if (nodes[around] == null && (before = nodes[around - 1]) instanceof HeightMapGap && (after = nodes[around + 1]) instanceof HeightMapGap) nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
  constructor(pos, oracle) {
    this.pos = pos;
    this.oracle = oracle;
    this.nodes = [];
    this.lineStart = -1;
    this.lineEnd = -1;
    this.covering = null;
    this.writtenTo = pos;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(_from, to) {
    if (this.lineStart > -1) {
      let end = Math.min(to, this.lineEnd),
        last = this.nodes[this.nodes.length - 1];
      if (last instanceof HeightMapText) last.length += end - this.pos;else if (end > this.pos || !this.isCovered) this.nodes.push(new HeightMapText(end - this.pos, -1));
      this.writtenTo = end;
      if (to > end) {
        this.nodes.push(null);
        this.writtenTo++;
        this.lineStart = -1;
      }
    }
    this.pos = to;
  }
  point(from, to, deco) {
    if (from < to || deco.heightRelevant) {
      let height = deco.widget ? deco.widget.estimatedHeight : 0;
      let breaks = deco.widget ? deco.widget.lineBreaks : 0;
      if (height < 0) height = this.oracle.lineHeight;
      let len = to - from;
      if (deco.block) {
        this.addBlock(new HeightMapBlock(len, height, deco));
      } else if (len || breaks || height >= relevantWidgetHeight) {
        this.addLineDeco(height, breaks, len);
      }
    } else if (to > from) {
      this.span(from, to);
    }
    if (this.lineEnd > -1 && this.lineEnd < this.pos) this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
  }
  enterLine() {
    if (this.lineStart > -1) return;
    let {
      from,
      to
    } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = from;
    this.lineEnd = to;
    if (this.writtenTo < from) {
      if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null) this.nodes.push(this.blankContent(this.writtenTo, from - 1));
      this.nodes.push(null);
    }
    if (this.pos > from) this.nodes.push(new HeightMapText(this.pos - from, -1));
    this.writtenTo = this.pos;
  }
  blankContent(from, to) {
    let gap = new HeightMapGap(to - from);
    if (this.oracle.doc.lineAt(from).to == to) gap.flags |= 4;
    return gap;
  }
  ensureLine() {
    this.enterLine();
    let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (last instanceof HeightMapText) return last;
    let line = new HeightMapText(0, -1);
    this.nodes.push(line);
    return line;
  }
  addBlock(block) {
    this.enterLine();
    let deco = block.deco;
    if (deco && deco.startSide > 0 && !this.isCovered) this.ensureLine();
    this.nodes.push(block);
    this.writtenTo = this.pos = this.pos + block.length;
    if (deco && deco.endSide > 0) this.covering = block;
  }
  addLineDeco(height, breaks, length) {
    let line = this.ensureLine();
    line.length += length;
    line.collapsed += length;
    line.widgetHeight = Math.max(line.widgetHeight, height);
    line.breaks += breaks;
    this.writtenTo = this.pos = this.pos + length;
  }
  finish(from) {
    let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered) this.nodes.push(new HeightMapText(0, -1));else if (this.writtenTo < this.pos || last == null) this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let pos = from;
    for (var _iterator33 = _createForOfIteratorHelperLoose(this.nodes), _step33; !(_step33 = _iterator33()).done;) {
      let node = _step33.value;
      if (node instanceof HeightMapText) node.updateHeight(this.oracle, pos);
      pos += node ? node.length : 1;
    }
    return this.nodes;
  }
  static build(oracle, decorations, from, to) {
    let builder = new NodeBuilder(from, oracle);
    state_dist/* RangeSet */.om.spans(decorations, from, to, builder, 0);
    return builder.finish(from);
  }
}
function heightRelevantDecoChanges(a, b, diff) {
  let comp = new DecorationComparator();
  state_dist/* RangeSet */.om.compare(a, b, diff, comp, 0);
  return comp.changes;
}
class DecorationComparator {
  constructor() {
    this.changes = [];
  }
  compareRange() {}
  comparePoint(from, to, a, b) {
    if (from < to || a && a.heightRelevant || b && b.heightRelevant) addRange(from, to, this.changes, 5);
  }
}
function visiblePixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  let doc = dom.ownerDocument,
    win = doc.defaultView || window;
  let left = Math.max(0, rect.left),
    right = Math.min(win.innerWidth, rect.right);
  let top = Math.max(0, rect.top),
    bottom = Math.min(win.innerHeight, rect.bottom);
  for (let parent = dom.parentNode; parent && parent != doc.body;) {
    if (parent.nodeType == 1) {
      let elt = parent;
      let style = window.getComputedStyle(elt);
      if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) && style.overflow != "visible") {
        let parentRect = elt.getBoundingClientRect();
        left = Math.max(left, parentRect.left);
        right = Math.min(right, parentRect.right);
        top = Math.max(top, parentRect.top);
        bottom = Math.min(parent == dom.parentNode ? win.innerHeight : bottom, parentRect.bottom);
      }
      parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
    } else if (parent.nodeType == 11) {
      parent = parent.host;
    } else {
      break;
    }
  }
  return {
    left: left - rect.left,
    right: Math.max(left, right) - rect.left,
    top: top - (rect.top + paddingTop),
    bottom: Math.max(top, bottom) - (rect.top + paddingTop)
  };
}
function inWindow(elt) {
  let rect = elt.getBoundingClientRect(),
    win = elt.ownerDocument.defaultView || window;
  return rect.left < win.innerWidth && rect.right > 0 && rect.top < win.innerHeight && rect.bottom > 0;
}
function fullPixelRange(dom, paddingTop) {
  let rect = dom.getBoundingClientRect();
  return {
    left: 0,
    right: rect.right - rect.left,
    top: paddingTop,
    bottom: rect.bottom - (rect.top + paddingTop)
  };
}
class LineGap {
  constructor(from, to, size, displaySize) {
    this.from = from;
    this.to = to;
    this.size = size;
    this.displaySize = displaySize;
  }
  static same(a, b) {
    if (a.length != b.length) return false;
    for (let i = 0; i < a.length; i++) {
      let gA = a[i],
        gB = b[i];
      if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size) return false;
    }
    return true;
  }
  draw(viewState, wrapping) {
    return Decoration.replace({
      widget: new LineGapWidget(this.displaySize * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
    }).range(this.from, this.to);
  }
}
class LineGapWidget extends WidgetType {
  constructor(size, vertical) {
    super();
    this.size = size;
    this.vertical = vertical;
  }
  eq(other) {
    return other.size == this.size && other.vertical == this.vertical;
  }
  toDOM() {
    let elt = document.createElement("div");
    if (this.vertical) {
      elt.style.height = this.size + "px";
    } else {
      elt.style.width = this.size + "px";
      elt.style.height = "2px";
      elt.style.display = "inline-block";
    }
    return elt;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ViewState {
  constructor(state) {
    this.state = state;
    this.pixelViewport = {
      left: 0,
      right: window.innerWidth,
      top: 0,
      bottom: 0
    };
    this.inView = true;
    this.paddingTop = 0;
    this.paddingBottom = 0;
    this.contentDOMWidth = 0;
    this.contentDOMHeight = 0;
    this.editorHeight = 0;
    this.editorWidth = 0;
    this.scrollTop = 0;
    this.scrolledToBottom = false;
    this.scaleX = 1;
    this.scaleY = 1;
    this.scrollAnchorPos = 0;
    this.scrollAnchorHeight = -1;
    this.scaler = IdScaler;
    this.scrollTarget = null;
    this.printing = false;
    this.mustMeasureContent = true;
    this.defaultTextDirection = Direction.LTR;
    this.visibleRanges = [];
    this.mustEnforceCursorAssoc = false;
    let guessWrapping = state.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
    this.heightOracle = new HeightOracle(guessWrapping);
    this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
    this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, state_dist/* Text */.EY.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
    for (let i = 0; i < 2; i++) {
      this.viewport = this.getViewport(0, null);
      if (!this.updateForViewport()) break;
    }
    this.updateViewportLines();
    this.lineGaps = this.ensureLineGaps([]);
    this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));
    this.computeVisibleRanges();
  }
  updateForViewport() {
    let viewports = [this.viewport],
      {
        main
      } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let pos = i ? main.head : main.anchor;
      if (!viewports.some(_ref2 => {
        let {
          from,
          to
        } = _ref2;
        return pos >= from && pos <= to;
      })) {
        let {
          from,
          to
        } = this.lineBlockAt(pos);
        viewports.push(new Viewport(from, to));
      }
    }
    this.viewports = viewports.sort((a, b) => a.from - b.from);
    return this.updateScaler();
  }
  updateScaler() {
    let scaler = this.scaler;
    this.scaler = this.heightMap.height <= 7000000 ? IdScaler : new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    return scaler.eq(this.scaler) ? 0 : 2;
  }
  updateViewportLines() {
    this.viewportLines = [];
    this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {
      this.viewportLines.push(scaleBlock(block, this.scaler));
    });
  }
  update(update, scrollTarget) {
    if (scrollTarget === void 0) {
      scrollTarget = null;
    }
    this.state = update.state;
    let prevDeco = this.stateDeco;
    this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
    let contentChanges = update.changedRanges;
    let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : state_dist/* ChangeSet */.VR.empty(this.state.doc.length)));
    let prevHeight = this.heightMap.height;
    let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    clearHeightChangeFlag();
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
    if (this.heightMap.height != prevHeight || heightChangeFlag) update.flags |= 2;
    if (scrollAnchor) {
      this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
      this.scrollAnchorHeight = scrollAnchor.top;
    } else {
      this.scrollAnchorPos = -1;
      this.scrollAnchorHeight = this.heightMap.height;
    }
    let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
    if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) || !this.viewportIsAppropriate(viewport)) viewport = this.getViewport(0, scrollTarget);
    let viewportChange = viewport.from != this.viewport.from || viewport.to != this.viewport.to;
    this.viewport = viewport;
    update.flags |= this.updateForViewport();
    if (viewportChange || !update.changes.empty || update.flags & 2) this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 << 1) this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
    update.flags |= this.computeVisibleRanges(update.changes);
    if (scrollTarget) this.scrollTarget = scrollTarget;
    if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping && update.state.selection.main.empty && update.state.selection.main.assoc && !update.state.facet(nativeSelectionHidden)) this.mustEnforceCursorAssoc = true;
  }
  measure(view) {
    let dom = view.contentDOM,
      style = window.getComputedStyle(dom);
    let oracle = this.heightOracle;
    let whiteSpace = style.whiteSpace;
    this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
    let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
    let domRect = dom.getBoundingClientRect();
    let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
    this.contentDOMHeight = domRect.height;
    this.mustMeasureContent = false;
    let result = 0,
      bias = 0;
    if (domRect.width && domRect.height) {
      let {
        scaleX,
        scaleY
      } = getScale(dom, domRect);
      if (scaleX > .005 && Math.abs(this.scaleX - scaleX) > .005 || scaleY > .005 && Math.abs(this.scaleY - scaleY) > .005) {
        this.scaleX = scaleX;
        this.scaleY = scaleY;
        result |= 16;
        refresh = measureContent = true;
      }
    }
    let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
    let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
    if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
      this.paddingTop = paddingTop;
      this.paddingBottom = paddingBottom;
      result |= 16 | 2;
    }
    if (this.editorWidth != view.scrollDOM.clientWidth) {
      if (oracle.lineWrapping) measureContent = true;
      this.editorWidth = view.scrollDOM.clientWidth;
      result |= 16;
    }
    let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
    if (this.scrollTop != scrollTop) {
      this.scrollAnchorHeight = -1;
      this.scrollTop = scrollTop;
    }
    this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
    let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
    let dTop = pixelViewport.top - this.pixelViewport.top,
      dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
    this.pixelViewport = pixelViewport;
    let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (inView != this.inView) {
      this.inView = inView;
      if (inView) measureContent = true;
    }
    if (!this.inView && !this.scrollTarget && !inWindow(view.dom)) return 0;
    let contentWidth = domRect.width;
    if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
      this.contentDOMWidth = domRect.width;
      this.editorHeight = view.scrollDOM.clientHeight;
      result |= 16;
    }
    if (measureContent) {
      let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
      if (oracle.mustRefreshForHeights(lineHeights)) refresh = true;
      if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
        let {
          lineHeight,
          charWidth,
          textHeight
        } = view.docView.measureTextSize();
        refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
        if (refresh) {
          view.docView.minWidth = 0;
          result |= 16;
        }
      }
      if (dTop > 0 && dBottom > 0) bias = Math.max(dTop, dBottom);else if (dTop < 0 && dBottom < 0) bias = Math.min(dTop, dBottom);
      clearHeightChangeFlag();
      for (var _iterator34 = _createForOfIteratorHelperLoose(this.viewports), _step34; !(_step34 = _iterator34()).done;) {
        let vp = _step34.value;
        let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
        this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, state_dist/* Text */.EY.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
      }
      if (heightChangeFlag) result |= 2;
    }
    let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    if (viewportChange) {
      if (result & 2) result |= this.updateScaler();
      this.viewport = this.getViewport(bias, this.scrollTarget);
      result |= this.updateForViewport();
    }
    if (result & 2 || viewportChange) this.updateViewportLines();
    if (this.lineGaps.length || this.viewport.to - this.viewport.from > 2000 << 1) this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
    result |= this.computeVisibleRanges();
    if (this.mustEnforceCursorAssoc) {
      this.mustEnforceCursorAssoc = false;
      view.docView.enforceCursorAssoc();
    }
    return result;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(bias, scrollTarget) {
    let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 / 2));
    let map = this.heightMap,
      oracle = this.heightOracle;
    let {
      visibleTop,
      visibleBottom
    } = this;
    let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000, QueryType.ByHeight, oracle, 0, 0).to);
    if (scrollTarget) {
      let {
        head
      } = scrollTarget.range;
      if (head < viewport.from || head > viewport.to) {
        let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
        let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0),
          topPos;
        if (scrollTarget.y == "center") topPos = (block.top + block.bottom) / 2 - viewHeight / 2;else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from) topPos = block.top;else topPos = block.bottom - viewHeight;
        viewport = new Viewport(map.lineAt(topPos - 1000 / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 / 2, QueryType.ByHeight, oracle, 0, 0).to);
      }
    }
    return viewport;
  }
  mapViewport(viewport, changes) {
    let from = changes.mapPos(viewport.from, -1),
      to = changes.mapPos(viewport.to, 1);
    return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
  }
  viewportIsAppropriate(_ref3, bias) {
    let {
      from,
      to
    } = _ref3;
    if (bias === void 0) {
      bias = 0;
    }
    if (!this.inView) return true;
    let {
      top
    } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
    let {
      bottom
    } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
    let {
      visibleTop,
      visibleBottom
    } = this;
    return (from == 0 || top <= visibleTop - Math.max(10, Math.min(-bias, 250))) && (to == this.state.doc.length || bottom >= visibleBottom + Math.max(10, Math.min(bias, 250))) && top > visibleTop - 2 * 1000 && bottom < visibleBottom + 2 * 1000;
  }
  mapLineGaps(gaps, changes) {
    if (!gaps.length || changes.empty) return gaps;
    let mapped = [];
    for (var _iterator35 = _createForOfIteratorHelperLoose(gaps), _step35; !(_step35 = _iterator35()).done;) {
      let gap = _step35.value;
      if (!changes.touchesRange(gap.from, gap.to)) mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size, gap.displaySize));
    }
    return mapped;
  }
  ensureLineGaps(current, mayMeasure) {
    let wrapping = this.heightOracle.lineWrapping;
    let margin = wrapping ? 10000 : 2000,
      halfMargin = margin >> 1,
      doubleMargin = margin << 1;
    if (this.defaultTextDirection != Direction.LTR && !wrapping) return [];
    let gaps = [];
    let addGap = (from, to, line, structure) => {
      if (to - from < halfMargin) return;
      let sel = this.state.selection.main,
        avoid = [sel.from];
      if (!sel.empty) avoid.push(sel.to);
      for (var _i3 = 0, _avoid = avoid; _i3 < _avoid.length; _i3++) {
        let pos = _avoid[_i3];
        if (pos > from && pos < to) {
          addGap(from, pos - 10, line, structure);
          addGap(pos + 10, to, line, structure);
          return;
        }
      }
      let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to && Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin && !avoid.some(pos => gap.from < pos && gap.to > pos));
      if (!gap) {
        if (to < line.to && mayMeasure && wrapping && mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
          let lineStart = mayMeasure.moveToLineBoundary(state_dist/* EditorSelection */.OF.cursor(to), false, true).head;
          if (lineStart > from) to = lineStart;
        }
        let size = this.gapSize(line, from, to, structure);
        let displaySize = wrapping || size < 2000000 ? size : 2000000;
        gap = new LineGap(from, to, size, displaySize);
      }
      gaps.push(gap);
    };
    let checkLine = line => {
      if (line.length < doubleMargin || line.type != BlockType.Text) return;
      let structure = lineStructure(line.from, line.to, this.stateDeco);
      if (structure.total < doubleMargin) return;
      let target = this.scrollTarget ? this.scrollTarget.range.head : null;
      let viewFrom, viewTo;
      if (wrapping) {
        let marginHeight = margin / this.heightOracle.lineLength * this.heightOracle.lineHeight;
        let top, bot;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
          top = targetFrac - spaceFrac;
          bot = targetFrac + spaceFrac;
        } else {
          top = (this.visibleTop - line.top - marginHeight) / line.height;
          bot = (this.visibleBottom - line.top + marginHeight) / line.height;
        }
        viewFrom = findPosition(structure, top);
        viewTo = findPosition(structure, bot);
      } else {
        let totalWidth = structure.total * this.heightOracle.charWidth;
        let marginWidth = margin * this.heightOracle.charWidth;
        let horizOffset = 0;
        if (totalWidth > 2000000) {
          for (var _iterator36 = _createForOfIteratorHelperLoose(current), _step36; !(_step36 = _iterator36()).done;) {
            let old = _step36.value;
            if (old.from >= line.from && old.from < line.to && old.size != old.displaySize && old.from * this.heightOracle.charWidth + horizOffset < this.pixelViewport.left) horizOffset = old.size - old.displaySize;
          }
        }
        let pxLeft = this.pixelViewport.left + horizOffset,
          pxRight = this.pixelViewport.right + horizOffset;
        let left, right;
        if (target != null) {
          let targetFrac = findFraction(structure, target);
          let spaceFrac = ((pxRight - pxLeft) / 2 + marginWidth) / totalWidth;
          left = targetFrac - spaceFrac;
          right = targetFrac + spaceFrac;
        } else {
          left = (pxLeft - marginWidth) / totalWidth;
          right = (pxRight + marginWidth) / totalWidth;
        }
        viewFrom = findPosition(structure, left);
        viewTo = findPosition(structure, right);
      }
      if (viewFrom > line.from) addGap(line.from, viewFrom, line, structure);
      if (viewTo < line.to) addGap(viewTo, line.to, line, structure);
    };
    for (var _iterator37 = _createForOfIteratorHelperLoose(this.viewportLines), _step37; !(_step37 = _iterator37()).done;) {
      let line = _step37.value;
      if (Array.isArray(line.type)) line.type.forEach(checkLine);else checkLine(line);
    }
    return gaps;
  }
  gapSize(line, from, to, structure) {
    let fraction = findFraction(structure, to) - findFraction(structure, from);
    if (this.heightOracle.lineWrapping) {
      return line.height * fraction;
    } else {
      return structure.total * this.heightOracle.charWidth * fraction;
    }
  }
  updateLineGaps(gaps) {
    if (!LineGap.same(gaps, this.lineGaps)) {
      this.lineGaps = gaps;
      this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));
    }
  }
  computeVisibleRanges(changes) {
    let deco = this.stateDeco;
    if (this.lineGaps.length) deco = deco.concat(this.lineGapDeco);
    let ranges = [];
    state_dist/* RangeSet */.om.spans(deco, this.viewport.from, this.viewport.to, {
      span(from, to) {
        ranges.push({
          from,
          to
        });
      },
      point() {}
    }, 20);
    let changed = 0;
    if (ranges.length != this.visibleRanges.length) {
      changed = 8 | 4;
    } else {
      for (let i = 0; i < ranges.length && !(changed & 8); i++) {
        let old = this.visibleRanges[i],
          nw = ranges[i];
        if (old.from != nw.from || old.to != nw.to) {
          changed |= 4;
          if (!(changes && changes.mapPos(old.from, -1) == nw.from && changes.mapPos(old.to, 1) == nw.to)) changed |= 8;
        }
      }
    }
    this.visibleRanges = ranges;
    return changed;
  }
  lineBlockAt(pos) {
    return pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos) || scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(height) {
    return height >= this.viewportLines[0].top && height <= this.viewportLines[this.viewportLines.length - 1].bottom && this.viewportLines.find(l => l.top <= height && l.bottom >= height) || scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(scrollTop) {
    let block = this.lineBlockAtHeight(scrollTop + 8);
    return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
  }
  elementAtHeight(height) {
    return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Viewport {
  constructor(from, to) {
    this.from = from;
    this.to = to;
  }
}
function lineStructure(from, to, stateDeco) {
  let ranges = [],
    pos = from,
    total = 0;
  state_dist/* RangeSet */.om.spans(stateDeco, from, to, {
    span() {},
    point(from, to) {
      if (from > pos) {
        ranges.push({
          from: pos,
          to: from
        });
        total += from - pos;
      }
      pos = to;
    }
  }, 20);
  if (pos < to) {
    ranges.push({
      from: pos,
      to
    });
    total += to - pos;
  }
  return {
    total,
    ranges
  };
}
function findPosition(_ref4, ratio) {
  let {
    total,
    ranges
  } = _ref4;
  if (ratio <= 0) return ranges[0].from;
  if (ratio >= 1) return ranges[ranges.length - 1].to;
  let dist = Math.floor(total * ratio);
  for (let i = 0;; i++) {
    let {
        from,
        to
      } = ranges[i],
      size = to - from;
    if (dist <= size) return from + dist;
    dist -= size;
  }
}
function findFraction(structure, pos) {
  let counted = 0;
  for (var _iterator38 = _createForOfIteratorHelperLoose(structure.ranges), _step38; !(_step38 = _iterator38()).done;) {
    let {
      from,
      to
    } = _step38.value;
    if (pos <= to) {
      counted += pos - from;
      break;
    }
    counted += to - from;
  }
  return counted / structure.total;
}
function find(array, f) {
  for (var _iterator39 = _createForOfIteratorHelperLoose(array), _step39; !(_step39 = _iterator39()).done;) {
    let val = _step39.value;
    if (f(val)) return val;
  }
  return undefined;
}
const IdScaler = {
  toDOM(n) {
    return n;
  },
  fromDOM(n) {
    return n;
  },
  scale: 1,
  eq(other) {
    return other == this;
  }
};
class BigScaler {
  constructor(oracle, heightMap, viewports) {
    let vpHeight = 0,
      base = 0,
      domBase = 0;
    this.viewports = viewports.map(_ref5 => {
      let {
        from,
        to
      } = _ref5;
      let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
      let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
      vpHeight += bottom - top;
      return {
        from,
        to,
        top,
        bottom,
        domTop: 0,
        domBottom: 0
      };
    });
    this.scale = (7000000 - vpHeight) / (heightMap.height - vpHeight);
    for (var _iterator40 = _createForOfIteratorHelperLoose(this.viewports), _step40; !(_step40 = _iterator40()).done;) {
      let obj = _step40.value;
      obj.domTop = domBase + (obj.top - base) * this.scale;
      domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
      base = obj.bottom;
    }
  }
  toDOM(n) {
    for (let i = 0, base = 0, domBase = 0;; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.top) return domBase + (n - base) * this.scale;
      if (n <= vp.bottom) return vp.domTop + (n - vp.top);
      base = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  fromDOM(n) {
    for (let i = 0, base = 0, domBase = 0;; i++) {
      let vp = i < this.viewports.length ? this.viewports[i] : null;
      if (!vp || n < vp.domTop) return base + (n - domBase) / this.scale;
      if (n <= vp.domBottom) return vp.top + (n - vp.domTop);
      base = vp.bottom;
      domBase = vp.domBottom;
    }
  }
  eq(other) {
    if (!(other instanceof BigScaler)) return false;
    return this.scale == other.scale && this.viewports.length == other.viewports.length && this.viewports.every((vp, i) => vp.from == other.viewports[i].from && vp.to == other.viewports[i].to);
  }
}
function scaleBlock(block, scaler) {
  if (scaler.scale == 1) return block;
  let bTop = scaler.toDOM(block.top),
    bBottom = scaler.toDOM(block.bottom);
  return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);
}
const theme = state_dist/* Facet */.sj.define({
  combine: strs => strs.join(" ")
});
const darkTheme = state_dist/* Facet */.sj.define({
  combine: values => values.indexOf(true) > -1
});
const baseThemeID = style_mod/* StyleModule */.G.newName(),
  baseLightID = style_mod/* StyleModule */.G.newName(),
  baseDarkID = style_mod/* StyleModule */.G.newName();
const lightDarkIDs = {
  "&light": "." + baseLightID,
  "&dark": "." + baseDarkID
};
function buildTheme(main, spec, scopes) {
  return new style_mod/* StyleModule */.G(spec, {
    finish(sel) {
      return /&/.test(sel) ? sel.replace(/&\w*/, m => {
        if (m == "&") return main;
        if (!scopes || !scopes[m]) throw new RangeError(`Unsupported selector: ${m}`);
        return scopes[m];
      }) : main + " " + sel;
    }
  });
}
const baseTheme$1 = buildTheme("." + baseThemeID, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0,
    overflowAnchor: "none"
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": {
    caretColor: "black"
  },
  "&dark .cm-content": {
    caretColor: "white"
  },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": {
    "0%": {},
    "50%": {
      opacity: 0
    },
    "100%": {}
  },
  "@keyframes cm-blink2": {
    "0%": {},
    "50%": {
      opacity: 0
    },
    "100%": {}
  },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#ddd"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": {
      display: "none"
    }
  },
  "&light .cm-activeLine": {
    backgroundColor: "#cceeff44"
  },
  "&dark .cm-activeLine": {
    backgroundColor: "#99eeff33"
  },
  "&light .cm-specialChar": {
    color: "red"
  },
  "&dark .cm-specialChar": {
    color: "#f78"
  },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0,
    zIndex: 300
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace": {
    backgroundImage: "radial-gradient(circle at 50% 55%, #aaa 20%, transparent 5%)",
    backgroundPosition: "center"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, lightDarkIDs);
const observeOptions = {
  childList: true,
  characterData: true,
  subtree: true,
  attributes: true,
  characterDataOldValue: true
};
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
  constructor(view) {
    this.view = view;
    this.active = false;
    this.editContext = null;
    this.selectionRange = new DOMSelectionState();
    this.selectionChanged = false;
    this.delayedFlush = -1;
    this.resizeTimeout = -1;
    this.queue = [];
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
    this.lastChange = 0;
    this.scrollTargets = [];
    this.intersection = null;
    this.resizeScroll = null;
    this.intersecting = false;
    this.gapIntersection = null;
    this.gaps = [];
    this.printQuery = null;
    this.parentCheck = -1;
    this.dom = view.contentDOM;
    this.observer = new MutationObserver(mutations => {
      for (var _iterator41 = _createForOfIteratorHelperLoose(mutations), _step41; !(_step41 = _iterator41()).done;) {
        let mut = _step41.value;
        this.queue.push(mut);
      }
      if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) && mutations.some(m => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length)) this.flushSoon();else this.flush();
    });
    if (window.EditContext && view.constructor.EDIT_CONTEXT !== false && !(browser.chrome && browser.chrome_version < 126)) {
      this.editContext = new EditContextManager(view);
      if (view.state.facet(editable)) view.contentDOM.editContext = this.editContext.editContext;
    }
    if (useCharData) this.onCharData = event => {
      this.queue.push({
        target: event.target,
        type: "characterData",
        oldValue: event.prevValue
      });
      this.flushSoon();
    };
    this.onSelectionChange = this.onSelectionChange.bind(this);
    this.onResize = this.onResize.bind(this);
    this.onPrint = this.onPrint.bind(this);
    this.onScroll = this.onScroll.bind(this);
    if (window.matchMedia) this.printQuery = window.matchMedia("print");
    if (typeof ResizeObserver == "function") {
      this.resizeScroll = new ResizeObserver(() => {
        var _a;
        if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75) this.onResize();
      });
      this.resizeScroll.observe(view.scrollDOM);
    }
    this.addWindowListeners(this.win = view.win);
    this.start();
    if (typeof IntersectionObserver == "function") {
      this.intersection = new IntersectionObserver(entries => {
        if (this.parentCheck < 0) this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0 != this.intersecting) {
          this.intersecting = !this.intersecting;
          if (this.intersecting != this.view.inView) this.onScrollChanged(document.createEvent("Event"));
        }
      }, {
        threshold: [0, .001]
      });
      this.intersection.observe(this.dom);
      this.gapIntersection = new IntersectionObserver(entries => {
        if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0) this.onScrollChanged(document.createEvent("Event"));
      }, {});
    }
    this.listenForScroll();
    this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runHandlers("scroll", e);
    if (this.intersecting) this.view.measure();
  }
  onScroll(e) {
    if (this.intersecting) this.flush(false);
    if (this.editContext) this.view.requestMeasure(this.editContext.measureReq);
    this.onScrollChanged(e);
  }
  onResize() {
    if (this.resizeTimeout < 0) this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1;
      this.view.requestMeasure();
    }, 50);
  }
  onPrint(event) {
    if ((event.type == "change" || !event.type) && !event.matches) return;
    this.view.viewState.printing = true;
    this.view.measure();
    setTimeout(() => {
      this.view.viewState.printing = false;
      this.view.requestMeasure();
    }, 500);
  }
  updateGaps(gaps) {
    if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
      this.gapIntersection.disconnect();
      for (var _iterator42 = _createForOfIteratorHelperLoose(gaps), _step42; !(_step42 = _iterator42()).done;) {
        let gap = _step42.value;
        this.gapIntersection.observe(gap);
      }
      this.gaps = gaps;
    }
  }
  onSelectionChange(event) {
    let wasChanged = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey) return;
    let {
        view
      } = this,
      sel = this.selectionRange;
    if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(this.dom, sel)) return;
    let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
    if (context && context.ignoreEvent(event)) {
      if (!wasChanged) this.selectionChanged = false;
      return;
    }
    if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty && sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) this.flushSoon();else this.flush(false);
  }
  readSelectionRange() {
    let {
      view
    } = this;
    let selection = getSelection(view.root);
    if (!selection) return false;
    let range = browser.safari && view.root.nodeType == 11 && view.root.activeElement == this.dom && safariSelectionRangeHack(this.view, selection) || selection;
    if (!range || this.selectionRange.eq(range)) return false;
    let local = hasSelection(this.dom, range);
    if (local && !this.selectionChanged && view.inputState.lastFocusTime > Date.now() - 200 && view.inputState.lastTouchTime < Date.now() - 300 && atElementStart(this.dom, range)) {
      this.view.inputState.lastFocusTime = 0;
      view.docView.updateSelection();
      return false;
    }
    this.selectionRange.setRange(range);
    if (local) this.selectionChanged = true;
    return true;
  }
  setSelectionRange(anchor, head) {
    this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
    this.selectionChanged = false;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let i = 0,
      changed = null;
    for (let dom = this.dom; dom;) {
      if (dom.nodeType == 1) {
        if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom) i++;else if (!changed) changed = this.scrollTargets.slice(0, i);
        if (changed) changed.push(dom);
        dom = dom.assignedSlot || dom.parentNode;
      } else if (dom.nodeType == 11) {
        dom = dom.host;
      } else {
        break;
      }
    }
    if (i < this.scrollTargets.length && !changed) changed = this.scrollTargets.slice(0, i);
    if (changed) {
      for (var _iterator43 = _createForOfIteratorHelperLoose(this.scrollTargets), _step43; !(_step43 = _iterator43()).done;) {
        let dom = _step43.value;
        dom.removeEventListener("scroll", this.onScroll);
      }
      for (var _iterator44 = _createForOfIteratorHelperLoose(this.scrollTargets = changed), _step44; !(_step44 = _iterator44()).done;) {
        let dom = _step44.value;
        dom.addEventListener("scroll", this.onScroll);
      }
    }
  }
  ignore(f) {
    if (!this.active) return f();
    try {
      this.stop();
      return f();
    } finally {
      this.start();
      this.clear();
    }
  }
  start() {
    if (this.active) return;
    this.observer.observe(this.dom, observeOptions);
    if (useCharData) this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.active = true;
  }
  stop() {
    if (!this.active) return;
    this.active = false;
    this.observer.disconnect();
    if (useCharData) this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
  }
  clear() {
    this.processRecords();
    this.queue.length = 0;
    this.selectionChanged = false;
  }
  delayAndroidKey(key, keyCode) {
    var _a;
    if (!this.delayedAndroidKey) {
      let flush = () => {
        let key = this.delayedAndroidKey;
        if (key) {
          this.clearDelayedAndroidKey();
          this.view.inputState.lastKeyCode = key.keyCode;
          this.view.inputState.lastKeyTime = Date.now();
          let flushed = this.flush();
          if (!flushed && key.force) dispatchKey(this.dom, key.key, key.keyCode);
        }
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
    }
    if (!this.delayedAndroidKey || key == "Enter") this.delayedAndroidKey = {
      key,
      keyCode,
      force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
    };
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    this.delayedAndroidKey = null;
    this.flushingAndroidKey = -1;
  }
  flushSoon() {
    if (this.delayedFlush < 0) this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1;
      this.flush();
    });
  }
  forceFlush() {
    if (this.delayedFlush >= 0) {
      this.view.win.cancelAnimationFrame(this.delayedFlush);
      this.delayedFlush = -1;
    }
    this.flush();
  }
  pendingRecords() {
    for (var _iterator45 = _createForOfIteratorHelperLoose(this.observer.takeRecords()), _step45; !(_step45 = _iterator45()).done;) {
      let mut = _step45.value;
      this.queue.push(mut);
    }
    return this.queue;
  }
  processRecords() {
    let records = this.pendingRecords();
    if (records.length) this.queue = [];
    let from = -1,
      to = -1,
      typeOver = false;
    for (var _iterator46 = _createForOfIteratorHelperLoose(records), _step46; !(_step46 = _iterator46()).done;) {
      let record = _step46.value;
      let range = this.readMutation(record);
      if (!range) continue;
      if (range.typeOver) typeOver = true;
      if (from == -1) {
        ({
          from,
          to
        } = range);
      } else {
        from = Math.min(range.from, from);
        to = Math.max(range.to, to);
      }
    }
    return {
      from,
      to,
      typeOver
    };
  }
  readChange() {
    let {
      from,
      to,
      typeOver
    } = this.processRecords();
    let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
    if (from < 0 && !newSel) return null;
    if (from > -1) this.lastChange = Date.now();
    this.view.inputState.lastFocusTime = 0;
    this.selectionChanged = false;
    let change = new DOMChange(this.view, from, to, typeOver);
    this.view.docView.domChanged = {
      newSel: change.newSel ? change.newSel.main : null
    };
    return change;
  }
  flush(readSelection) {
    if (readSelection === void 0) {
      readSelection = true;
    }
    if (this.delayedFlush >= 0 || this.delayedAndroidKey) return false;
    if (readSelection) this.readSelectionRange();
    let domChange = this.readChange();
    if (!domChange) {
      this.view.requestMeasure();
      return false;
    }
    let startState = this.view.state;
    let handled = applyDOMChange(this.view, domChange);
    if (this.view.state == startState && (domChange.domChanged || domChange.newSel && !domChange.newSel.main.eq(this.view.state.selection.main))) this.view.update([]);
    return handled;
  }
  readMutation(rec) {
    let cView = this.view.docView.nearest(rec.target);
    if (!cView || cView.ignoreMutation(rec)) return null;
    cView.markDirty(rec.type == "attributes");
    if (rec.type == "attributes") cView.flags |= 4;
    if (rec.type == "childList") {
      let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
      let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
      return {
        from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
        to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd,
        typeOver: false
      };
    } else if (rec.type == "characterData") {
      return {
        from: cView.posAtStart,
        to: cView.posAtEnd,
        typeOver: rec.target.nodeValue == rec.oldValue
      };
    } else {
      return null;
    }
  }
  setWindow(win) {
    if (win != this.win) {
      this.removeWindowListeners(this.win);
      this.win = win;
      this.addWindowListeners(this.win);
    }
  }
  addWindowListeners(win) {
    win.addEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.addEventListener) this.printQuery.addEventListener("change", this.onPrint);else this.printQuery.addListener(this.onPrint);
    } else win.addEventListener("beforeprint", this.onPrint);
    win.addEventListener("scroll", this.onScroll);
    win.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(win) {
    win.removeEventListener("scroll", this.onScroll);
    win.removeEventListener("resize", this.onResize);
    if (this.printQuery) {
      if (this.printQuery.removeEventListener) this.printQuery.removeEventListener("change", this.onPrint);else this.printQuery.removeListener(this.onPrint);
    } else win.removeEventListener("beforeprint", this.onPrint);
    win.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  update(update) {
    if (this.editContext) {
      this.editContext.update(update);
      if (update.startState.facet(editable) != update.state.facet(editable)) update.view.contentDOM.editContext = update.state.facet(editable) ? this.editContext.editContext : null;
    }
  }
  destroy() {
    var _a, _b, _c;
    this.stop();
    (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
    (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
    for (var _iterator47 = _createForOfIteratorHelperLoose(this.scrollTargets), _step47; !(_step47 = _iterator47()).done;) {
      let dom = _step47.value;
      dom.removeEventListener("scroll", this.onScroll);
    }
    this.removeWindowListeners(this.win);
    clearTimeout(this.parentCheck);
    clearTimeout(this.resizeTimeout);
    this.win.cancelAnimationFrame(this.delayedFlush);
    this.win.cancelAnimationFrame(this.flushingAndroidKey);
    if (this.editContext) {
      this.view.contentDOM.editContext = null;
      this.editContext.destroy();
    }
  }
}
function findChild(cView, dom, dir) {
  while (dom) {
    let curView = ContentView.get(dom);
    if (curView && curView.parent == cView) return curView;
    let parent = dom.parentNode;
    dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
  }
  return null;
}
function buildSelectionRangeFromRange(view, range) {
  let anchorNode = range.startContainer,
    anchorOffset = range.startOffset;
  let focusNode = range.endContainer,
    focusOffset = range.endOffset;
  let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
  if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset)) [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return {
    anchorNode,
    anchorOffset,
    focusNode,
    focusOffset
  };
}
function safariSelectionRangeHack(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range) return buildSelectionRangeFromRange(view, range);
  }
  let found = null;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.contentDOM.addEventListener("beforeinput", read, true);
  view.dom.ownerDocument.execCommand("indent");
  view.contentDOM.removeEventListener("beforeinput", read, true);
  return found ? buildSelectionRangeFromRange(view, found) : null;
}
class EditContextManager {
  constructor(view) {
    this.from = 0;
    this.to = 0;
    this.pendingContextChange = null;
    this.handlers = Object.create(null);
    this.composing = null;
    this.resetRange(view.state);
    let context = this.editContext = new window.EditContext({
      text: view.state.doc.sliceString(this.from, this.to),
      selectionStart: this.toContextPos(Math.max(this.from, Math.min(this.to, view.state.selection.main.anchor))),
      selectionEnd: this.toContextPos(view.state.selection.main.head)
    });
    this.handlers.textupdate = e => {
      let main = view.state.selection.main,
        {
          anchor,
          head
        } = main;
      let from = this.toEditorPos(e.updateRangeStart),
        to = this.toEditorPos(e.updateRangeEnd);
      if (view.inputState.composing >= 0 && !this.composing) this.composing = {
        contextBase: e.updateRangeStart,
        editorBase: from,
        drifted: false
      };
      let change = {
        from,
        to,
        insert: state_dist/* Text */.EY.of(e.text.split("\n"))
      };
      if (change.from == this.from && anchor < this.from) change.from = anchor;else if (change.to == this.to && anchor > this.to) change.to = anchor;
      if (change.from == change.to && !change.insert.length) {
        let newSel = state_dist/* EditorSelection */.OF.single(this.toEditorPos(e.selectionStart), this.toEditorPos(e.selectionEnd));
        if (!newSel.main.eq(main)) view.dispatch({
          selection: newSel,
          userEvent: "select"
        });
        return;
      }
      if ((browser.mac || browser.android) && change.from == head - 1 && /^\. ?$/.test(e.text) && view.contentDOM.getAttribute("autocorrect") == "off") change = {
        from,
        to,
        insert: state_dist/* Text */.EY.of([e.text.replace(".", " ")])
      };
      this.pendingContextChange = change;
      if (!view.state.readOnly) {
        let newLen = this.to - this.from + (change.to - change.from + change.insert.length);
        applyDOMChangeInner(view, change, state_dist/* EditorSelection */.OF.single(this.toEditorPos(e.selectionStart, newLen), this.toEditorPos(e.selectionEnd, newLen)));
      }
      if (this.pendingContextChange) {
        this.revertPending(view.state);
        this.setSelection(view.state);
      }
    };
    this.handlers.characterboundsupdate = e => {
      let rects = [],
        prev = null;
      for (let i = this.toEditorPos(e.rangeStart), end = this.toEditorPos(e.rangeEnd); i < end; i++) {
        let rect = view.coordsForChar(i);
        prev = rect && new DOMRect(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top) || prev || new DOMRect();
        rects.push(prev);
      }
      context.updateCharacterBounds(e.rangeStart, rects);
    };
    this.handlers.textformatupdate = e => {
      let deco = [];
      for (var _iterator48 = _createForOfIteratorHelperLoose(e.getTextFormats()), _step48; !(_step48 = _iterator48()).done;) {
        let format = _step48.value;
        let lineStyle = format.underlineStyle,
          thickness = format.underlineThickness;
        if (lineStyle != "None" && thickness != "None") {
          let from = this.toEditorPos(format.rangeStart),
            to = this.toEditorPos(format.rangeEnd);
          if (from < to) {
            let style = `text-decoration: underline ${lineStyle == "Dashed" ? "dashed " : lineStyle == "Squiggle" ? "wavy " : ""}${thickness == "Thin" ? 1 : 2}px`;
            deco.push(Decoration.mark({
              attributes: {
                style
              }
            }).range(from, to));
          }
        }
      }
      view.dispatch({
        effects: setEditContextFormatting.of(Decoration.set(deco))
      });
    };
    this.handlers.compositionstart = () => {
      if (view.inputState.composing < 0) {
        view.inputState.composing = 0;
        view.inputState.compositionFirstChange = true;
      }
    };
    this.handlers.compositionend = () => {
      view.inputState.composing = -1;
      view.inputState.compositionFirstChange = null;
      if (this.composing) {
        let {
          drifted
        } = this.composing;
        this.composing = null;
        if (drifted) this.reset(view.state);
      }
    };
    for (let event in this.handlers) context.addEventListener(event, this.handlers[event]);
    this.measureReq = {
      read: view => {
        this.editContext.updateControlBounds(view.contentDOM.getBoundingClientRect());
        let sel = getSelection(view.root);
        if (sel && sel.rangeCount) this.editContext.updateSelectionBounds(sel.getRangeAt(0).getBoundingClientRect());
      }
    };
  }
  applyEdits(update) {
    let off = 0,
      abort = false,
      pending = this.pendingContextChange;
    update.changes.iterChanges((fromA, toA, _fromB, _toB, insert) => {
      if (abort) return;
      let dLen = insert.length - (toA - fromA);
      if (pending && toA >= pending.to) {
        if (pending.from == fromA && pending.to == toA && pending.insert.eq(insert)) {
          pending = this.pendingContextChange = null;
          off += dLen;
          this.to += dLen;
          return;
        } else {
          pending = null;
          this.revertPending(update.state);
        }
      }
      fromA += off;
      toA += off;
      if (toA <= this.from) {
        this.from += dLen;
        this.to += dLen;
      } else if (fromA < this.to) {
        if (fromA < this.from || toA > this.to || this.to - this.from + insert.length > 30000) {
          abort = true;
          return;
        }
        this.editContext.updateText(this.toContextPos(fromA), this.toContextPos(toA), insert.toString());
        this.to += dLen;
      }
      off += dLen;
    });
    if (pending && !abort) this.revertPending(update.state);
    return !abort;
  }
  update(update) {
    let reverted = this.pendingContextChange,
      startSel = update.startState.selection.main;
    if (this.composing && (this.composing.drifted || !update.changes.touchesRange(startSel.from, startSel.to) && update.transactions.some(tr => !tr.isUserEvent("input.type") && tr.changes.touchesRange(this.from, this.to)))) {
      this.composing.drifted = true;
      this.composing.editorBase = update.changes.mapPos(this.composing.editorBase);
    } else if (!this.applyEdits(update) || !this.rangeIsValid(update.state)) {
      this.pendingContextChange = null;
      this.reset(update.state);
    } else if (update.docChanged || update.selectionSet || reverted) {
      this.setSelection(update.state);
    }
    if (update.geometryChanged || update.docChanged || update.selectionSet) update.view.requestMeasure(this.measureReq);
  }
  resetRange(state) {
    let {
      head
    } = state.selection.main;
    this.from = Math.max(0, head - 10000);
    this.to = Math.min(state.doc.length, head + 10000);
  }
  reset(state) {
    this.resetRange(state);
    this.editContext.updateText(0, this.editContext.text.length, state.doc.sliceString(this.from, this.to));
    this.setSelection(state);
  }
  revertPending(state) {
    let pending = this.pendingContextChange;
    this.pendingContextChange = null;
    this.editContext.updateText(this.toContextPos(pending.from), this.toContextPos(pending.from + pending.insert.length), state.doc.sliceString(pending.from, pending.to));
  }
  setSelection(state) {
    let {
      main
    } = state.selection;
    let start = this.toContextPos(Math.max(this.from, Math.min(this.to, main.anchor)));
    let end = this.toContextPos(main.head);
    if (this.editContext.selectionStart != start || this.editContext.selectionEnd != end) this.editContext.updateSelection(start, end);
  }
  rangeIsValid(state) {
    let {
      head
    } = state.selection.main;
    return !(this.from > 0 && head - this.from < 500 || this.to < state.doc.length && this.to - head < 500 || this.to - this.from > 10000 * 3);
  }
  toEditorPos(contextPos, clipLen) {
    if (clipLen === void 0) {
      clipLen = this.to - this.from;
    }
    contextPos = Math.min(contextPos, clipLen);
    let c = this.composing;
    return c && c.drifted ? c.editorBase + (contextPos - c.contextBase) : contextPos + this.from;
  }
  toContextPos(editorPos) {
    let c = this.composing;
    return c && c.drifted ? c.contextBase + (editorPos - c.editorBase) : editorPos - this.from;
  }
  destroy() {
    for (let event in this.handlers) this.editContext.removeEventListener(event, this.handlers[event]);
  }
}
class EditorView {
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  constructor(config) {
    if (config === void 0) {
      config = {};
    }
    var _a;
    this.plugins = [];
    this.pluginMap = new Map();
    this.editorAttrs = {};
    this.contentAttrs = {};
    this.bidiCache = [];
    this.destroyed = false;
    this.updateState = 2;
    this.measureScheduled = -1;
    this.measureRequests = [];
    this.contentDOM = document.createElement("div");
    this.scrollDOM = document.createElement("div");
    this.scrollDOM.tabIndex = -1;
    this.scrollDOM.className = "cm-scroller";
    this.scrollDOM.appendChild(this.contentDOM);
    this.announceDOM = document.createElement("div");
    this.announceDOM.className = "cm-announced";
    this.announceDOM.setAttribute("aria-live", "polite");
    this.dom = document.createElement("div");
    this.dom.appendChild(this.announceDOM);
    this.dom.appendChild(this.scrollDOM);
    if (config.parent) config.parent.appendChild(this.dom);
    let {
      dispatch
    } = config;
    this.dispatchTransactions = config.dispatchTransactions || dispatch && (trs => trs.forEach(tr => dispatch(tr, this))) || (trs => this.update(trs));
    this.dispatch = this.dispatch.bind(this);
    this._root = config.root || getRoot(config.parent) || document;
    this.viewState = new ViewState(config.state || state_dist/* EditorState */.$t.create(config));
    if (config.scrollTo && config.scrollTo.is(scrollIntoView)) this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
    this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
    for (var _iterator49 = _createForOfIteratorHelperLoose(this.plugins), _step49; !(_step49 = _iterator49()).done;) {
      let plugin = _step49.value;
      plugin.update(this);
    }
    this.observer = new DOMObserver(this);
    this.inputState = new InputState(this);
    this.inputState.ensureHandlers(this.plugins);
    this.docView = new DocView(this);
    this.mountStyles();
    this.updateAttrs();
    this.updateState = 0;
    this.requestMeasure();
    if ((_a = document.fonts) === null || _a === void 0 ? void 0 : _a.ready) document.fonts.ready.then(() => this.requestMeasure());
  }
  dispatch() {
    for (var _len = arguments.length, input = new Array(_len), _key = 0; _key < _len; _key++) {
      input[_key] = arguments[_key];
    }
    let trs = input.length == 1 && input[0] instanceof state_dist/* Transaction */.ZX ? input : input.length == 1 && Array.isArray(input[0]) ? input[0] : [this.state.update(...input)];
    this.dispatchTransactions(trs, this);
  }
  update(transactions) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let redrawn = false,
      attrsChanged = false,
      update;
    let state = this.state;
    for (var _iterator50 = _createForOfIteratorHelperLoose(transactions), _step50; !(_step50 = _iterator50()).done;) {
      let tr = _step50.value;
      if (tr.startState != state) throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      state = tr.state;
    }
    if (this.destroyed) {
      this.viewState.state = state;
      return;
    }
    let focus = this.hasFocus,
      focusFlag = 0,
      dispatchFocus = null;
    if (transactions.some(tr => tr.annotation(isFocusChange))) {
      this.inputState.notifiedFocused = focus;
      focusFlag = 1;
    } else if (focus != this.inputState.notifiedFocused) {
      this.inputState.notifiedFocused = focus;
      dispatchFocus = focusChangeTransaction(state, focus);
      if (!dispatchFocus) focusFlag = 1;
    }
    let pendingKey = this.observer.delayedAndroidKey,
      domChange = null;
    if (pendingKey) {
      this.observer.clearDelayedAndroidKey();
      domChange = this.observer.readChange();
      if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection)) domChange = null;
    } else {
      this.observer.clear();
    }
    if (state.facet(state_dist/* EditorState */.$t.phrases) != this.state.facet(state_dist/* EditorState */.$t.phrases)) return this.setState(state);
    update = ViewUpdate.create(this, state, transactions);
    update.flags |= focusFlag;
    let scrollTarget = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (var _iterator51 = _createForOfIteratorHelperLoose(transactions), _step51; !(_step51 = _iterator51()).done;) {
        let tr = _step51.value;
        if (scrollTarget) scrollTarget = scrollTarget.map(tr.changes);
        if (tr.scrollIntoView) {
          let {
            main
          } = tr.state.selection;
          scrollTarget = new ScrollTarget(main.empty ? main : state_dist/* EditorSelection */.OF.cursor(main.head, main.head > main.anchor ? -1 : 1));
        }
        for (var _iterator52 = _createForOfIteratorHelperLoose(tr.effects), _step52; !(_step52 = _iterator52()).done;) {
          let e = _step52.value;
          if (e.is(scrollIntoView)) scrollTarget = e.value.clip(this.state);
        }
      }
      this.viewState.update(update, scrollTarget);
      this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
      if (!update.empty) {
        this.updatePlugins(update);
        this.inputState.update(update);
      }
      redrawn = this.docView.update(update);
      if (this.state.facet(styleModule) != this.styleModules) this.mountStyles();
      attrsChanged = this.updateAttrs();
      this.showAnnouncements(transactions);
      this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (update.startState.facet(theme) != update.state.facet(theme)) this.viewState.mustMeasureContent = true;
    if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) this.requestMeasure();
    if (redrawn) this.docViewUpdate();
    if (!update.empty) {
      for (var _iterator53 = _createForOfIteratorHelperLoose(this.state.facet(updateListener)), _step53; !(_step53 = _iterator53()).done;) {
        let listener = _step53.value;
        try {
          listener(update);
        } catch (e) {
          logException(this.state, e, "update listener");
        }
      }
    }
    if (dispatchFocus || domChange) Promise.resolve().then(() => {
      if (dispatchFocus && this.state == dispatchFocus.startState) this.dispatch(dispatchFocus);
      if (domChange) {
        if (!applyDOMChange(this, domChange) && pendingKey.force) dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
      }
    });
  }
  setState(newState) {
    if (this.updateState != 0) throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = newState;
      return;
    }
    this.updateState = 2;
    let hadFocus = this.hasFocus;
    try {
      for (var _iterator54 = _createForOfIteratorHelperLoose(this.plugins), _step54; !(_step54 = _iterator54()).done;) {
        let plugin = _step54.value;
        plugin.destroy(this);
      }
      this.viewState = new ViewState(newState);
      this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
      this.pluginMap.clear();
      for (var _iterator55 = _createForOfIteratorHelperLoose(this.plugins), _step55; !(_step55 = _iterator55()).done;) {
        let plugin = _step55.value;
        plugin.update(this);
      }
      this.docView.destroy();
      this.docView = new DocView(this);
      this.inputState.ensureHandlers(this.plugins);
      this.mountStyles();
      this.updateAttrs();
      this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    if (hadFocus) this.focus();
    this.requestMeasure();
  }
  updatePlugins(update) {
    let prevSpecs = update.startState.facet(viewPlugin),
      specs = update.state.facet(viewPlugin);
    if (prevSpecs != specs) {
      let newPlugins = [];
      for (var _iterator56 = _createForOfIteratorHelperLoose(specs), _step56; !(_step56 = _iterator56()).done;) {
        let spec = _step56.value;
        let found = prevSpecs.indexOf(spec);
        if (found < 0) {
          newPlugins.push(new PluginInstance(spec));
        } else {
          let plugin = this.plugins[found];
          plugin.mustUpdate = update;
          newPlugins.push(plugin);
        }
      }
      for (var _iterator57 = _createForOfIteratorHelperLoose(this.plugins), _step57; !(_step57 = _iterator57()).done;) {
        let plugin = _step57.value;
        if (plugin.mustUpdate != update) plugin.destroy(this);
      }
      this.plugins = newPlugins;
      this.pluginMap.clear();
    } else {
      for (var _iterator58 = _createForOfIteratorHelperLoose(this.plugins), _step58; !(_step58 = _iterator58()).done;) {
        let p = _step58.value;
        p.mustUpdate = update;
      }
    }
    for (let i = 0; i < this.plugins.length; i++) this.plugins[i].update(this);
    if (prevSpecs != specs) this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (var _iterator59 = _createForOfIteratorHelperLoose(this.plugins), _step59; !(_step59 = _iterator59()).done;) {
      let plugin = _step59.value;
      let val = plugin.value;
      if (val && val.docViewUpdate) {
        try {
          val.docViewUpdate(this);
        } catch (e) {
          logException(this.state, e, "doc view update listener");
        }
      }
    }
  }
  measure(flush) {
    if (flush === void 0) {
      flush = true;
    }
    if (this.destroyed) return;
    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
    if (this.observer.delayedAndroidKey) {
      this.measureScheduled = -1;
      this.requestMeasure();
      return;
    }
    this.measureScheduled = 0;
    if (flush) this.observer.forceFlush();
    let updated = null;
    let sDOM = this.scrollDOM,
      scrollTop = sDOM.scrollTop * this.scaleY;
    let {
      scrollAnchorPos,
      scrollAnchorHeight
    } = this.viewState;
    if (Math.abs(scrollTop - this.viewState.scrollTop) > 1) scrollAnchorHeight = -1;
    this.viewState.scrollAnchorHeight = -1;
    try {
      for (let i = 0;; i++) {
        if (scrollAnchorHeight < 0) {
          if (isScrolledToBottom(sDOM)) {
            scrollAnchorPos = -1;
            scrollAnchorHeight = this.viewState.heightMap.height;
          } else {
            let block = this.viewState.scrollAnchorAt(scrollTop);
            scrollAnchorPos = block.from;
            scrollAnchorHeight = block.top;
          }
        }
        this.updateState = 1;
        let changed = this.viewState.measure(this);
        if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null) break;
        if (i > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let measuring = [];
        if (!(changed & 4)) [this.measureRequests, measuring] = [measuring, this.measureRequests];
        let measured = measuring.map(m => {
          try {
            return m.read(this);
          } catch (e) {
            logException(this.state, e);
            return BadMeasure;
          }
        });
        let update = ViewUpdate.create(this, this.state, []),
          redrawn = false;
        update.flags |= changed;
        if (!updated) updated = update;else updated.flags |= changed;
        this.updateState = 2;
        if (!update.empty) {
          this.updatePlugins(update);
          this.inputState.update(update);
          this.updateAttrs();
          redrawn = this.docView.update(update);
          if (redrawn) this.docViewUpdate();
        }
        for (let i = 0; i < measuring.length; i++) if (measured[i] != BadMeasure) {
          try {
            let m = measuring[i];
            if (m.write) m.write(measured[i], this);
          } catch (e) {
            logException(this.state, e);
          }
        }
        if (redrawn) this.docView.updateSelection(true);
        if (!update.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight) {
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget);
              this.viewState.scrollTarget = null;
              scrollAnchorHeight = -1;
              continue;
            } else {
              let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(scrollAnchorPos).top;
              let diff = newAnchorHeight - scrollAnchorHeight;
              if (diff > 1 || diff < -1) {
                scrollTop = scrollTop + diff;
                sDOM.scrollTop = scrollTop / this.scaleY;
                scrollAnchorHeight = -1;
                continue;
              }
            }
          }
          break;
        }
      }
    } finally {
      this.updateState = 0;
      this.measureScheduled = -1;
    }
    if (updated && !updated.empty) {
      for (var _iterator60 = _createForOfIteratorHelperLoose(this.state.facet(updateListener)), _step60; !(_step60 = _iterator60()).done;) {
        let listener = _step60.value;
        listener(updated);
      }
    }
  }
  get themeClasses() {
    return baseThemeID + " " + (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " + this.state.facet(theme);
  }
  updateAttrs() {
    let editorAttrs = attrsFromFacet(this, editorAttributes, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    });
    let contentAttrs = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      writingsuggestions: "false",
      translate: "no",
      contenteditable: !this.state.facet(editable) ? "false" : "true",
      class: "cm-content",
      style: `${browser.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    if (this.state.readOnly) contentAttrs["aria-readonly"] = "true";
    attrsFromFacet(this, contentAttributes, contentAttrs);
    let changed = this.observer.ignore(() => {
      let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
      let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
      return changedContent || changedEditor;
    });
    this.editorAttrs = editorAttrs;
    this.contentAttrs = contentAttrs;
    return changed;
  }
  showAnnouncements(trs) {
    let first = true;
    for (var _iterator61 = _createForOfIteratorHelperLoose(trs), _step61; !(_step61 = _iterator61()).done;) {
      let tr = _step61.value;
      for (var _iterator62 = _createForOfIteratorHelperLoose(tr.effects), _step62; !(_step62 = _iterator62()).done;) {
        let effect = _step62.value;
        if (effect.is(EditorView.announce)) {
          if (first) this.announceDOM.textContent = "";
          first = false;
          let div = this.announceDOM.appendChild(document.createElement("div"));
          div.textContent = effect.value;
        }
      }
    }
  }
  mountStyles() {
    this.styleModules = this.state.facet(styleModule);
    let nonce = this.state.facet(EditorView.cspNonce);
    style_mod/* StyleModule */.G.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? {
      nonce
    } : undefined);
  }
  readMeasured() {
    if (this.updateState == 2) throw new Error("Reading the editor layout isn't allowed during an update");
    if (this.updateState == 0 && this.measureScheduled > -1) this.measure(false);
  }
  requestMeasure(request) {
    if (this.measureScheduled < 0) this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
    if (request) {
      if (this.measureRequests.indexOf(request) > -1) return;
      if (request.key != null) for (let i = 0; i < this.measureRequests.length; i++) {
        if (this.measureRequests[i].key === request.key) {
          this.measureRequests[i] = request;
          return;
        }
      }
      this.measureRequests.push(request);
    }
  }
  plugin(plugin) {
    let known = this.pluginMap.get(plugin);
    if (known === undefined || known && known.spec != plugin) this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
    return known && known.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return {
      top: this.viewState.paddingTop,
      bottom: this.viewState.paddingBottom
    };
  }
  get scaleX() {
    return this.viewState.scaleX;
  }
  get scaleY() {
    return this.viewState.scaleY;
  }
  elementAtHeight(height) {
    this.readMeasured();
    return this.viewState.elementAtHeight(height);
  }
  lineBlockAtHeight(height) {
    this.readMeasured();
    return this.viewState.lineBlockAtHeight(height);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(pos) {
    return this.viewState.lineBlockAt(pos);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(start, forward, by) {
    return skipAtoms(this, start, moveByChar(this, start, forward, by));
  }
  moveByGroup(start, forward) {
    return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
  }
  visualLineSide(line, end) {
    let order = this.bidiSpans(line),
      dir = this.textDirectionAt(line.from);
    let span = order[end ? order.length - 1 : 0];
    return state_dist/* EditorSelection */.OF.cursor(span.side(end, dir) + line.from, span.forward(!end, dir) ? 1 : -1);
  }
  moveToLineBoundary(start, forward, includeWrap) {
    if (includeWrap === void 0) {
      includeWrap = true;
    }
    return moveToLineBoundary(this, start, forward, includeWrap);
  }
  moveVertically(start, forward, distance) {
    return skipAtoms(this, start, moveVertically(this, start, forward, distance));
  }
  domAtPos(pos) {
    return this.docView.domAtPos(pos);
  }
  posAtDOM(node, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return this.docView.posFromDOM(node, offset);
  }
  posAtCoords(coords, precise) {
    if (precise === void 0) {
      precise = true;
    }
    this.readMeasured();
    return posAtCoords(this, coords, precise);
  }
  coordsAtPos(pos, side) {
    if (side === void 0) {
      side = 1;
    }
    this.readMeasured();
    let rect = this.docView.coordsAt(pos, side);
    if (!rect || rect.left == rect.right) return rect;
    let line = this.state.doc.lineAt(pos),
      order = this.bidiSpans(line);
    let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
    return flattenRect(rect, span.dir == Direction.LTR == side > 0);
  }
  coordsForChar(pos) {
    this.readMeasured();
    return this.docView.coordsForChar(pos);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(pos) {
    let perLine = this.state.facet(perLineTextDirection);
    if (!perLine || pos < this.viewport.from || pos > this.viewport.to) return this.textDirection;
    this.readMeasured();
    return this.docView.textDirectionAt(pos);
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(line) {
    if (line.length > MaxBidiLine) return trivialOrder(line.length);
    let dir = this.textDirectionAt(line.from),
      isolates;
    for (var _iterator63 = _createForOfIteratorHelperLoose(this.bidiCache), _step63; !(_step63 = _iterator63()).done;) {
      let entry = _step63.value;
      if (entry.from == line.from && entry.dir == dir && (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line)))) return entry.order;
    }
    if (!isolates) isolates = getIsolatedRanges(this, line);
    let order = computeOrder(line.text, dir, isolates);
    this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
    return order;
  }
  get hasFocus() {
    var _a;
    return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      focusPreventScroll(this.contentDOM);
      this.docView.updateSelection();
    });
  }
  setRoot(root) {
    if (this._root != root) {
      this._root = root;
      this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
      this.mountStyles();
    }
  }
  destroy() {
    if (this.root.activeElement == this.contentDOM) this.contentDOM.blur();
    for (var _iterator64 = _createForOfIteratorHelperLoose(this.plugins), _step64; !(_step64 = _iterator64()).done;) {
      let plugin = _step64.value;
      plugin.destroy(this);
    }
    this.plugins = [];
    this.inputState.destroy();
    this.docView.destroy();
    this.dom.remove();
    this.observer.destroy();
    if (this.measureScheduled > -1) this.win.cancelAnimationFrame(this.measureScheduled);
    this.destroyed = true;
  }
  static scrollIntoView(pos, options) {
    if (options === void 0) {
      options = {};
    }
    return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? state_dist/* EditorSelection */.OF.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
  }
  scrollSnapshot() {
    let {
      scrollTop,
      scrollLeft
    } = this.scrollDOM;
    let ref = this.viewState.scrollAnchorAt(scrollTop);
    return scrollIntoView.of(new ScrollTarget(state_dist/* EditorSelection */.OF.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
  }
  setTabFocusMode(to) {
    if (to == null) this.inputState.tabFocusMode = this.inputState.tabFocusMode < 0 ? 0 : -1;else if (typeof to == "boolean") this.inputState.tabFocusMode = to ? 0 : -1;else if (this.inputState.tabFocusMode != 0) this.inputState.tabFocusMode = Date.now() + to;
  }
  static domEventHandlers(handlers) {
    return ViewPlugin.define(() => ({}), {
      eventHandlers: handlers
    });
  }
  static domEventObservers(observers) {
    return ViewPlugin.define(() => ({}), {
      eventObservers: observers
    });
  }
  static theme(spec, options) {
    let prefix = style_mod/* StyleModule */.G.newName();
    let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
    if (options && options.dark) result.push(darkTheme.of(true));
    return result;
  }
  static baseTheme(spec) {
    return state_dist/* Prec */.Nb.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
  }
  static findFromDOM(dom) {
    var _a;
    let content = dom.querySelector(".cm-content");
    let cView = content && ContentView.get(content) || ContentView.get(dom);
    return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
  }
}
EditorView.styleModule = styleModule;
EditorView.inputHandler = inputHandler;
EditorView.clipboardInputFilter = clipboardInputFilter;
EditorView.clipboardOutputFilter = clipboardOutputFilter;
EditorView.scrollHandler = scrollHandler;
EditorView.focusChangeEffect = focusChangeEffect;
EditorView.perLineTextDirection = perLineTextDirection;
EditorView.exceptionSink = exceptionSink;
EditorView.updateListener = updateListener;
EditorView.editable = editable;
EditorView.mouseSelectionStyle = mouseSelectionStyle;
EditorView.dragMovesSelection = dragMovesSelection$1;
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
EditorView.decorations = decorations;
EditorView.outerDecorations = outerDecorations;
EditorView.atomicRanges = atomicRanges;
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
EditorView.scrollMargins = scrollMargins;
EditorView.darkTheme = darkTheme;
EditorView.cspNonce = state_dist/* Facet */.sj.define({
  combine: values => values.length ? values[0] : ""
});
EditorView.contentAttributes = contentAttributes;
EditorView.editorAttributes = editorAttributes;
EditorView.lineWrapping = EditorView.contentAttributes.of({
  "class": "cm-lineWrapping"
});
EditorView.announce = state_dist/* StateEffect */.Pe.define();
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
  constructor(from, to, dir, isolates, fresh, order) {
    this.from = from;
    this.to = to;
    this.dir = dir;
    this.isolates = isolates;
    this.fresh = fresh;
    this.order = order;
  }
  static update(cache, changes) {
    if (changes.empty && !cache.some(c => c.fresh)) return cache;
    let result = [],
      lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
    for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
      let entry = cache[i];
      if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to)) result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
    }
    return result;
  }
}
function attrsFromFacet(view, facet, base) {
  for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
    let source = sources[i],
      value = typeof source == "function" ? source(view) : source;
    if (value) combineAttrs(value, base);
  }
  return base;
}
const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name, platform) {
  const parts = name.split(/-(?!$)/);
  let result = parts[parts.length - 1];
  if (result == "Space") result = " ";
  let alt, ctrl, shift, meta;
  for (let i = 0; i < parts.length - 1; ++i) {
    const mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
      if (platform == "mac") meta = true;else ctrl = true;
    } else throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt) result = "Alt-" + result;
  if (ctrl) result = "Ctrl-" + result;
  if (meta) result = "Meta-" + result;
  if (shift) result = "Shift-" + result;
  return result;
}
function modifiers(name, event, shift) {
  if (event.altKey) name = "Alt-" + name;
  if (event.ctrlKey) name = "Ctrl-" + name;
  if (event.metaKey) name = "Meta-" + name;
  if (shift !== false && event.shiftKey) name = "Shift-" + name;
  return name;
}
const handleKeyEvents = state_dist/* Prec */.Nb.default(EditorView.domEventHandlers({
  keydown(event, view) {
    return runHandlers(getKeymap(view.state), event, view, "editor");
  }
}));
const keymap = state_dist/* Facet */.sj.define({
  enables: handleKeyEvents
});
const Keymaps = new WeakMap();
function getKeymap(state) {
  let bindings = state.facet(keymap);
  let map = Keymaps.get(bindings);
  if (!map) Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
  return map;
}
function runScopeHandlers(view, event, scope) {
  return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform) {
  if (platform === void 0) {
    platform = currentPlatform;
  }
  let bound = Object.create(null);
  let isPrefix = Object.create(null);
  let checkPrefix = (name, is) => {
    let current = isPrefix[name];
    if (current == null) isPrefix[name] = is;else if (current != is) throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
  };
  let add = (scope, key, command, preventDefault, stopPropagation) => {
    var _a, _b;
    let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
    let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
    for (let i = 1; i < parts.length; i++) {
      let prefix = parts.slice(0, i).join(" ");
      checkPrefix(prefix, true);
      if (!scopeObj[prefix]) scopeObj[prefix] = {
        preventDefault: true,
        stopPropagation: false,
        run: [view => {
          let ourObj = storedPrefix = {
            view,
            prefix,
            scope
          };
          setTimeout(() => {
            if (storedPrefix == ourObj) storedPrefix = null;
          }, PrefixTimeout);
          return true;
        }]
      };
    }
    let full = parts.join(" ");
    checkPrefix(full, false);
    let binding = scopeObj[full] || (scopeObj[full] = {
      preventDefault: false,
      stopPropagation: false,
      run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
    });
    if (command) binding.run.push(command);
    if (preventDefault) binding.preventDefault = true;
    if (stopPropagation) binding.stopPropagation = true;
  };
  for (var _iterator65 = _createForOfIteratorHelperLoose(bindings), _step65; !(_step65 = _iterator65()).done;) {
    let b = _step65.value;
    let scopes = b.scope ? b.scope.split(" ") : ["editor"];
    if (b.any) {
      for (var _iterator66 = _createForOfIteratorHelperLoose(scopes), _step66; !(_step66 = _iterator66()).done;) {
        let scope = _step66.value;
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        if (!scopeObj._any) scopeObj._any = {
          preventDefault: false,
          stopPropagation: false,
          run: []
        };
        let {
          any
        } = b;
        for (let key in scopeObj) scopeObj[key].run.push(view => any(view, currentKeyEvent));
      }
    }
    let name = b[platform] || b.key;
    if (!name) continue;
    for (var _iterator67 = _createForOfIteratorHelperLoose(scopes), _step67; !(_step67 = _iterator67()).done;) {
      let scope = _step67.value;
      add(scope, name, b.run, b.preventDefault, b.stopPropagation);
      if (b.shift) add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
    }
  }
  return bound;
}
let currentKeyEvent = null;
function runHandlers(map, event, view, scope) {
  currentKeyEvent = event;
  let name = keyName(event);
  let charCode = (0,state_dist/* codePointAt */.vS)(name, 0),
    isChar = (0,state_dist/* codePointSize */.Fh)(charCode) == name.length && name != " ";
  let prefix = "",
    handled = false,
    prevented = false,
    stopPropagation = false;
  if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
    prefix = storedPrefix.prefix + " ";
    if (modifierCodes.indexOf(event.keyCode) < 0) {
      prevented = true;
      storedPrefix = null;
    }
  }
  let ran = new Set();
  let runFor = binding => {
    if (binding) {
      for (var _iterator68 = _createForOfIteratorHelperLoose(binding.run), _step68; !(_step68 = _iterator68()).done;) {
        let cmd = _step68.value;
        if (!ran.has(cmd)) {
          ran.add(cmd);
          if (cmd(view)) {
            if (binding.stopPropagation) stopPropagation = true;
            return true;
          }
        }
      }
      if (binding.preventDefault) {
        if (binding.stopPropagation) stopPropagation = true;
        prevented = true;
      }
    }
    return false;
  };
  let scopeObj = map[scope],
    baseName,
    shiftName;
  if (scopeObj) {
    if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
      handled = true;
    } else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) && !(browser.windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
      if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
        handled = true;
      } else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name && shiftName != baseName && runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
        handled = true;
      }
    } else if (isChar && event.shiftKey && runFor(scopeObj[prefix + modifiers(name, event, true)])) {
      handled = true;
    }
    if (!handled && runFor(scopeObj._any)) handled = true;
  }
  if (prevented) handled = true;
  if (handled && stopPropagation) event.stopPropagation();
  currentKeyEvent = null;
  return handled;
}
class RectangleMarker {
  constructor(className, left, top, width, height) {
    this.className = className;
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }
  draw() {
    let elt = document.createElement("div");
    elt.className = this.className;
    this.adjust(elt);
    return elt;
  }
  update(elt, prev) {
    if (prev.className != this.className) return false;
    this.adjust(elt);
    return true;
  }
  adjust(elt) {
    elt.style.left = this.left + "px";
    elt.style.top = this.top + "px";
    if (this.width != null) elt.style.width = this.width + "px";
    elt.style.height = this.height + "px";
  }
  eq(p) {
    return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height && this.className == p.className;
  }
  static forRange(view, className, range) {
    if (range.empty) {
      let pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (!pos) return [];
      let base = getBase(view);
      return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
    } else {
      return rectanglesForRange(view, className, range);
    }
  }
}
function getBase(view) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
  return {
    left: left - view.scrollDOM.scrollLeft * view.scaleX,
    top: rect.top - view.scrollDOM.scrollTop * view.scaleY
  };
}
function wrappedLine(view, pos, side, inside) {
  let coords = view.coordsAtPos(pos, side * 2);
  if (!coords) return inside;
  let editorRect = view.dom.getBoundingClientRect();
  let y = (coords.top + coords.bottom) / 2;
  let left = view.posAtCoords({
    x: editorRect.left + 1,
    y
  });
  let right = view.posAtCoords({
    x: editorRect.right - 1,
    y
  });
  if (left == null || right == null) return inside;
  return {
    from: Math.max(inside.from, Math.min(left, right)),
    to: Math.min(inside.to, Math.max(left, right))
  };
}
function rectanglesForRange(view, className, range) {
  if (range.to <= view.viewport.from || range.from >= view.viewport.to) return [];
  let from = Math.max(range.from, view.viewport.from),
    to = Math.min(range.to, view.viewport.to);
  let ltr = view.textDirection == Direction.LTR;
  let content = view.contentDOM,
    contentRect = content.getBoundingClientRect(),
    base = getBase(view);
  let lineElt = content.querySelector(".cm-line"),
    lineStyle = lineElt && window.getComputedStyle(lineElt);
  let leftSide = contentRect.left + (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
  let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
  let startBlock = blockAt(view, from),
    endBlock = blockAt(view, to);
  let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
  let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
  if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks)) visualStart = wrappedLine(view, from, 1, visualStart);
  if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks)) visualEnd = wrappedLine(view, to, -1, visualEnd);
  if (visualStart && visualEnd && visualStart.from == visualEnd.from && visualStart.to == visualEnd.to) {
    return pieces(drawForLine(range.from, range.to, visualStart));
  } else {
    let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
    let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
    let between = [];
    if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) || startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top) between.push(piece(leftSide, top.bottom, rightSide, bottom.top));else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text) top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
    return pieces(top).concat(between).concat(pieces(bottom));
  }
  function piece(left, top, right, bottom) {
    return new RectangleMarker(className, left - base.left, top - base.top, right - left, bottom - top);
  }
  function pieces(_ref6) {
    let {
      top,
      bottom,
      horizontal
    } = _ref6;
    let pieces = [];
    for (let i = 0; i < horizontal.length; i += 2) pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
    return pieces;
  }
  function drawForLine(from, to, line) {
    let top = 1e9,
      bottom = -1e9,
      horizontal = [];
    function addSpan(from, fromOpen, to, toOpen, dir) {
      let fromCoords = view.coordsAtPos(from, from == line.to ? -2 : 2);
      let toCoords = view.coordsAtPos(to, to == line.from ? 2 : -2);
      if (!fromCoords || !toCoords) return;
      top = Math.min(fromCoords.top, toCoords.top, top);
      bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
      if (dir == Direction.LTR) horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);else horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
    }
    let start = from !== null && from !== void 0 ? from : line.from,
      end = to !== null && to !== void 0 ? to : line.to;
    for (var _iterator69 = _createForOfIteratorHelperLoose(view.visibleRanges), _step69; !(_step69 = _iterator69()).done;) {
      let r = _step69.value;
      if (r.to > start && r.from < end) {
        for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
          let docLine = view.state.doc.lineAt(pos);
          for (var _iterator70 = _createForOfIteratorHelperLoose(view.bidiSpans(docLine)), _step70; !(_step70 = _iterator70()).done;) {
            let span = _step70.value;
            let spanFrom = span.from + docLine.from,
              spanTo = span.to + docLine.from;
            if (spanFrom >= endPos) break;
            if (spanTo > pos) addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
          }
          pos = docLine.to + 1;
          if (pos >= endPos) break;
        }
      }
    }
    if (horizontal.length == 0) addSpan(start, from == null, end, to == null, view.textDirection);
    return {
      top,
      bottom,
      horizontal
    };
  }
  function drawForWidget(block, top) {
    let y = contentRect.top + (top ? block.top : block.bottom);
    return {
      top: y,
      bottom: y,
      horizontal: []
    };
  }
}
function sameMarker(a, b) {
  return a.constructor == b.constructor && a.eq(b);
}
class LayerView {
  constructor(view, layer) {
    this.view = view;
    this.layer = layer;
    this.drawn = [];
    this.scaleX = 1;
    this.scaleY = 1;
    this.measureReq = {
      read: this.measure.bind(this),
      write: this.draw.bind(this)
    };
    this.dom = view.scrollDOM.appendChild(document.createElement("div"));
    this.dom.classList.add("cm-layer");
    if (layer.above) this.dom.classList.add("cm-layer-above");
    if (layer.class) this.dom.classList.add(layer.class);
    this.scale();
    this.dom.setAttribute("aria-hidden", "true");
    this.setOrder(view.state);
    view.requestMeasure(this.measureReq);
    if (layer.mount) layer.mount(this.dom, view);
  }
  update(update) {
    if (update.startState.facet(layerOrder) != update.state.facet(layerOrder)) this.setOrder(update.state);
    if (this.layer.update(update, this.dom) || update.geometryChanged) {
      this.scale();
      update.view.requestMeasure(this.measureReq);
    }
  }
  docViewUpdate(view) {
    if (this.layer.updateOnDocViewUpdate !== false) view.requestMeasure(this.measureReq);
  }
  setOrder(state) {
    let pos = 0,
      order = state.facet(layerOrder);
    while (pos < order.length && order[pos] != this.layer) pos++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  scale() {
    let {
      scaleX,
      scaleY
    } = this.view;
    if (scaleX != this.scaleX || scaleY != this.scaleY) {
      this.scaleX = scaleX;
      this.scaleY = scaleY;
      this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
    }
  }
  draw(markers) {
    if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
      let old = this.dom.firstChild,
        oldI = 0;
      for (var _iterator71 = _createForOfIteratorHelperLoose(markers), _step71; !(_step71 = _iterator71()).done;) {
        let marker = _step71.value;
        if (marker.update && old && marker.constructor && this.drawn[oldI].constructor && marker.update(old, this.drawn[oldI])) {
          old = old.nextSibling;
          oldI++;
        } else {
          this.dom.insertBefore(marker.draw(), old);
        }
      }
      while (old) {
        let next = old.nextSibling;
        old.remove();
        old = next;
      }
      this.drawn = markers;
    }
  }
  destroy() {
    if (this.layer.destroy) this.layer.destroy(this.dom, this.view);
    this.dom.remove();
  }
}
const layerOrder = state_dist/* Facet */.sj.define();
function dist_layer(config) {
  return [ViewPlugin.define(v => new LayerView(v, config)), layerOrder.of(config)];
}
const CanHidePrimary = !(browser.ios && browser.webkit && browser.webkit_version < 534);
const selectionConfig = state_dist/* Facet */.sj.define({
  combine(configs) {
    return (0,state_dist/* combineConfig */.QR)(configs, {
      cursorBlinkRate: 1200,
      drawRangeCursor: true
    }, {
      cursorBlinkRate: (a, b) => Math.min(a, b),
      drawRangeCursor: (a, b) => a || b
    });
  }
});
function drawSelection(config) {
  if (config === void 0) {
    config = {};
  }
  return [selectionConfig.of(config), cursorLayer, selectionLayer, hideNativeSelection, nativeSelectionHidden.of(true)];
}
function getDrawSelectionConfig(state) {
  return state.facet(selectionConfig);
}
function configChanged(update) {
  return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = dist_layer({
  above: true,
  markers(view) {
    let {
        state
      } = view,
      conf = state.facet(selectionConfig);
    let cursors = [];
    for (var _iterator72 = _createForOfIteratorHelperLoose(state.selection.ranges), _step72; !(_step72 = _iterator72()).done;) {
      let r = _step72.value;
      let prim = r == state.selection.main;
      if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
        let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
        let cursor = r.empty ? r : state_dist/* EditorSelection */.OF.cursor(r.head, r.head > r.anchor ? -1 : 1);
        for (var _iterator73 = _createForOfIteratorHelperLoose(RectangleMarker.forRange(view, className, cursor)), _step73; !(_step73 = _iterator73()).done;) {
          let piece = _step73.value;
          cursors.push(piece);
        }
      }
    }
    return cursors;
  },
  update(update, dom) {
    if (update.transactions.some(tr => tr.selection)) dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
    let confChange = configChanged(update);
    if (confChange) setBlinkRate(update.state, dom);
    return update.docChanged || update.selectionSet || confChange;
  },
  mount(dom, view) {
    setBlinkRate(view.state, dom);
  },
  class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
  dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = dist_layer({
  above: false,
  markers(view) {
    return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r)).reduce((a, b) => a.concat(b));
  },
  update(update, dom) {
    return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
  },
  class: "cm-selectionLayer"
});
const themeSpec = {
  ".cm-line": {
    "& ::selection, &::selection": {
      backgroundColor: "transparent !important"
    }
  },
  ".cm-content": {
    "& :focus": {
      caretColor: "initial !important",
      "&::selection, & ::selection": {
        backgroundColor: "Highlight !important"
      }
    }
  }
};
if (CanHidePrimary) themeSpec[".cm-line"].caretColor = themeSpec[".cm-content"].caretColor = "transparent !important";
const hideNativeSelection = state_dist/* Prec */.Nb.highest(EditorView.theme(themeSpec));
const setDropCursorPos = state_dist/* StateEffect */.Pe.define({
  map(pos, mapping) {
    return pos == null ? null : mapping.mapPos(pos);
  }
});
const dropCursorPos = state_dist/* StateField */.sU.define({
  create() {
    return null;
  },
  update(pos, tr) {
    if (pos != null) pos = tr.changes.mapPos(pos);
    return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
  }
});
const drawDropCursor = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.cursor = null;
    this.measureReq = {
      read: this.readPos.bind(this),
      write: this.drawCursor.bind(this)
    };
  }
  update(update) {
    var _a;
    let cursorPos = update.state.field(dropCursorPos);
    if (cursorPos == null) {
      if (this.cursor != null) {
        (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
        this.cursor = null;
      }
    } else {
      if (!this.cursor) {
        this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
        this.cursor.className = "cm-dropCursor";
      }
      if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged) this.view.requestMeasure(this.measureReq);
    }
  }
  readPos() {
    let {
      view
    } = this;
    let pos = view.state.field(dropCursorPos);
    let rect = pos != null && view.coordsAtPos(pos);
    if (!rect) return null;
    let outer = view.scrollDOM.getBoundingClientRect();
    return {
      left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
      top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
      height: rect.bottom - rect.top
    };
  }
  drawCursor(pos) {
    if (this.cursor) {
      let {
        scaleX,
        scaleY
      } = this.view;
      if (pos) {
        this.cursor.style.left = pos.left / scaleX + "px";
        this.cursor.style.top = pos.top / scaleY + "px";
        this.cursor.style.height = pos.height / scaleY + "px";
      } else {
        this.cursor.style.left = "-100000px";
      }
    }
  }
  destroy() {
    if (this.cursor) this.cursor.remove();
  }
  setDropPos(pos) {
    if (this.view.state.field(dropCursorPos) != pos) this.view.dispatch({
      effects: setDropCursorPos.of(pos)
    });
  }
}, {
  eventObservers: {
    dragover(event) {
      this.setDropPos(this.view.posAtCoords({
        x: event.clientX,
        y: event.clientY
      }));
    },
    dragleave(event) {
      if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget)) this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function dropCursor() {
  return [dropCursorPos, drawDropCursor];
}
function iterMatches(doc, re, from, to, f) {
  re.lastIndex = 0;
  for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
    if (!cursor.lineBreak) while (m = re.exec(cursor.value)) f(pos + m.index, m);
  }
}
function matchRanges(view, maxLength) {
  let visible = view.visibleRanges;
  if (visible.length == 1 && visible[0].from == view.viewport.from && visible[0].to == view.viewport.to) return visible;
  let result = [];
  for (var _iterator74 = _createForOfIteratorHelperLoose(visible), _step74; !(_step74 = _iterator74()).done;) {
    let {
      from,
      to
    } = _step74.value;
    from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
    to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
    if (result.length && result[result.length - 1].to >= from) result[result.length - 1].to = to;else result.push({
      from,
      to
    });
  }
  return result;
}
class MatchDecorator {
  constructor(config) {
    const {
      regexp,
      decoration,
      decorate,
      boundary,
      maxLength = 1000
    } = config;
    if (!regexp.global) throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    this.regexp = regexp;
    if (decorate) {
      this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
    } else if (typeof decoration == "function") {
      this.addMatch = (match, view, from, add) => {
        let deco = decoration(match, view, from);
        if (deco) add(from, from + match[0].length, deco);
      };
    } else if (decoration) {
      this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
    } else {
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    }
    this.boundary = boundary;
    this.maxLength = maxLength;
  }
  createDeco(view) {
    let build = new state_dist/* RangeSetBuilder */.vB(),
      add = build.add.bind(build);
    for (var _iterator75 = _createForOfIteratorHelperLoose(matchRanges(view, this.maxLength)), _step75; !(_step75 = _iterator75()).done;) {
      let {
        from,
        to
      } = _step75.value;
      iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
    }
    return build.finish();
  }
  updateDeco(update, deco) {
    let changeFrom = 1e9,
      changeTo = -1;
    if (update.docChanged) update.changes.iterChanges((_f, _t, from, to) => {
      if (to >= update.view.viewport.from && from <= update.view.viewport.to) {
        changeFrom = Math.min(from, changeFrom);
        changeTo = Math.max(to, changeTo);
      }
    });
    if (update.viewportMoved || changeTo - changeFrom > 1000) return this.createDeco(update.view);
    if (changeTo > -1) return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
    return deco;
  }
  updateRange(view, deco, updateFrom, updateTo) {
    for (var _iterator76 = _createForOfIteratorHelperLoose(view.visibleRanges), _step76; !(_step76 = _iterator76()).done;) {
      let r = _step76.value;
      let from = Math.max(r.from, updateFrom),
        to = Math.min(r.to, updateTo);
      if (to > from) {
        let fromLine = view.state.doc.lineAt(from),
          toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
        let start = Math.max(r.from, fromLine.from),
          end = Math.min(r.to, toLine.to);
        if (this.boundary) {
          for (; from > fromLine.from; from--) if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
            start = from;
            break;
          }
          for (; to < toLine.to; to++) if (this.boundary.test(toLine.text[to - toLine.from])) {
            end = to;
            break;
          }
        }
        let ranges = [],
          m;
        let add = (from, to, deco) => ranges.push(deco.range(from, to));
        if (fromLine == toLine) {
          this.regexp.lastIndex = start - fromLine.from;
          while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from) this.addMatch(m, view, m.index + fromLine.from, add);
        } else {
          iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
        }
        deco = deco.update({
          filterFrom: start,
          filterTo: end,
          filter: (from, to) => from < start || to > end,
          add: ranges
        });
      }
    }
    return deco;
  }
}
const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
  var _a;
  if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
    let styles = document.body.style;
    _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
  }
  return _supportsTabSize || false;
}
const specialCharConfig = state_dist/* Facet */.sj.define({
  combine(configs) {
    let config = (0,state_dist/* combineConfig */.QR)(configs, {
      render: null,
      specialChars: Specials,
      addSpecialChars: null
    });
    if (config.replaceTabs = !supportsTabSize()) config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
    if (config.addSpecialChars) config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
    return config;
  }
});
function highlightSpecialChars(config) {
  if (config === void 0) {
    config = {};
  }
  return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
  return _plugin || (_plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.decorations = Decoration.none;
      this.decorationCache = Object.create(null);
      this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
      this.decorations = this.decorator.createDeco(view);
    }
    makeDecorator(conf) {
      return new MatchDecorator({
        regexp: conf.specialChars,
        decoration: (m, view, pos) => {
          let {
            doc
          } = view.state;
          let code = (0,state_dist/* codePointAt */.vS)(m[0], 0);
          if (code == 9) {
            let line = doc.lineAt(pos);
            let size = view.state.tabSize,
              col = (0,state_dist/* countColumn */.y$)(line.text, size, pos - line.from);
            return Decoration.replace({
              widget: new TabWidget((size - col % size) * this.view.defaultCharacterWidth / this.view.scaleX)
            });
          }
          return this.decorationCache[code] || (this.decorationCache[code] = Decoration.replace({
            widget: new SpecialCharWidget(conf, code)
          }));
        },
        boundary: conf.replaceTabs ? undefined : /[^]/
      });
    }
    update(update) {
      let conf = update.state.facet(specialCharConfig);
      if (update.startState.facet(specialCharConfig) != conf) {
        this.decorator = this.makeDecorator(conf);
        this.decorations = this.decorator.createDeco(update.view);
      } else {
        this.decorations = this.decorator.updateDeco(update, this.decorations);
      }
    }
  }, {
    decorations: v => v.decorations
  }));
}
const DefaultPlaceholder = "\u2022";
function placeholder$1(code) {
  if (code >= 32) return DefaultPlaceholder;
  if (code == 10) return "\u2424";
  return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends WidgetType {
  constructor(options, code) {
    super();
    this.options = options;
    this.code = code;
  }
  eq(other) {
    return other.code == this.code;
  }
  toDOM(view) {
    let ph = placeholder$1(this.code);
    let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
    let custom = this.options.render && this.options.render(this.code, desc, ph);
    if (custom) return custom;
    let span = document.createElement("span");
    span.textContent = ph;
    span.title = desc;
    span.setAttribute("aria-label", desc);
    span.className = "cm-specialChar";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}
class TabWidget extends WidgetType {
  constructor(width) {
    super();
    this.width = width;
  }
  eq(other) {
    return other.width == this.width;
  }
  toDOM() {
    let span = document.createElement("span");
    span.textContent = "\t";
    span.className = "cm-tab";
    span.style.width = this.width + "px";
    return span;
  }
  ignoreEvent() {
    return false;
  }
}
const dist_plugin = ViewPlugin.fromClass(class {
  constructor() {
    this.height = 1000;
    this.attrs = {
      style: "padding-bottom: 1000px"
    };
  }
  update(update) {
    let {
      view
    } = update;
    let height = view.viewState.editorHeight - view.defaultLineHeight - view.documentPadding.top - 0.5;
    if (height >= 0 && height != this.height) {
      this.height = height;
      this.attrs = {
        style: `padding-bottom: ${height}px`
      };
    }
  }
});
function scrollPastEnd() {
  return [dist_plugin, contentAttributes.of(view => {
    var _a;
    return ((_a = view.plugin(dist_plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null;
  })];
}
function highlightActiveLine() {
  return activeLineHighlighter;
}
const lineDeco = Decoration.line({
  class: "cm-activeLine"
});
const activeLineHighlighter = ViewPlugin.fromClass(class {
  constructor(view) {
    this.decorations = this.getDeco(view);
  }
  update(update) {
    if (update.docChanged || update.selectionSet) this.decorations = this.getDeco(update.view);
  }
  getDeco(view) {
    let lastLineStart = -1,
      deco = [];
    for (var _iterator77 = _createForOfIteratorHelperLoose(view.state.selection.ranges), _step77; !(_step77 = _iterator77()).done;) {
      let r = _step77.value;
      let line = view.lineBlockAt(r.head);
      if (line.from > lastLineStart) {
        deco.push(lineDeco.range(line.from));
        lastLineStart = line.from;
      }
    }
    return Decoration.set(deco);
  }
}, {
  decorations: v => v.decorations
});
class Placeholder extends WidgetType {
  constructor(content) {
    super();
    this.content = content;
  }
  toDOM(view) {
    let wrap = document.createElement("span");
    wrap.className = "cm-placeholder";
    wrap.style.pointerEvents = "none";
    wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : typeof this.content == "function" ? this.content(view) : this.content.cloneNode(true));
    if (typeof this.content == "string") wrap.setAttribute("aria-label", "placeholder " + this.content);else wrap.setAttribute("aria-hidden", "true");
    return wrap;
  }
  coordsAt(dom) {
    let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
    if (!rects.length) return null;
    let style = window.getComputedStyle(dom.parentNode);
    let rect = flattenRect(rects[0], style.direction != "rtl");
    let lineHeight = parseInt(style.lineHeight);
    if (rect.bottom - rect.top > lineHeight * 1.5) return {
      left: rect.left,
      right: rect.right,
      top: rect.top,
      bottom: rect.top + lineHeight
    };
    return rect;
  }
  ignoreEvent() {
    return false;
  }
}
function placeholder(content) {
  return ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.placeholder = content ? Decoration.set([Decoration.widget({
        widget: new Placeholder(content),
        side: 1
      }).range(0)]) : Decoration.none;
    }
    get decorations() {
      return this.view.state.doc.length ? Decoration.none : this.placeholder;
    }
  }, {
    decorations: v => v.decorations
  });
}
const MaxOff = 2000;
function rectangleFor(state, a, b) {
  let startLine = Math.min(a.line, b.line),
    endLine = Math.max(a.line, b.line);
  let ranges = [];
  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
    let startOff = Math.min(a.off, b.off),
      endOff = Math.max(a.off, b.off);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      if (line.length <= endOff) ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));
    }
  } else {
    let startCol = Math.min(a.col, b.col),
      endCol = Math.max(a.col, b.col);
    for (let i = startLine; i <= endLine; i++) {
      let line = state.doc.line(i);
      let start = findColumn(line.text, startCol, state.tabSize, true);
      if (start < 0) {
        ranges.push(EditorSelection.cursor(line.to));
      } else {
        let end = findColumn(line.text, endCol, state.tabSize);
        ranges.push(EditorSelection.range(line.from + start, line.from + end));
      }
    }
  }
  return ranges;
}
function absoluteColumn(view, x) {
  let ref = view.coordsAtPos(view.viewport.from);
  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
  let offset = view.posAtCoords({
    x: event.clientX,
    y: event.clientY
  }, false);
  let line = view.state.doc.lineAt(offset),
    off = offset - line.from;
  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);
  return {
    line: line.number,
    col,
    off
  };
}
function rectangleSelectionStyle(view, event) {
  let start = getPos(view, event),
    startSel = view.state.selection;
  if (!start) return null;
  return {
    update(update) {
      if (update.docChanged) {
        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
        let newLine = update.state.doc.lineAt(newStart);
        start = {
          line: newLine.number,
          col: start.col,
          off: Math.min(start.off, newLine.length)
        };
        startSel = startSel.map(update.changes);
      }
    },
    get(event, _extend, multiple) {
      let cur = getPos(view, event);
      if (!cur) return startSel;
      let ranges = rectangleFor(view.state, start, cur);
      if (!ranges.length) return startSel;
      if (multiple) return EditorSelection.create(ranges.concat(startSel.ranges));else return EditorSelection.create(ranges);
    }
  };
}
function rectangularSelection(options) {
  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
  Alt: [18, e => !!e.altKey],
  Control: [17, e => !!e.ctrlKey],
  Shift: [16, e => !!e.shiftKey],
  Meta: [91, e => !!e.metaKey]
};
const showCrosshair = {
  style: "cursor: crosshair"
};
function crosshairCursor(options) {
  if (options === void 0) {
    options = {};
  }
  let [code, getter] = keys[options.key || "Alt"];
  let plugin = ViewPlugin.fromClass(class {
    constructor(view) {
      this.view = view;
      this.isDown = false;
    }
    set(isDown) {
      if (this.isDown != isDown) {
        this.isDown = isDown;
        this.view.update([]);
      }
    }
  }, {
    eventObservers: {
      keydown(e) {
        this.set(e.keyCode == code || getter(e));
      },
      keyup(e) {
        if (e.keyCode == code || !getter(e)) this.set(false);
      },
      mousemove(e) {
        this.set(getter(e));
      }
    }
  });
  return [plugin, EditorView.contentAttributes.of(view => {
    var _a;
    return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null;
  })];
}
const Outside = "-10000px";
class TooltipViewManager {
  constructor(view, facet, createTooltipView, removeTooltipView) {
    this.facet = facet;
    this.createTooltipView = createTooltipView;
    this.removeTooltipView = removeTooltipView;
    this.input = view.state.facet(facet);
    this.tooltips = this.input.filter(t => t);
    let prev = null;
    this.tooltipViews = this.tooltips.map(t => prev = createTooltipView(t, prev));
  }
  update(update, above) {
    var _a;
    let input = update.state.facet(this.facet);
    let tooltips = input.filter(x => x);
    if (input === this.input) {
      for (var _iterator78 = _createForOfIteratorHelperLoose(this.tooltipViews), _step78; !(_step78 = _iterator78()).done;) {
        let t = _step78.value;
        if (t.update) t.update(update);
      }
      return false;
    }
    let tooltipViews = [],
      newAbove = above ? [] : null;
    for (let i = 0; i < tooltips.length; i++) {
      let tip = tooltips[i],
        known = -1;
      if (!tip) continue;
      for (let i = 0; i < this.tooltips.length; i++) {
        let other = this.tooltips[i];
        if (other && other.create == tip.create) known = i;
      }
      if (known < 0) {
        tooltipViews[i] = this.createTooltipView(tip, i ? tooltipViews[i - 1] : null);
        if (newAbove) newAbove[i] = !!tip.above;
      } else {
        let tooltipView = tooltipViews[i] = this.tooltipViews[known];
        if (newAbove) newAbove[i] = above[known];
        if (tooltipView.update) tooltipView.update(update);
      }
    }
    for (var _iterator79 = _createForOfIteratorHelperLoose(this.tooltipViews), _step79; !(_step79 = _iterator79()).done;) {
      let t = _step79.value;
      if (tooltipViews.indexOf(t) < 0) {
        this.removeTooltipView(t);
        (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
      }
    }
    if (above) {
      newAbove.forEach((val, i) => above[i] = val);
      above.length = newAbove.length;
    }
    this.input = input;
    this.tooltips = tooltips;
    this.tooltipViews = tooltipViews;
    return true;
  }
}
function tooltips(config) {
  if (config === void 0) {
    config = {};
  }
  return tooltipConfig.of(config);
}
function windowSpace(view) {
  let docElt = view.dom.ownerDocument.documentElement;
  return {
    top: 0,
    left: 0,
    bottom: docElt.clientHeight,
    right: docElt.clientWidth
  };
}
const tooltipConfig = state_dist/* Facet */.sj.define({
  combine: values => {
    var _a, _b, _c;
    return {
      position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
      parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
      tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace
    };
  }
});
const knownHeight = new WeakMap();
const tooltipPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.above = [];
    this.inView = true;
    this.madeAbsolute = false;
    this.lastTransaction = 0;
    this.measureTimeout = -1;
    let config = view.state.facet(tooltipConfig);
    this.position = config.position;
    this.parent = config.parent;
    this.classes = view.themeClasses;
    this.createContainer();
    this.measureReq = {
      read: this.readMeasure.bind(this),
      write: this.writeMeasure.bind(this),
      key: this
    };
    this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null;
    this.manager = new TooltipViewManager(view, showTooltip, (t, p) => this.createTooltip(t, p), t => {
      if (this.resizeObserver) this.resizeObserver.unobserve(t.dom);
      t.dom.remove();
    });
    this.above = this.manager.tooltips.map(t => !!t.above);
    this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
      if (Date.now() > this.lastTransaction - 50 && entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1) this.measureSoon();
    }, {
      threshold: [1]
    }) : null;
    this.observeIntersection();
    view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
    this.maybeMeasure();
  }
  createContainer() {
    if (this.parent) {
      this.container = document.createElement("div");
      this.container.style.position = "relative";
      this.container.className = this.view.themeClasses;
      this.parent.appendChild(this.container);
    } else {
      this.container = this.view.dom;
    }
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (var _iterator80 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step80; !(_step80 = _iterator80()).done;) {
        let tooltip = _step80.value;
        this.intersectionObserver.observe(tooltip.dom);
      }
    }
  }
  measureSoon() {
    if (this.measureTimeout < 0) this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1;
      this.maybeMeasure();
    }, 50);
  }
  update(update) {
    if (update.transactions.length) this.lastTransaction = Date.now();
    let updated = this.manager.update(update, this.above);
    if (updated) this.observeIntersection();
    let shouldMeasure = updated || update.geometryChanged;
    let newConfig = update.state.facet(tooltipConfig);
    if (newConfig.position != this.position && !this.madeAbsolute) {
      this.position = newConfig.position;
      for (var _iterator81 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step81; !(_step81 = _iterator81()).done;) {
        let t = _step81.value;
        t.dom.style.position = this.position;
      }
      shouldMeasure = true;
    }
    if (newConfig.parent != this.parent) {
      if (this.parent) this.container.remove();
      this.parent = newConfig.parent;
      this.createContainer();
      for (var _iterator82 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step82; !(_step82 = _iterator82()).done;) {
        let t = _step82.value;
        this.container.appendChild(t.dom);
      }
      shouldMeasure = true;
    } else if (this.parent && this.view.themeClasses != this.classes) {
      this.classes = this.container.className = this.view.themeClasses;
    }
    if (shouldMeasure) this.maybeMeasure();
  }
  createTooltip(tooltip, prev) {
    let tooltipView = tooltip.create(this.view);
    let before = prev ? prev.dom : null;
    tooltipView.dom.classList.add("cm-tooltip");
    if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let arrow = document.createElement("div");
      arrow.className = "cm-tooltip-arrow";
      tooltipView.dom.appendChild(arrow);
    }
    tooltipView.dom.style.position = this.position;
    tooltipView.dom.style.top = Outside;
    tooltipView.dom.style.left = "0px";
    this.container.insertBefore(tooltipView.dom, before);
    if (tooltipView.mount) tooltipView.mount(this.view);
    if (this.resizeObserver) this.resizeObserver.observe(tooltipView.dom);
    return tooltipView;
  }
  destroy() {
    var _a, _b, _c;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (var _iterator83 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step83; !(_step83 = _iterator83()).done;) {
      let tooltipView = _step83.value;
      tooltipView.dom.remove();
      (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
    }
    if (this.parent) this.container.remove();
    (_b = this.resizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
    (_c = this.intersectionObserver) === null || _c === void 0 ? void 0 : _c.disconnect();
    clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let scaleX = 1,
      scaleY = 1,
      makeAbsolute = false;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let {
        dom
      } = this.manager.tooltipViews[0];
      if (browser.gecko) {
        makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
      } else if (dom.style.top == Outside && dom.style.left == "0px") {
        let rect = dom.getBoundingClientRect();
        makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;
      }
    }
    if (makeAbsolute || this.position == "absolute") {
      if (this.parent) {
        let rect = this.parent.getBoundingClientRect();
        if (rect.width && rect.height) {
          scaleX = rect.width / this.parent.offsetWidth;
          scaleY = rect.height / this.parent.offsetHeight;
        }
      } else {
        ({
          scaleX,
          scaleY
        } = this.view.viewState);
      }
    }
    let visible = this.view.scrollDOM.getBoundingClientRect(),
      margins = getScrollMargins(this.view);
    return {
      visible: {
        left: visible.left + margins.left,
        top: visible.top + margins.top,
        right: visible.right - margins.right,
        bottom: visible.bottom - margins.bottom
      },
      parent: this.parent ? this.container.getBoundingClientRect() : this.view.dom.getBoundingClientRect(),
      pos: this.manager.tooltips.map((t, i) => {
        let tv = this.manager.tooltipViews[i];
        return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
      }),
      size: this.manager.tooltipViews.map(_ref7 => {
        let {
          dom
        } = _ref7;
        return dom.getBoundingClientRect();
      }),
      space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
      scaleX,
      scaleY,
      makeAbsolute
    };
  }
  writeMeasure(measured) {
    var _a;
    if (measured.makeAbsolute) {
      this.madeAbsolute = true;
      this.position = "absolute";
      for (var _iterator84 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step84; !(_step84 = _iterator84()).done;) {
        let t = _step84.value;
        t.dom.style.position = "absolute";
      }
    }
    let {
      visible,
      space,
      scaleX,
      scaleY
    } = measured;
    let others = [];
    for (let i = 0; i < this.manager.tooltips.length; i++) {
      let tooltip = this.manager.tooltips[i],
        tView = this.manager.tooltipViews[i],
        {
          dom
        } = tView;
      let pos = measured.pos[i],
        size = measured.size[i];
      if (!pos || tooltip.clip !== false && (pos.bottom <= Math.max(visible.top, space.top) || pos.top >= Math.min(visible.bottom, space.bottom) || pos.right < Math.max(visible.left, space.left) - .1 || pos.left > Math.min(visible.right, space.right) + .1)) {
        dom.style.top = Outside;
        continue;
      }
      let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
      let arrowHeight = arrow ? 7 : 0;
      let width = size.right - size.left,
        height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
      let offset = tView.offset || noOffset,
        ltr = this.view.textDirection == Direction.LTR;
      let left = size.width > space.right - space.left ? ltr ? space.left : space.right - size.width : ltr ? Math.max(space.left, Math.min(pos.left - (arrow ? 14 : 0) + offset.x, space.right - width)) : Math.min(Math.max(space.left, pos.left - width + (arrow ? 14 : 0) - offset.x), space.right - width);
      let above = this.above[i];
      if (!tooltip.strictSide && (above ? pos.top - height - arrowHeight - offset.y < space.top : pos.bottom + height + arrowHeight + offset.y > space.bottom) && above == space.bottom - pos.bottom > pos.top - space.top) above = this.above[i] = !above;
      let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
      if (spaceVert < height && tView.resize !== false) {
        if (spaceVert < this.view.defaultLineHeight) {
          dom.style.top = Outside;
          continue;
        }
        knownHeight.set(tView, height);
        dom.style.height = (height = spaceVert) / scaleY + "px";
      } else if (dom.style.height) {
        dom.style.height = "";
      }
      let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
      let right = left + width;
      if (tView.overlap !== true) {
        for (var _iterator85 = _createForOfIteratorHelperLoose(others), _step85; !(_step85 = _iterator85()).done;) {
          let r = _step85.value;
          if (r.left < right && r.right > left && r.top < top + height && r.bottom > top) top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
        }
      }
      if (this.position == "absolute") {
        dom.style.top = (top - measured.parent.top) / scaleY + "px";
        setLeftStyle(dom, (left - measured.parent.left) / scaleX);
      } else {
        dom.style.top = top / scaleY + "px";
        setLeftStyle(dom, left / scaleX);
      }
      if (arrow) {
        let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 - 7);
        arrow.style.left = arrowLeft / scaleX + "px";
      }
      if (tView.overlap !== true) others.push({
        left,
        top,
        right,
        bottom: top + height
      });
      dom.classList.toggle("cm-tooltip-above", above);
      dom.classList.toggle("cm-tooltip-below", !above);
      if (tView.positioned) tView.positioned(measured.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length) {
      if (this.view.inView) this.view.requestMeasure(this.measureReq);
      if (this.inView != this.view.inView) {
        this.inView = this.view.inView;
        if (!this.inView) {
          for (var _iterator86 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step86; !(_step86 = _iterator86()).done;) {
            let tv = _step86.value;
            tv.dom.style.top = Outside;
          }
        }
      }
    }
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
});
function setLeftStyle(elt, value) {
  let current = parseInt(elt.style.left, 10);
  if (isNaN(current) || Math.abs(value - current) > 1) elt.style.left = value + "px";
}
const baseTheme = EditorView.baseTheme({
  ".cm-tooltip": {
    zIndex: 500,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
});
const noOffset = {
  x: 0,
  y: 0
};
const showTooltip = state_dist/* Facet */.sj.define({
  enables: [tooltipPlugin, baseTheme]
});
const showHoverTooltip = state_dist/* Facet */.sj.define({
  combine: inputs => inputs.reduce((a, i) => a.concat(i), [])
});
class HoverTooltipHost {
  static create(view) {
    return new HoverTooltipHost(view);
  }
  constructor(view) {
    this.view = view;
    this.mounted = false;
    this.dom = document.createElement("div");
    this.dom.classList.add("cm-tooltip-hover");
    this.manager = new TooltipViewManager(view, showHoverTooltip, (t, p) => this.createHostedView(t, p), t => t.dom.remove());
  }
  createHostedView(tooltip, prev) {
    let hostedView = tooltip.create(this.view);
    hostedView.dom.classList.add("cm-tooltip-section");
    this.dom.insertBefore(hostedView.dom, prev ? prev.dom.nextSibling : this.dom.firstChild);
    if (this.mounted && hostedView.mount) hostedView.mount(this.view);
    return hostedView;
  }
  mount(view) {
    for (var _iterator87 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step87; !(_step87 = _iterator87()).done;) {
      let hostedView = _step87.value;
      if (hostedView.mount) hostedView.mount(view);
    }
    this.mounted = true;
  }
  positioned(space) {
    for (var _iterator88 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step88; !(_step88 = _iterator88()).done;) {
      let hostedView = _step88.value;
      if (hostedView.positioned) hostedView.positioned(space);
    }
  }
  update(update) {
    this.manager.update(update);
  }
  destroy() {
    var _a;
    for (var _iterator89 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step89; !(_step89 = _iterator89()).done;) {
      let t = _step89.value;
      (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
    }
  }
  passProp(name) {
    let value = undefined;
    for (var _iterator90 = _createForOfIteratorHelperLoose(this.manager.tooltipViews), _step90; !(_step90 = _iterator90()).done;) {
      let view = _step90.value;
      let given = view[name];
      if (given !== undefined) {
        if (value === undefined) value = given;else if (value !== given) return undefined;
      }
    }
    return value;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const showHoverTooltipHost = showTooltip.compute([showHoverTooltip], state => {
  let tooltips = state.facet(showHoverTooltip);
  if (tooltips.length === 0) return null;
  return {
    pos: Math.min(...tooltips.map(t => t.pos)),
    end: Math.max(...tooltips.map(t => {
      var _a;
      return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos;
    })),
    create: HoverTooltipHost.create,
    above: tooltips[0].above,
    arrow: tooltips.some(t => t.arrow)
  };
});
class HoverPlugin {
  constructor(view, source, field, setHover, hoverTime) {
    this.view = view;
    this.source = source;
    this.field = field;
    this.setHover = setHover;
    this.hoverTime = hoverTime;
    this.hoverTimeout = -1;
    this.restartTimeout = -1;
    this.pending = null;
    this.lastMove = {
      x: 0,
      y: 0,
      target: view.dom,
      time: 0
    };
    this.checkHover = this.checkHover.bind(this);
    view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
    view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    if (this.pending) {
      this.pending = null;
      clearTimeout(this.restartTimeout);
      this.restartTimeout = setTimeout(() => this.startHover(), 20);
    }
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    this.hoverTimeout = -1;
    if (this.active.length) return;
    let hovered = Date.now() - this.lastMove.time;
    if (hovered < this.hoverTime) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);else this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let {
      view,
      lastMove
    } = this;
    let desc = view.docView.nearest(lastMove.target);
    if (!desc) return;
    let pos,
      side = 1;
    if (desc instanceof WidgetView) {
      pos = desc.posAtStart;
    } else {
      pos = view.posAtCoords(lastMove);
      if (pos == null) return;
      let posCoords = view.coordsAtPos(pos);
      if (!posCoords || lastMove.y < posCoords.top || lastMove.y > posCoords.bottom || lastMove.x < posCoords.left - view.defaultCharacterWidth || lastMove.x > posCoords.right + view.defaultCharacterWidth) return;
      let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
      let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
      side = lastMove.x < posCoords.left ? -rtl : rtl;
    }
    let open = this.source(view, pos, side);
    if (open === null || open === void 0 ? void 0 : open.then) {
      let pending = this.pending = {
        pos
      };
      open.then(result => {
        if (this.pending == pending) {
          this.pending = null;
          if (result && !(Array.isArray(result) && !result.length)) view.dispatch({
            effects: this.setHover.of(Array.isArray(result) ? result : [result])
          });
        }
      }, e => logException(view.state, e, "hover tooltip"));
    } else if (open && !(Array.isArray(open) && !open.length)) {
      view.dispatch({
        effects: this.setHover.of(Array.isArray(open) ? open : [open])
      });
    }
  }
  get tooltip() {
    let plugin = this.view.plugin(tooltipPlugin);
    let index = plugin ? plugin.manager.tooltips.findIndex(t => t.create == HoverTooltipHost.create) : -1;
    return index > -1 ? plugin.manager.tooltipViews[index] : null;
  }
  mousemove(event) {
    var _a, _b;
    this.lastMove = {
      x: event.clientX,
      y: event.clientY,
      target: event.target,
      time: Date.now()
    };
    if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
    let {
      active,
      tooltip
    } = this;
    if (active.length && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
      let {
          pos
        } = active[0] || this.pending,
        end = (_b = (_a = active[0]) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : pos;
      if (pos == end ? this.view.posAtCoords(this.lastMove) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY)) {
        this.view.dispatch({
          effects: this.setHover.of([])
        });
        this.pending = null;
      }
    }
  }
  mouseleave(event) {
    clearTimeout(this.hoverTimeout);
    this.hoverTimeout = -1;
    let {
      active
    } = this;
    if (active.length) {
      let {
        tooltip
      } = this;
      let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
      if (!inTooltip) this.view.dispatch({
        effects: this.setHover.of([])
      });else this.watchTooltipLeave(tooltip.dom);
    }
  }
  watchTooltipLeave(tooltip) {
    let watch = event => {
      tooltip.removeEventListener("mouseleave", watch);
      if (this.active.length && !this.view.dom.contains(event.relatedTarget)) this.view.dispatch({
        effects: this.setHover.of([])
      });
    };
    tooltip.addEventListener("mouseleave", watch);
  }
  destroy() {
    clearTimeout(this.hoverTimeout);
    this.view.dom.removeEventListener("mouseleave", this.mouseleave);
    this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const tooltipMargin = 4;
function isInTooltip(tooltip, event) {
  let {
      left,
      right,
      top,
      bottom
    } = tooltip.getBoundingClientRect(),
    arrow;
  if (arrow = tooltip.querySelector(".cm-tooltip-arrow")) {
    let arrowRect = arrow.getBoundingClientRect();
    top = Math.min(arrowRect.top, top);
    bottom = Math.max(arrowRect.bottom, bottom);
  }
  return event.clientX >= left - tooltipMargin && event.clientX <= right + tooltipMargin && event.clientY >= top - tooltipMargin && event.clientY <= bottom + tooltipMargin;
}
function isOverRange(view, from, to, x, y, margin) {
  let rect = view.scrollDOM.getBoundingClientRect();
  let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
  if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y) return false;
  let pos = view.posAtCoords({
    x,
    y
  }, false);
  return pos >= from && pos <= to;
}
function hoverTooltip(source, options) {
  if (options === void 0) {
    options = {};
  }
  let setHover = StateEffect.define();
  let hoverState = StateField.define({
    create() {
      return [];
    },
    update(value, tr) {
      if (value.length) {
        if (options.hideOnChange && (tr.docChanged || tr.selection)) value = [];else if (options.hideOn) value = value.filter(v => !options.hideOn(tr, v));
        if (tr.docChanged) {
          let mapped = [];
          for (var _iterator91 = _createForOfIteratorHelperLoose(value), _step91; !(_step91 = _iterator91()).done;) {
            let tooltip = _step91.value;
            let newPos = tr.changes.mapPos(tooltip.pos, -1, MapMode.TrackDel);
            if (newPos != null) {
              let copy = Object.assign(Object.create(null), tooltip);
              copy.pos = newPos;
              if (copy.end != null) copy.end = tr.changes.mapPos(copy.end);
              mapped.push(copy);
            }
          }
          value = mapped;
        }
      }
      for (var _iterator92 = _createForOfIteratorHelperLoose(tr.effects), _step92; !(_step92 = _iterator92()).done;) {
        let effect = _step92.value;
        if (effect.is(setHover)) value = effect.value;
        if (effect.is(closeHoverTooltipEffect)) value = [];
      }
      return value;
    },
    provide: f => showHoverTooltip.from(f)
  });
  return {
    active: hoverState,
    extension: [hoverState, ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300)), showHoverTooltipHost]
  };
}
function getTooltip(view, tooltip) {
  let plugin = view.plugin(tooltipPlugin);
  if (!plugin) return null;
  let found = plugin.manager.tooltips.indexOf(tooltip);
  return found < 0 ? null : plugin.manager.tooltipViews[found];
}
function hasHoverTooltips(state) {
  return state.facet(showHoverTooltip).some(x => x);
}
const closeHoverTooltipEffect = state_dist/* StateEffect */.Pe.define();
const closeHoverTooltips = closeHoverTooltipEffect.of(null);
function repositionTooltips(view) {
  let plugin = view.plugin(tooltipPlugin);
  if (plugin) plugin.maybeMeasure();
}
const panelConfig = state_dist/* Facet */.sj.define({
  combine(configs) {
    let topContainer, bottomContainer;
    for (var _iterator93 = _createForOfIteratorHelperLoose(configs), _step93; !(_step93 = _iterator93()).done;) {
      let c = _step93.value;
      topContainer = topContainer || c.topContainer;
      bottomContainer = bottomContainer || c.bottomContainer;
    }
    return {
      topContainer,
      bottomContainer
    };
  }
});
function panels(config) {
  return config ? [panelConfig.of(config)] : [];
}
function getPanel(view, panel) {
  let plugin = view.plugin(panelPlugin);
  let index = plugin ? plugin.specs.indexOf(panel) : -1;
  return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = ViewPlugin.fromClass(class {
  constructor(view) {
    this.input = view.state.facet(showPanel);
    this.specs = this.input.filter(s => s);
    this.panels = this.specs.map(spec => spec(view));
    let conf = view.state.facet(panelConfig);
    this.top = new PanelGroup(view, true, conf.topContainer);
    this.bottom = new PanelGroup(view, false, conf.bottomContainer);
    this.top.sync(this.panels.filter(p => p.top));
    this.bottom.sync(this.panels.filter(p => !p.top));
    for (var _iterator94 = _createForOfIteratorHelperLoose(this.panels), _step94; !(_step94 = _iterator94()).done;) {
      let p = _step94.value;
      p.dom.classList.add("cm-panel");
      if (p.mount) p.mount();
    }
  }
  update(update) {
    let conf = update.state.facet(panelConfig);
    if (this.top.container != conf.topContainer) {
      this.top.sync([]);
      this.top = new PanelGroup(update.view, true, conf.topContainer);
    }
    if (this.bottom.container != conf.bottomContainer) {
      this.bottom.sync([]);
      this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
    }
    this.top.syncClasses();
    this.bottom.syncClasses();
    let input = update.state.facet(showPanel);
    if (input != this.input) {
      let specs = input.filter(x => x);
      let panels = [],
        top = [],
        bottom = [],
        mount = [];
      for (var _iterator95 = _createForOfIteratorHelperLoose(specs), _step95; !(_step95 = _iterator95()).done;) {
        let spec = _step95.value;
        let known = this.specs.indexOf(spec),
          panel;
        if (known < 0) {
          panel = spec(update.view);
          mount.push(panel);
        } else {
          panel = this.panels[known];
          if (panel.update) panel.update(update);
        }
        panels.push(panel);
        (panel.top ? top : bottom).push(panel);
      }
      this.specs = specs;
      this.panels = panels;
      this.top.sync(top);
      this.bottom.sync(bottom);
      for (var _i4 = 0, _mount = mount; _i4 < _mount.length; _i4++) {
        let p = _mount[_i4];
        p.dom.classList.add("cm-panel");
        if (p.mount) p.mount();
      }
    } else {
      for (var _iterator96 = _createForOfIteratorHelperLoose(this.panels), _step96; !(_step96 = _iterator96()).done;) {
        let p = _step96.value;
        if (p.update) p.update(update);
      }
    }
  }
  destroy() {
    this.top.sync([]);
    this.bottom.sync([]);
  }
}, {
  provide: plugin => EditorView.scrollMargins.of(view => {
    let value = view.plugin(plugin);
    return value && {
      top: value.top.scrollMargin(),
      bottom: value.bottom.scrollMargin()
    };
  })
});
class PanelGroup {
  constructor(view, top, container) {
    this.view = view;
    this.top = top;
    this.container = container;
    this.dom = undefined;
    this.classes = "";
    this.panels = [];
    this.syncClasses();
  }
  sync(panels) {
    for (var _iterator97 = _createForOfIteratorHelperLoose(this.panels), _step97; !(_step97 = _iterator97()).done;) {
      let p = _step97.value;
      if (p.destroy && panels.indexOf(p) < 0) p.destroy();
    }
    this.panels = panels;
    this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      if (this.dom) {
        this.dom.remove();
        this.dom = undefined;
      }
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div");
      this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
      this.dom.style[this.top ? "top" : "bottom"] = "0";
      let parent = this.container || this.view.dom;
      parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
    }
    let curDOM = this.dom.firstChild;
    for (var _iterator98 = _createForOfIteratorHelperLoose(this.panels), _step98; !(_step98 = _iterator98()).done;) {
      let panel = _step98.value;
      if (panel.dom.parentNode == this.dom) {
        while (curDOM != panel.dom) curDOM = rm(curDOM);
        curDOM = curDOM.nextSibling;
      } else {
        this.dom.insertBefore(panel.dom, curDOM);
      }
    }
    while (curDOM) curDOM = rm(curDOM);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!this.container || this.classes == this.view.themeClasses) return;
    for (var _iterator99 = _createForOfIteratorHelperLoose(this.classes.split(" ")), _step99; !(_step99 = _iterator99()).done;) {
      let cls = _step99.value;
      if (cls) this.container.classList.remove(cls);
    }
    for (var _iterator100 = _createForOfIteratorHelperLoose((this.classes = this.view.themeClasses).split(" ")), _step100; !(_step100 = _iterator100()).done;) {
      let cls = _step100.value;
      if (cls) this.container.classList.add(cls);
    }
  }
}
function rm(node) {
  let next = node.nextSibling;
  node.remove();
  return next;
}
const showPanel = state_dist/* Facet */.sj.define({
  enables: panelPlugin
});
class GutterMarker extends state_dist/* RangeValue */.FB {
  compare(other) {
    return this == other || this.constructor == other.constructor && this.eq(other);
  }
  eq(other) {
    return false;
  }
  destroy(dom) {}
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = state_dist/* MapMode */.iR.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
const gutterLineClass = state_dist/* Facet */.sj.define();
const gutterWidgetClass = state_dist/* Facet */.sj.define();
const defaults = {
  class: "",
  renderEmptyElements: false,
  elementStyle: "",
  markers: () => state_dist/* RangeSet */.om.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
};
const activeGutters = state_dist/* Facet */.sj.define();
function gutter(config) {
  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const unfixGutters = state_dist/* Facet */.sj.define({
  combine: values => values.some(x => x)
});
function gutters(config) {
  let result = [gutterView];
  if (config && config.fixed === false) result.push(unfixGutters.of(true));
  return result;
}
const gutterView = ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.prevViewport = view.viewport;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutters";
    this.dom.setAttribute("aria-hidden", "true");
    this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
    for (var _iterator101 = _createForOfIteratorHelperLoose(this.gutters), _step101; !(_step101 = _iterator101()).done;) {
      let gutter = _step101.value;
      this.dom.appendChild(gutter.dom);
    }
    this.fixed = !view.state.facet(unfixGutters);
    if (this.fixed) {
      this.dom.style.position = "sticky";
    }
    this.syncGutters(false);
    view.scrollDOM.insertBefore(this.dom, view.contentDOM);
  }
  update(update) {
    if (this.updateGutters(update)) {
      let vpA = this.prevViewport,
        vpB = update.view.viewport;
      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
    }
    if (update.geometryChanged) {
      this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + "px";
    }
    if (this.view.state.facet(unfixGutters) != !this.fixed) {
      this.fixed = !this.fixed;
      this.dom.style.position = this.fixed ? "sticky" : "";
    }
    this.prevViewport = update.view.viewport;
  }
  syncGutters(detach) {
    let after = this.dom.nextSibling;
    if (detach) this.dom.remove();
    let lineClasses = state_dist/* RangeSet */.om.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
    let classSet = [];
    let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
    for (var _iterator102 = _createForOfIteratorHelperLoose(this.view.viewportLineBlocks), _step102; !(_step102 = _iterator102()).done;) {
      let line = _step102.value;
      if (classSet.length) classSet = [];
      if (Array.isArray(line.type)) {
        let first = true;
        for (var _iterator104 = _createForOfIteratorHelperLoose(line.type), _step104; !(_step104 = _iterator104()).done;) {
          let b = _step104.value;
          if (b.type == BlockType.Text && first) {
            advanceCursor(lineClasses, classSet, b.from);
            for (var _iterator105 = _createForOfIteratorHelperLoose(contexts), _step105; !(_step105 = _iterator105()).done;) {
              let cx = _step105.value;
              cx.line(this.view, b, classSet);
            }
            first = false;
          } else if (b.widget) {
            for (var _iterator106 = _createForOfIteratorHelperLoose(contexts), _step106; !(_step106 = _iterator106()).done;) {
              let cx = _step106.value;
              cx.widget(this.view, b);
            }
          }
        }
      } else if (line.type == BlockType.Text) {
        advanceCursor(lineClasses, classSet, line.from);
        for (var _iterator107 = _createForOfIteratorHelperLoose(contexts), _step107; !(_step107 = _iterator107()).done;) {
          let cx = _step107.value;
          cx.line(this.view, line, classSet);
        }
      } else if (line.widget) {
        for (var _iterator108 = _createForOfIteratorHelperLoose(contexts), _step108; !(_step108 = _iterator108()).done;) {
          let cx = _step108.value;
          cx.widget(this.view, line);
        }
      }
    }
    for (var _iterator103 = _createForOfIteratorHelperLoose(contexts), _step103; !(_step103 = _iterator103()).done;) {
      let cx = _step103.value;
      cx.finish();
    }
    if (detach) this.view.scrollDOM.insertBefore(this.dom, after);
  }
  updateGutters(update) {
    let prev = update.startState.facet(activeGutters),
      cur = update.state.facet(activeGutters);
    let change = update.docChanged || update.heightChanged || update.viewportChanged || !state_dist/* RangeSet */.om.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
    if (prev == cur) {
      for (var _iterator109 = _createForOfIteratorHelperLoose(this.gutters), _step109; !(_step109 = _iterator109()).done;) {
        let gutter = _step109.value;
        if (gutter.update(update)) change = true;
      }
    } else {
      change = true;
      let gutters = [];
      for (var _iterator110 = _createForOfIteratorHelperLoose(cur), _step110; !(_step110 = _iterator110()).done;) {
        let conf = _step110.value;
        let known = prev.indexOf(conf);
        if (known < 0) {
          gutters.push(new SingleGutterView(this.view, conf));
        } else {
          this.gutters[known].update(update);
          gutters.push(this.gutters[known]);
        }
      }
      for (var _iterator111 = _createForOfIteratorHelperLoose(this.gutters), _step111; !(_step111 = _iterator111()).done;) {
        let g = _step111.value;
        g.dom.remove();
        if (gutters.indexOf(g) < 0) g.destroy();
      }
      for (var _i5 = 0, _gutters = gutters; _i5 < _gutters.length; _i5++) {
        let g = _gutters[_i5];
        this.dom.appendChild(g.dom);
      }
      this.gutters = gutters;
    }
    return change;
  }
  destroy() {
    for (var _iterator112 = _createForOfIteratorHelperLoose(this.gutters), _step112; !(_step112 = _iterator112()).done;) {
      let view = _step112.value;
      view.destroy();
    }
    this.dom.remove();
  }
}, {
  provide: plugin => EditorView.scrollMargins.of(view => {
    let value = view.plugin(plugin);
    if (!value || value.gutters.length == 0 || !value.fixed) return null;
    return view.textDirection == Direction.LTR ? {
      left: value.dom.offsetWidth * view.scaleX
    } : {
      right: value.dom.offsetWidth * view.scaleX
    };
  })
});
function asArray(val) {
  return Array.isArray(val) ? val : [val];
}
function advanceCursor(cursor, collect, pos) {
  while (cursor.value && cursor.from <= pos) {
    if (cursor.from == pos) collect.push(cursor.value);
    cursor.next();
  }
}
class UpdateContext {
  constructor(gutter, viewport, height) {
    this.gutter = gutter;
    this.height = height;
    this.i = 0;
    this.cursor = state_dist/* RangeSet */.om.iter(gutter.markers, viewport.from);
  }
  addElement(view, block, markers) {
    let {
        gutter
      } = this,
      above = (block.top - this.height) / view.scaleY,
      height = block.height / view.scaleY;
    if (this.i == gutter.elements.length) {
      let newElt = new GutterElement(view, height, above, markers);
      gutter.elements.push(newElt);
      gutter.dom.appendChild(newElt.dom);
    } else {
      gutter.elements[this.i].update(view, height, above, markers);
    }
    this.height = block.bottom;
    this.i++;
  }
  line(view, line, extraMarkers) {
    let localMarkers = [];
    advanceCursor(this.cursor, localMarkers, line.from);
    if (extraMarkers.length) localMarkers = localMarkers.concat(extraMarkers);
    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
    if (forLine) localMarkers.unshift(forLine);
    let gutter = this.gutter;
    if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;
    this.addElement(view, line, localMarkers);
  }
  widget(view, block) {
    let marker = this.gutter.config.widgetMarker(view, block.widget, block),
      markers = marker ? [marker] : null;
    for (var _iterator113 = _createForOfIteratorHelperLoose(view.state.facet(gutterWidgetClass)), _step113; !(_step113 = _iterator113()).done;) {
      let cls = _step113.value;
      let marker = cls(view, block.widget, block);
      if (marker) (markers || (markers = [])).push(marker);
    }
    if (markers) this.addElement(view, block, markers);
  }
  finish() {
    let gutter = this.gutter;
    while (gutter.elements.length > this.i) {
      let last = gutter.elements.pop();
      gutter.dom.removeChild(last.dom);
      last.destroy();
    }
  }
}
class SingleGutterView {
  constructor(view, config) {
    this.view = view;
    this.config = config;
    this.elements = [];
    this.spacer = null;
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let prop in config.domEventHandlers) {
      this.dom.addEventListener(prop, event => {
        let target = event.target,
          y;
        if (target != this.dom && this.dom.contains(target)) {
          while (target.parentNode != this.dom) target = target.parentNode;
          let rect = target.getBoundingClientRect();
          y = (rect.top + rect.bottom) / 2;
        } else {
          y = event.clientY;
        }
        let line = view.lineBlockAtHeight(y - view.documentTop);
        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();
      });
    }
    this.markers = asArray(config.markers(view));
    if (config.initialSpacer) {
      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
      this.dom.appendChild(this.spacer.dom);
      this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
    }
  }
  update(update) {
    let prevMarkers = this.markers;
    this.markers = asArray(this.config.markers(update.view));
    if (this.spacer && this.config.updateSpacer) {
      let updated = this.config.updateSpacer(this.spacer.markers[0], update);
      if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [updated]);
    }
    let vp = update.view.viewport;
    return !state_dist/* RangeSet */.om.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
  }
  destroy() {
    for (var _iterator114 = _createForOfIteratorHelperLoose(this.elements), _step114; !(_step114 = _iterator114()).done;) {
      let elt = _step114.value;
      elt.destroy();
    }
  }
}
class GutterElement {
  constructor(view, height, above, markers) {
    this.height = -1;
    this.above = 0;
    this.markers = [];
    this.dom = document.createElement("div");
    this.dom.className = "cm-gutterElement";
    this.update(view, height, above, markers);
  }
  update(view, height, above, markers) {
    if (this.height != height) {
      this.height = height;
      this.dom.style.height = height + "px";
    }
    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
    if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);
  }
  setMarkers(view, markers) {
    let cls = "cm-gutterElement",
      domPos = this.dom.firstChild;
    for (let iNew = 0, iOld = 0;;) {
      let skipTo = iOld,
        marker = iNew < markers.length ? markers[iNew++] : null,
        matched = false;
      if (marker) {
        let c = marker.elementClass;
        if (c) cls += " " + c;
        for (let i = iOld; i < this.markers.length; i++) if (this.markers[i].compare(marker)) {
          skipTo = i;
          matched = true;
          break;
        }
      } else {
        skipTo = this.markers.length;
      }
      while (iOld < skipTo) {
        let next = this.markers[iOld++];
        if (next.toDOM) {
          next.destroy(domPos);
          let after = domPos.nextSibling;
          domPos.remove();
          domPos = after;
        }
      }
      if (!marker) break;
      if (marker.toDOM) {
        if (matched) domPos = domPos.nextSibling;else this.dom.insertBefore(marker.toDOM(view), domPos);
      }
      if (matched) iOld++;
    }
    this.dom.className = cls;
    this.markers = markers;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function sameMarkers(a, b) {
  if (a.length != b.length) return false;
  for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;
  return true;
}
const lineNumberMarkers = state_dist/* Facet */.sj.define();
const lineNumberWidgetMarker = state_dist/* Facet */.sj.define();
const lineNumberConfig = state_dist/* Facet */.sj.define({
  combine(values) {
    return (0,state_dist/* combineConfig */.QR)(values, {
      formatNumber: String,
      domEventHandlers: {}
    }, {
      domEventHandlers(a, b) {
        let result = Object.assign({}, a);
        for (let event in b) {
          let exists = result[event],
            add = b[event];
          result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
        }
        return result;
      }
    });
  }
});
class NumberMarker extends GutterMarker {
  constructor(number) {
    super();
    this.number = number;
  }
  eq(other) {
    return this.number == other.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function formatNumber(view, number) {
  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = activeGutters.compute([lineNumberConfig], state => ({
  class: "cm-lineNumbers",
  renderEmptyElements: false,
  markers(view) {
    return view.state.facet(lineNumberMarkers);
  },
  lineMarker(view, line, others) {
    if (others.some(m => m.toDOM)) return null;
    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
  },
  widgetMarker: (view, widget, block) => {
    for (var _iterator115 = _createForOfIteratorHelperLoose(view.state.facet(lineNumberWidgetMarker)), _step115; !(_step115 = _iterator115()).done;) {
      let m = _step115.value;
      let result = m(view, widget, block);
      if (result) return result;
    }
    return null;
  },
  lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
  initialSpacer(view) {
    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
  },
  updateSpacer(spacer, update) {
    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
    return max == spacer.number ? spacer : new NumberMarker(max);
  },
  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
function lineNumbers(config) {
  if (config === void 0) {
    config = {};
  }
  return [lineNumberConfig.of(config), gutters(), lineNumberGutter];
}
function maxLineNumber(lines) {
  let last = 9;
  while (last < lines) last = last * 10 + 9;
  return last;
}
const activeLineGutterMarker = new class extends GutterMarker {
  constructor() {
    super(...arguments);
    this.elementClass = "cm-activeLineGutter";
  }
}();
const activeLineGutterHighlighter = gutterLineClass.compute(["selection"], state => {
  let marks = [],
    last = -1;
  for (var _iterator116 = _createForOfIteratorHelperLoose(state.selection.ranges), _step116; !(_step116 = _iterator116()).done;) {
    let range = _step116.value;
    let linePos = state.doc.lineAt(range.head).from;
    if (linePos > last) {
      last = linePos;
      marks.push(activeLineGutterMarker.range(linePos));
    }
  }
  return state_dist/* RangeSet */.om.of(marks);
});
function highlightActiveLineGutter() {
  return activeLineGutterHighlighter;
}
function matcher(decorator) {
  return ViewPlugin.define(view => ({
    decorations: decorator.createDeco(view),
    update(u) {
      this.decorations = decorator.updateDeco(u, this.decorations);
    }
  }), {
    decorations: v => v.decorations
  });
}
const tabDeco = Decoration.mark({
  class: "cm-highlightTab"
});
const spaceDeco = Decoration.mark({
  class: "cm-highlightSpace"
});
const whitespaceHighlighter = matcher(new MatchDecorator({
  regexp: /\t| /g,
  decoration: match => match[0] == "\t" ? tabDeco : spaceDeco,
  boundary: /\S/
}));
function highlightWhitespace() {
  return whitespaceHighlighter;
}
const trailingHighlighter = matcher(new MatchDecorator({
  regexp: /\s+$/g,
  decoration: Decoration.mark({
    class: "cm-trailingSpace"
  }),
  boundary: /\S/
}));
function highlightTrailingWhitespace() {
  return trailingHighlighter;
}
const __test = {
  HeightMap,
  HeightOracle,
  MeasuredHeights,
  QueryType,
  ChangedRange,
  computeOrder,
  moveVisually,
  clearHeightChangeFlag,
  getHeightChangeFlag: () => heightChangeFlag
};


/***/ }),

/***/ 5252:
/***/ (() => {

"use strict";


if (typeof Object.assign !== "function") {
  Object.assign = function (target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function (source) {
      if (source) {
        Object.keys(source).forEach(function (key) {
          return target[key] = source[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

/***/ }),

/***/ 5299:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Light-webfont.woff2";

/***/ }),

/***/ 5367:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Mode = __webpack_require__(8674);
const ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];
function AlphanumericData(data) {
  this.mode = Mode.ALPHANUMERIC;
  this.data = data;
}
AlphanumericData.getBitsLength = function getBitsLength(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2);
};
AlphanumericData.prototype.getLength = function getLength() {
  return this.data.length;
};
AlphanumericData.prototype.getBitsLength = function getBitsLength() {
  return AlphanumericData.getBitsLength(this.data.length);
};
AlphanumericData.prototype.write = function write(bitBuffer) {
  let i;
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
    bitBuffer.put(value, 11);
  }
  if (this.data.length % 2) {
    bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
  }
};
module.exports = AlphanumericData;

/***/ }),

/***/ 5458:
/***/ ((module) => {

function BitMatrix(size) {
  if (!size || size < 1) {
    throw new Error('BitMatrix size must be defined and greater than 0');
  }
  this.size = size;
  this.data = new Uint8Array(size * size);
  this.reservedBit = new Uint8Array(size * size);
}
BitMatrix.prototype.set = function (row, col, value, reserved) {
  const index = row * this.size + col;
  this.data[index] = value;
  if (reserved) this.reservedBit[index] = true;
};
BitMatrix.prototype.get = function (row, col) {
  return this.data[row * this.size + col];
};
BitMatrix.prototype.xor = function (row, col, value) {
  this.data[row * this.size + col] ^= value;
};
BitMatrix.prototype.isReserved = function (row, col) {
  return this.reservedBit[row * this.size + col];
};
module.exports = BitMatrix;

/***/ }),

/***/ 5530:
/***/ (function(module) {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(this, function () {
  return function () {
    var __webpack_modules__ = {
      686: (function (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_482__) {
        "use strict";
        __nested_webpack_require_482__.d(__nested_webpack_exports__, {
          "default": function () {
            return clipboard;
          }
        });
        var tiny_emitter = __nested_webpack_require_482__(279);
        var tiny_emitter_default = __nested_webpack_require_482__.n(tiny_emitter);
        var listen = __nested_webpack_require_482__(370);
        var listen_default = __nested_webpack_require_482__.n(listen);
        var src_select = __nested_webpack_require_482__(817);
        var select_default = __nested_webpack_require_482__.n(src_select);
        ;
        function command(type) {
          try {
            return document.execCommand(type);
          } catch (err) {
            return false;
          }
        }
        ;
        var ClipboardActionCut = function ClipboardActionCut(target) {
          var selectedText = select_default()(target);
          command('cut');
          return selectedText;
        };
        var actions_cut = ClipboardActionCut;
        ;
        function createFakeElement(value) {
          var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
          var fakeElement = document.createElement('textarea');
          fakeElement.style.fontSize = '12pt';
          fakeElement.style.border = '0';
          fakeElement.style.padding = '0';
          fakeElement.style.margin = '0';
          fakeElement.style.position = 'absolute';
          fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px';
          var yPosition = window.pageYOffset || document.documentElement.scrollTop;
          fakeElement.style.top = "".concat(yPosition, "px");
          fakeElement.setAttribute('readonly', '');
          fakeElement.value = value;
          return fakeElement;
        }
        ;
        var fakeCopyAction = function fakeCopyAction(value, options) {
          var fakeElement = createFakeElement(value);
          options.container.appendChild(fakeElement);
          var selectedText = select_default()(fakeElement);
          command('copy');
          fakeElement.remove();
          return selectedText;
        };
        var ClipboardActionCopy = function ClipboardActionCopy(target) {
          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
            container: document.body
          };
          var selectedText = '';
          if (typeof target === 'string') {
            selectedText = fakeCopyAction(target, options);
          } else if (target instanceof HTMLInputElement && !['text', 'search', 'url', 'tel', 'password'].includes(target === null || target === void 0 ? void 0 : target.type)) {
            selectedText = fakeCopyAction(target.value, options);
          } else {
            selectedText = select_default()(target);
            command('copy');
          }
          return selectedText;
        };
        var actions_copy = ClipboardActionCopy;
        ;
        function _typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            _typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            _typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }
          return _typeof(obj);
        }
        var ClipboardActionDefault = function ClipboardActionDefault() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var _options$action = options.action,
            action = _options$action === void 0 ? 'copy' : _options$action,
            container = options.container,
            target = options.target,
            text = options.text;
          if (action !== 'copy' && action !== 'cut') {
            throw new Error('Invalid "action" value, use either "copy" or "cut"');
          }
          if (target !== undefined) {
            if (target && _typeof(target) === 'object' && target.nodeType === 1) {
              if (action === 'copy' && target.hasAttribute('disabled')) {
                throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
              }
              if (action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
              }
            } else {
              throw new Error('Invalid "target" value, use a valid Element');
            }
          }
          if (text) {
            return actions_copy(text, {
              container: container
            });
          }
          if (target) {
            return action === 'cut' ? actions_cut(target) : actions_copy(target, {
              container: container
            });
          }
        };
        var actions_default = ClipboardActionDefault;
        ;
        function clipboard_typeof(obj) {
          "@babel/helpers - typeof";

          if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
            clipboard_typeof = function _typeof(obj) {
              return typeof obj;
            };
          } else {
            clipboard_typeof = function _typeof(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
          }
          return clipboard_typeof(obj);
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          if (superClass) _setPrototypeOf(subClass, superClass);
        }
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
          };
          return _setPrototypeOf(o, p);
        }
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived),
              result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = Reflect.construct(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _possibleConstructorReturn(self, call) {
          if (call && (clipboard_typeof(call) === "object" || typeof call === "function")) {
            return call;
          }
          return _assertThisInitialized(self);
        }
        function _assertThisInitialized(self) {
          if (self === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self;
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !Reflect.construct) return false;
          if (Reflect.construct.sham) return false;
          if (typeof Proxy === "function") return true;
          try {
            Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
            return true;
          } catch (e) {
            return false;
          }
        }
        function _getPrototypeOf(o) {
          _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
          };
          return _getPrototypeOf(o);
        }
        function getAttributeValue(suffix, element) {
          var attribute = "data-clipboard-".concat(suffix);
          if (!element.hasAttribute(attribute)) {
            return;
          }
          return element.getAttribute(attribute);
        }
        var Clipboard = function (_Emitter) {
          _inherits(Clipboard, _Emitter);
          var _super = _createSuper(Clipboard);
          function Clipboard(trigger, options) {
            var _this;
            _classCallCheck(this, Clipboard);
            _this = _super.call(this);
            _this.resolveOptions(options);
            _this.listenClick(trigger);
            return _this;
          }
          _createClass(Clipboard, [{
            key: "resolveOptions",
            value: function resolveOptions() {
              var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
              this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
              this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
              this.text = typeof options.text === 'function' ? options.text : this.defaultText;
              this.container = clipboard_typeof(options.container) === 'object' ? options.container : document.body;
            }
          }, {
            key: "listenClick",
            value: function listenClick(trigger) {
              var _this2 = this;
              this.listener = listen_default()(trigger, 'click', function (e) {
                return _this2.onClick(e);
              });
            }
          }, {
            key: "onClick",
            value: function onClick(e) {
              var trigger = e.delegateTarget || e.currentTarget;
              var action = this.action(trigger) || 'copy';
              var text = actions_default({
                action: action,
                container: this.container,
                target: this.target(trigger),
                text: this.text(trigger)
              });
              this.emit(text ? 'success' : 'error', {
                action: action,
                text: text,
                trigger: trigger,
                clearSelection: function clearSelection() {
                  if (trigger) {
                    trigger.focus();
                  }
                  window.getSelection().removeAllRanges();
                }
              });
            }
          }, {
            key: "defaultAction",
            value: function defaultAction(trigger) {
              return getAttributeValue('action', trigger);
            }
          }, {
            key: "defaultTarget",
            value: function defaultTarget(trigger) {
              var selector = getAttributeValue('target', trigger);
              if (selector) {
                return document.querySelector(selector);
              }
            }
          }, {
            key: "defaultText",
            value: function defaultText(trigger) {
              return getAttributeValue('text', trigger);
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.listener.destroy();
            }
          }], [{
            key: "copy",
            value: function copy(target) {
              var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
                container: document.body
              };
              return actions_copy(target, options);
            }
          }, {
            key: "cut",
            value: function cut(target) {
              return actions_cut(target);
            }
          }, {
            key: "isSupported",
            value: function isSupported() {
              var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];
              var actions = typeof action === 'string' ? [action] : action;
              var support = !!document.queryCommandSupported;
              actions.forEach(function (action) {
                support = support && !!document.queryCommandSupported(action);
              });
              return support;
            }
          }]);
          return Clipboard;
        }(tiny_emitter_default());
        var clipboard = Clipboard;
      }),
      828: (function (module) {
        var DOCUMENT_NODE_TYPE = 9;
        if (typeof Element !== 'undefined' && !Element.prototype.matches) {
          var proto = Element.prototype;
          proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
        }
        function closest(element, selector) {
          while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
            if (typeof element.matches === 'function' && element.matches(selector)) {
              return element;
            }
            element = element.parentNode;
          }
        }
        module.exports = closest;
      }),
      438: (function (module, __unused_webpack_exports, __nested_webpack_require_14582__) {
        var closest = __nested_webpack_require_14582__(828);
        function _delegate(element, selector, type, callback, useCapture) {
          var listenerFn = listener.apply(this, arguments);
          element.addEventListener(type, listenerFn, useCapture);
          return {
            destroy: function () {
              element.removeEventListener(type, listenerFn, useCapture);
            }
          };
        }
        function delegate(elements, selector, type, callback, useCapture) {
          if (typeof elements.addEventListener === 'function') {
            return _delegate.apply(null, arguments);
          }
          if (typeof type === 'function') {
            return _delegate.bind(null, document).apply(null, arguments);
          }
          if (typeof elements === 'string') {
            elements = document.querySelectorAll(elements);
          }
          return Array.prototype.map.call(elements, function (element) {
            return _delegate(element, selector, type, callback, useCapture);
          });
        }
        function listener(element, selector, type, callback) {
          return function (e) {
            e.delegateTarget = closest(e.target, selector);
            if (e.delegateTarget) {
              callback.call(element, e);
            }
          };
        }
        module.exports = delegate;
      }),
      879: (function (__unused_webpack_module, exports) {
        exports.node = function (value) {
          return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;
        };
        exports.nodeList = function (value) {
          var type = Object.prototype.toString.call(value);
          return value !== undefined && (type === '[object NodeList]' || type === '[object HTMLCollection]') && 'length' in value && (value.length === 0 || exports.node(value[0]));
        };
        exports.string = function (value) {
          return typeof value === 'string' || value instanceof String;
        };
        exports.fn = function (value) {
          var type = Object.prototype.toString.call(value);
          return type === '[object Function]';
        };
      }),
      370: (function (module, __unused_webpack_exports, __nested_webpack_require_16814__) {
        var is = __nested_webpack_require_16814__(879);
        var delegate = __nested_webpack_require_16814__(438);
        function listen(target, type, callback) {
          if (!target && !type && !callback) {
            throw new Error('Missing required arguments');
          }
          if (!is.string(type)) {
            throw new TypeError('Second argument must be a String');
          }
          if (!is.fn(callback)) {
            throw new TypeError('Third argument must be a Function');
          }
          if (is.node(target)) {
            return listenNode(target, type, callback);
          } else if (is.nodeList(target)) {
            return listenNodeList(target, type, callback);
          } else if (is.string(target)) {
            return listenSelector(target, type, callback);
          } else {
            throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
          }
        }
        function listenNode(node, type, callback) {
          node.addEventListener(type, callback);
          return {
            destroy: function () {
              node.removeEventListener(type, callback);
            }
          };
        }
        function listenNodeList(nodeList, type, callback) {
          Array.prototype.forEach.call(nodeList, function (node) {
            node.addEventListener(type, callback);
          });
          return {
            destroy: function () {
              Array.prototype.forEach.call(nodeList, function (node) {
                node.removeEventListener(type, callback);
              });
            }
          };
        }
        function listenSelector(selector, type, callback) {
          return delegate(document.body, selector, type, callback);
        }
        module.exports = listen;
      }),
      817: (function (module) {
        function select(element) {
          var selectedText;
          if (element.nodeName === 'SELECT') {
            element.focus();
            selectedText = element.value;
          } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
            var isReadOnly = element.hasAttribute('readonly');
            if (!isReadOnly) {
              element.setAttribute('readonly', '');
            }
            element.select();
            element.setSelectionRange(0, element.value.length);
            if (!isReadOnly) {
              element.removeAttribute('readonly');
            }
            selectedText = element.value;
          } else {
            if (element.hasAttribute('contenteditable')) {
              element.focus();
            }
            var selection = window.getSelection();
            var range = document.createRange();
            range.selectNodeContents(element);
            selection.removeAllRanges();
            selection.addRange(range);
            selectedText = selection.toString();
          }
          return selectedText;
        }
        module.exports = select;
      }),
      279: (function (module) {
        function E() {}
        E.prototype = {
          on: function (name, callback, ctx) {
            var e = this.e || (this.e = {});
            (e[name] || (e[name] = [])).push({
              fn: callback,
              ctx: ctx
            });
            return this;
          },
          once: function (name, callback, ctx) {
            var self = this;
            function listener() {
              self.off(name, listener);
              callback.apply(ctx, arguments);
            }
            ;
            listener._ = callback;
            return this.on(name, listener, ctx);
          },
          emit: function (name) {
            var data = [].slice.call(arguments, 1);
            var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
            var i = 0;
            var len = evtArr.length;
            for (i; i < len; i++) {
              evtArr[i].fn.apply(evtArr[i].ctx, data);
            }
            return this;
          },
          off: function (name, callback) {
            var e = this.e || (this.e = {});
            var evts = e[name];
            var liveEvents = [];
            if (evts && callback) {
              for (var i = 0, len = evts.length; i < len; i++) {
                if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
              }
            }
            liveEvents.length ? e[name] = liveEvents : delete e[name];
            return this;
          }
        };
        module.exports = E;
        module.exports.TinyEmitter = E;
      })
    };
    var __webpack_module_cache__ = {};
    function __nested_webpack_require_21457__(moduleId) {
      if (__webpack_module_cache__[moduleId]) {
        return __webpack_module_cache__[moduleId].exports;
      }
      var module = __webpack_module_cache__[moduleId] = {
        exports: {}
      };
      __webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_21457__);
      return module.exports;
    }
    !function () {
      __nested_webpack_require_21457__.n = function (module) {
        var getter = module && module.__esModule ? function () {
          return module['default'];
        } : function () {
          return module;
        };
        __nested_webpack_require_21457__.d(getter, {
          a: getter
        });
        return getter;
      };
    }();
    !function () {
      __nested_webpack_require_21457__.d = function (exports, definition) {
        for (var key in definition) {
          if (__nested_webpack_require_21457__.o(definition, key) && !__nested_webpack_require_21457__.o(exports, key)) {
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: definition[key]
            });
          }
        }
      };
    }();
    !function () {
      __nested_webpack_require_21457__.o = function (obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      };
    }();
    return __nested_webpack_require_21457__(686);
  }().default;
});

/***/ }),

/***/ 5617:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Utils = __webpack_require__(3340);
const ECCode = __webpack_require__(3020);
const ECLevel = __webpack_require__(151);
const Mode = __webpack_require__(8674);
const VersionCheck = __webpack_require__(7432);
const G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
const G18_BCH = Utils.getBCHDigit(G18);
function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
      return currentVersion;
    }
  }
  return undefined;
}
function getReservedBitsCount(mode, version) {
  return Mode.getCharCountIndicator(mode, version) + 4;
}
function getTotalBitsFromDataArray(segments, version) {
  let totalBits = 0;
  segments.forEach(function (data) {
    const reservedBits = getReservedBitsCount(data.mode, version);
    totalBits += reservedBits + data.getBitsLength();
  });
  return totalBits;
}
function getBestVersionForMixedData(segments, errorCorrectionLevel) {
  for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
    const length = getTotalBitsFromDataArray(segments, currentVersion);
    if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
      return currentVersion;
    }
  }
  return undefined;
}
exports.from = function from(value, defaultValue) {
  if (VersionCheck.isValid(value)) {
    return parseInt(value, 10);
  }
  return defaultValue;
};
exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid QR Code version');
  }
  if (typeof mode === 'undefined') mode = Mode.BYTE;
  const totalCodewords = Utils.getSymbolTotalCodewords(version);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (mode === Mode.MIXED) return dataTotalCodewordsBits;
  const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
  switch (mode) {
    case Mode.NUMERIC:
      return Math.floor(usableBits / 10 * 3);
    case Mode.ALPHANUMERIC:
      return Math.floor(usableBits / 11 * 2);
    case Mode.KANJI:
      return Math.floor(usableBits / 13);
    case Mode.BYTE:
    default:
      return Math.floor(usableBits / 8);
  }
};
exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
  let seg;
  const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
  if (Array.isArray(data)) {
    if (data.length > 1) {
      return getBestVersionForMixedData(data, ecl);
    }
    if (data.length === 0) {
      return 1;
    }
    seg = data[0];
  } else {
    seg = data;
  }
  return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
};
exports.getEncodedBits = function getEncodedBits(version) {
  if (!VersionCheck.isValid(version) || version < 7) {
    throw new Error('Invalid QR Code version');
  }
  let d = version << 12;
  while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
    d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
  }
  return version << 12 | d;
};

/***/ }),

/***/ 6142:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8095);
/* harmony import */ var _css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7968);
/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2187);
/* harmony import */ var _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(3258), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(6411), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_1___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/*!
 * Bootstrap Icons v1.11.3 (https://icons.getbootstrap.com/)
 * Copyright 2019-2024 The Bootstrap Authors
 * Licensed under MIT (https://github.com/twbs/icons/blob/main/LICENSE)
 */

@font-face {
  font-display: block;
  font-family: "bootstrap-icons";
  src: url(${___CSS_LOADER_URL_REPLACEMENT_0___}) format("woff2"),
url(${___CSS_LOADER_URL_REPLACEMENT_1___}) format("woff");
}

.bi::before,
[class^="bi-"]::before,
[class*=" bi-"]::before {
  display: inline-block;
  font-family: bootstrap-icons !important;
  font-style: normal;
  font-weight: normal !important;
  font-variant: normal;
  text-transform: none;
  line-height: 1;
  vertical-align: -.125em;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.bi-123::before { content: "\\f67f"; }
.bi-alarm-fill::before { content: "\\f101"; }
.bi-alarm::before { content: "\\f102"; }
.bi-align-bottom::before { content: "\\f103"; }
.bi-align-center::before { content: "\\f104"; }
.bi-align-end::before { content: "\\f105"; }
.bi-align-middle::before { content: "\\f106"; }
.bi-align-start::before { content: "\\f107"; }
.bi-align-top::before { content: "\\f108"; }
.bi-alt::before { content: "\\f109"; }
.bi-app-indicator::before { content: "\\f10a"; }
.bi-app::before { content: "\\f10b"; }
.bi-archive-fill::before { content: "\\f10c"; }
.bi-archive::before { content: "\\f10d"; }
.bi-arrow-90deg-down::before { content: "\\f10e"; }
.bi-arrow-90deg-left::before { content: "\\f10f"; }
.bi-arrow-90deg-right::before { content: "\\f110"; }
.bi-arrow-90deg-up::before { content: "\\f111"; }
.bi-arrow-bar-down::before { content: "\\f112"; }
.bi-arrow-bar-left::before { content: "\\f113"; }
.bi-arrow-bar-right::before { content: "\\f114"; }
.bi-arrow-bar-up::before { content: "\\f115"; }
.bi-arrow-clockwise::before { content: "\\f116"; }
.bi-arrow-counterclockwise::before { content: "\\f117"; }
.bi-arrow-down-circle-fill::before { content: "\\f118"; }
.bi-arrow-down-circle::before { content: "\\f119"; }
.bi-arrow-down-left-circle-fill::before { content: "\\f11a"; }
.bi-arrow-down-left-circle::before { content: "\\f11b"; }
.bi-arrow-down-left-square-fill::before { content: "\\f11c"; }
.bi-arrow-down-left-square::before { content: "\\f11d"; }
.bi-arrow-down-left::before { content: "\\f11e"; }
.bi-arrow-down-right-circle-fill::before { content: "\\f11f"; }
.bi-arrow-down-right-circle::before { content: "\\f120"; }
.bi-arrow-down-right-square-fill::before { content: "\\f121"; }
.bi-arrow-down-right-square::before { content: "\\f122"; }
.bi-arrow-down-right::before { content: "\\f123"; }
.bi-arrow-down-short::before { content: "\\f124"; }
.bi-arrow-down-square-fill::before { content: "\\f125"; }
.bi-arrow-down-square::before { content: "\\f126"; }
.bi-arrow-down-up::before { content: "\\f127"; }
.bi-arrow-down::before { content: "\\f128"; }
.bi-arrow-left-circle-fill::before { content: "\\f129"; }
.bi-arrow-left-circle::before { content: "\\f12a"; }
.bi-arrow-left-right::before { content: "\\f12b"; }
.bi-arrow-left-short::before { content: "\\f12c"; }
.bi-arrow-left-square-fill::before { content: "\\f12d"; }
.bi-arrow-left-square::before { content: "\\f12e"; }
.bi-arrow-left::before { content: "\\f12f"; }
.bi-arrow-repeat::before { content: "\\f130"; }
.bi-arrow-return-left::before { content: "\\f131"; }
.bi-arrow-return-right::before { content: "\\f132"; }
.bi-arrow-right-circle-fill::before { content: "\\f133"; }
.bi-arrow-right-circle::before { content: "\\f134"; }
.bi-arrow-right-short::before { content: "\\f135"; }
.bi-arrow-right-square-fill::before { content: "\\f136"; }
.bi-arrow-right-square::before { content: "\\f137"; }
.bi-arrow-right::before { content: "\\f138"; }
.bi-arrow-up-circle-fill::before { content: "\\f139"; }
.bi-arrow-up-circle::before { content: "\\f13a"; }
.bi-arrow-up-left-circle-fill::before { content: "\\f13b"; }
.bi-arrow-up-left-circle::before { content: "\\f13c"; }
.bi-arrow-up-left-square-fill::before { content: "\\f13d"; }
.bi-arrow-up-left-square::before { content: "\\f13e"; }
.bi-arrow-up-left::before { content: "\\f13f"; }
.bi-arrow-up-right-circle-fill::before { content: "\\f140"; }
.bi-arrow-up-right-circle::before { content: "\\f141"; }
.bi-arrow-up-right-square-fill::before { content: "\\f142"; }
.bi-arrow-up-right-square::before { content: "\\f143"; }
.bi-arrow-up-right::before { content: "\\f144"; }
.bi-arrow-up-short::before { content: "\\f145"; }
.bi-arrow-up-square-fill::before { content: "\\f146"; }
.bi-arrow-up-square::before { content: "\\f147"; }
.bi-arrow-up::before { content: "\\f148"; }
.bi-arrows-angle-contract::before { content: "\\f149"; }
.bi-arrows-angle-expand::before { content: "\\f14a"; }
.bi-arrows-collapse::before { content: "\\f14b"; }
.bi-arrows-expand::before { content: "\\f14c"; }
.bi-arrows-fullscreen::before { content: "\\f14d"; }
.bi-arrows-move::before { content: "\\f14e"; }
.bi-aspect-ratio-fill::before { content: "\\f14f"; }
.bi-aspect-ratio::before { content: "\\f150"; }
.bi-asterisk::before { content: "\\f151"; }
.bi-at::before { content: "\\f152"; }
.bi-award-fill::before { content: "\\f153"; }
.bi-award::before { content: "\\f154"; }
.bi-back::before { content: "\\f155"; }
.bi-backspace-fill::before { content: "\\f156"; }
.bi-backspace-reverse-fill::before { content: "\\f157"; }
.bi-backspace-reverse::before { content: "\\f158"; }
.bi-backspace::before { content: "\\f159"; }
.bi-badge-3d-fill::before { content: "\\f15a"; }
.bi-badge-3d::before { content: "\\f15b"; }
.bi-badge-4k-fill::before { content: "\\f15c"; }
.bi-badge-4k::before { content: "\\f15d"; }
.bi-badge-8k-fill::before { content: "\\f15e"; }
.bi-badge-8k::before { content: "\\f15f"; }
.bi-badge-ad-fill::before { content: "\\f160"; }
.bi-badge-ad::before { content: "\\f161"; }
.bi-badge-ar-fill::before { content: "\\f162"; }
.bi-badge-ar::before { content: "\\f163"; }
.bi-badge-cc-fill::before { content: "\\f164"; }
.bi-badge-cc::before { content: "\\f165"; }
.bi-badge-hd-fill::before { content: "\\f166"; }
.bi-badge-hd::before { content: "\\f167"; }
.bi-badge-tm-fill::before { content: "\\f168"; }
.bi-badge-tm::before { content: "\\f169"; }
.bi-badge-vo-fill::before { content: "\\f16a"; }
.bi-badge-vo::before { content: "\\f16b"; }
.bi-badge-vr-fill::before { content: "\\f16c"; }
.bi-badge-vr::before { content: "\\f16d"; }
.bi-badge-wc-fill::before { content: "\\f16e"; }
.bi-badge-wc::before { content: "\\f16f"; }
.bi-bag-check-fill::before { content: "\\f170"; }
.bi-bag-check::before { content: "\\f171"; }
.bi-bag-dash-fill::before { content: "\\f172"; }
.bi-bag-dash::before { content: "\\f173"; }
.bi-bag-fill::before { content: "\\f174"; }
.bi-bag-plus-fill::before { content: "\\f175"; }
.bi-bag-plus::before { content: "\\f176"; }
.bi-bag-x-fill::before { content: "\\f177"; }
.bi-bag-x::before { content: "\\f178"; }
.bi-bag::before { content: "\\f179"; }
.bi-bar-chart-fill::before { content: "\\f17a"; }
.bi-bar-chart-line-fill::before { content: "\\f17b"; }
.bi-bar-chart-line::before { content: "\\f17c"; }
.bi-bar-chart-steps::before { content: "\\f17d"; }
.bi-bar-chart::before { content: "\\f17e"; }
.bi-basket-fill::before { content: "\\f17f"; }
.bi-basket::before { content: "\\f180"; }
.bi-basket2-fill::before { content: "\\f181"; }
.bi-basket2::before { content: "\\f182"; }
.bi-basket3-fill::before { content: "\\f183"; }
.bi-basket3::before { content: "\\f184"; }
.bi-battery-charging::before { content: "\\f185"; }
.bi-battery-full::before { content: "\\f186"; }
.bi-battery-half::before { content: "\\f187"; }
.bi-battery::before { content: "\\f188"; }
.bi-bell-fill::before { content: "\\f189"; }
.bi-bell::before { content: "\\f18a"; }
.bi-bezier::before { content: "\\f18b"; }
.bi-bezier2::before { content: "\\f18c"; }
.bi-bicycle::before { content: "\\f18d"; }
.bi-binoculars-fill::before { content: "\\f18e"; }
.bi-binoculars::before { content: "\\f18f"; }
.bi-blockquote-left::before { content: "\\f190"; }
.bi-blockquote-right::before { content: "\\f191"; }
.bi-book-fill::before { content: "\\f192"; }
.bi-book-half::before { content: "\\f193"; }
.bi-book::before { content: "\\f194"; }
.bi-bookmark-check-fill::before { content: "\\f195"; }
.bi-bookmark-check::before { content: "\\f196"; }
.bi-bookmark-dash-fill::before { content: "\\f197"; }
.bi-bookmark-dash::before { content: "\\f198"; }
.bi-bookmark-fill::before { content: "\\f199"; }
.bi-bookmark-heart-fill::before { content: "\\f19a"; }
.bi-bookmark-heart::before { content: "\\f19b"; }
.bi-bookmark-plus-fill::before { content: "\\f19c"; }
.bi-bookmark-plus::before { content: "\\f19d"; }
.bi-bookmark-star-fill::before { content: "\\f19e"; }
.bi-bookmark-star::before { content: "\\f19f"; }
.bi-bookmark-x-fill::before { content: "\\f1a0"; }
.bi-bookmark-x::before { content: "\\f1a1"; }
.bi-bookmark::before { content: "\\f1a2"; }
.bi-bookmarks-fill::before { content: "\\f1a3"; }
.bi-bookmarks::before { content: "\\f1a4"; }
.bi-bookshelf::before { content: "\\f1a5"; }
.bi-bootstrap-fill::before { content: "\\f1a6"; }
.bi-bootstrap-reboot::before { content: "\\f1a7"; }
.bi-bootstrap::before { content: "\\f1a8"; }
.bi-border-all::before { content: "\\f1a9"; }
.bi-border-bottom::before { content: "\\f1aa"; }
.bi-border-center::before { content: "\\f1ab"; }
.bi-border-inner::before { content: "\\f1ac"; }
.bi-border-left::before { content: "\\f1ad"; }
.bi-border-middle::before { content: "\\f1ae"; }
.bi-border-outer::before { content: "\\f1af"; }
.bi-border-right::before { content: "\\f1b0"; }
.bi-border-style::before { content: "\\f1b1"; }
.bi-border-top::before { content: "\\f1b2"; }
.bi-border-width::before { content: "\\f1b3"; }
.bi-border::before { content: "\\f1b4"; }
.bi-bounding-box-circles::before { content: "\\f1b5"; }
.bi-bounding-box::before { content: "\\f1b6"; }
.bi-box-arrow-down-left::before { content: "\\f1b7"; }
.bi-box-arrow-down-right::before { content: "\\f1b8"; }
.bi-box-arrow-down::before { content: "\\f1b9"; }
.bi-box-arrow-in-down-left::before { content: "\\f1ba"; }
.bi-box-arrow-in-down-right::before { content: "\\f1bb"; }
.bi-box-arrow-in-down::before { content: "\\f1bc"; }
.bi-box-arrow-in-left::before { content: "\\f1bd"; }
.bi-box-arrow-in-right::before { content: "\\f1be"; }
.bi-box-arrow-in-up-left::before { content: "\\f1bf"; }
.bi-box-arrow-in-up-right::before { content: "\\f1c0"; }
.bi-box-arrow-in-up::before { content: "\\f1c1"; }
.bi-box-arrow-left::before { content: "\\f1c2"; }
.bi-box-arrow-right::before { content: "\\f1c3"; }
.bi-box-arrow-up-left::before { content: "\\f1c4"; }
.bi-box-arrow-up-right::before { content: "\\f1c5"; }
.bi-box-arrow-up::before { content: "\\f1c6"; }
.bi-box-seam::before { content: "\\f1c7"; }
.bi-box::before { content: "\\f1c8"; }
.bi-braces::before { content: "\\f1c9"; }
.bi-bricks::before { content: "\\f1ca"; }
.bi-briefcase-fill::before { content: "\\f1cb"; }
.bi-briefcase::before { content: "\\f1cc"; }
.bi-brightness-alt-high-fill::before { content: "\\f1cd"; }
.bi-brightness-alt-high::before { content: "\\f1ce"; }
.bi-brightness-alt-low-fill::before { content: "\\f1cf"; }
.bi-brightness-alt-low::before { content: "\\f1d0"; }
.bi-brightness-high-fill::before { content: "\\f1d1"; }
.bi-brightness-high::before { content: "\\f1d2"; }
.bi-brightness-low-fill::before { content: "\\f1d3"; }
.bi-brightness-low::before { content: "\\f1d4"; }
.bi-broadcast-pin::before { content: "\\f1d5"; }
.bi-broadcast::before { content: "\\f1d6"; }
.bi-brush-fill::before { content: "\\f1d7"; }
.bi-brush::before { content: "\\f1d8"; }
.bi-bucket-fill::before { content: "\\f1d9"; }
.bi-bucket::before { content: "\\f1da"; }
.bi-bug-fill::before { content: "\\f1db"; }
.bi-bug::before { content: "\\f1dc"; }
.bi-building::before { content: "\\f1dd"; }
.bi-bullseye::before { content: "\\f1de"; }
.bi-calculator-fill::before { content: "\\f1df"; }
.bi-calculator::before { content: "\\f1e0"; }
.bi-calendar-check-fill::before { content: "\\f1e1"; }
.bi-calendar-check::before { content: "\\f1e2"; }
.bi-calendar-date-fill::before { content: "\\f1e3"; }
.bi-calendar-date::before { content: "\\f1e4"; }
.bi-calendar-day-fill::before { content: "\\f1e5"; }
.bi-calendar-day::before { content: "\\f1e6"; }
.bi-calendar-event-fill::before { content: "\\f1e7"; }
.bi-calendar-event::before { content: "\\f1e8"; }
.bi-calendar-fill::before { content: "\\f1e9"; }
.bi-calendar-minus-fill::before { content: "\\f1ea"; }
.bi-calendar-minus::before { content: "\\f1eb"; }
.bi-calendar-month-fill::before { content: "\\f1ec"; }
.bi-calendar-month::before { content: "\\f1ed"; }
.bi-calendar-plus-fill::before { content: "\\f1ee"; }
.bi-calendar-plus::before { content: "\\f1ef"; }
.bi-calendar-range-fill::before { content: "\\f1f0"; }
.bi-calendar-range::before { content: "\\f1f1"; }
.bi-calendar-week-fill::before { content: "\\f1f2"; }
.bi-calendar-week::before { content: "\\f1f3"; }
.bi-calendar-x-fill::before { content: "\\f1f4"; }
.bi-calendar-x::before { content: "\\f1f5"; }
.bi-calendar::before { content: "\\f1f6"; }
.bi-calendar2-check-fill::before { content: "\\f1f7"; }
.bi-calendar2-check::before { content: "\\f1f8"; }
.bi-calendar2-date-fill::before { content: "\\f1f9"; }
.bi-calendar2-date::before { content: "\\f1fa"; }
.bi-calendar2-day-fill::before { content: "\\f1fb"; }
.bi-calendar2-day::before { content: "\\f1fc"; }
.bi-calendar2-event-fill::before { content: "\\f1fd"; }
.bi-calendar2-event::before { content: "\\f1fe"; }
.bi-calendar2-fill::before { content: "\\f1ff"; }
.bi-calendar2-minus-fill::before { content: "\\f200"; }
.bi-calendar2-minus::before { content: "\\f201"; }
.bi-calendar2-month-fill::before { content: "\\f202"; }
.bi-calendar2-month::before { content: "\\f203"; }
.bi-calendar2-plus-fill::before { content: "\\f204"; }
.bi-calendar2-plus::before { content: "\\f205"; }
.bi-calendar2-range-fill::before { content: "\\f206"; }
.bi-calendar2-range::before { content: "\\f207"; }
.bi-calendar2-week-fill::before { content: "\\f208"; }
.bi-calendar2-week::before { content: "\\f209"; }
.bi-calendar2-x-fill::before { content: "\\f20a"; }
.bi-calendar2-x::before { content: "\\f20b"; }
.bi-calendar2::before { content: "\\f20c"; }
.bi-calendar3-event-fill::before { content: "\\f20d"; }
.bi-calendar3-event::before { content: "\\f20e"; }
.bi-calendar3-fill::before { content: "\\f20f"; }
.bi-calendar3-range-fill::before { content: "\\f210"; }
.bi-calendar3-range::before { content: "\\f211"; }
.bi-calendar3-week-fill::before { content: "\\f212"; }
.bi-calendar3-week::before { content: "\\f213"; }
.bi-calendar3::before { content: "\\f214"; }
.bi-calendar4-event::before { content: "\\f215"; }
.bi-calendar4-range::before { content: "\\f216"; }
.bi-calendar4-week::before { content: "\\f217"; }
.bi-calendar4::before { content: "\\f218"; }
.bi-camera-fill::before { content: "\\f219"; }
.bi-camera-reels-fill::before { content: "\\f21a"; }
.bi-camera-reels::before { content: "\\f21b"; }
.bi-camera-video-fill::before { content: "\\f21c"; }
.bi-camera-video-off-fill::before { content: "\\f21d"; }
.bi-camera-video-off::before { content: "\\f21e"; }
.bi-camera-video::before { content: "\\f21f"; }
.bi-camera::before { content: "\\f220"; }
.bi-camera2::before { content: "\\f221"; }
.bi-capslock-fill::before { content: "\\f222"; }
.bi-capslock::before { content: "\\f223"; }
.bi-card-checklist::before { content: "\\f224"; }
.bi-card-heading::before { content: "\\f225"; }
.bi-card-image::before { content: "\\f226"; }
.bi-card-list::before { content: "\\f227"; }
.bi-card-text::before { content: "\\f228"; }
.bi-caret-down-fill::before { content: "\\f229"; }
.bi-caret-down-square-fill::before { content: "\\f22a"; }
.bi-caret-down-square::before { content: "\\f22b"; }
.bi-caret-down::before { content: "\\f22c"; }
.bi-caret-left-fill::before { content: "\\f22d"; }
.bi-caret-left-square-fill::before { content: "\\f22e"; }
.bi-caret-left-square::before { content: "\\f22f"; }
.bi-caret-left::before { content: "\\f230"; }
.bi-caret-right-fill::before { content: "\\f231"; }
.bi-caret-right-square-fill::before { content: "\\f232"; }
.bi-caret-right-square::before { content: "\\f233"; }
.bi-caret-right::before { content: "\\f234"; }
.bi-caret-up-fill::before { content: "\\f235"; }
.bi-caret-up-square-fill::before { content: "\\f236"; }
.bi-caret-up-square::before { content: "\\f237"; }
.bi-caret-up::before { content: "\\f238"; }
.bi-cart-check-fill::before { content: "\\f239"; }
.bi-cart-check::before { content: "\\f23a"; }
.bi-cart-dash-fill::before { content: "\\f23b"; }
.bi-cart-dash::before { content: "\\f23c"; }
.bi-cart-fill::before { content: "\\f23d"; }
.bi-cart-plus-fill::before { content: "\\f23e"; }
.bi-cart-plus::before { content: "\\f23f"; }
.bi-cart-x-fill::before { content: "\\f240"; }
.bi-cart-x::before { content: "\\f241"; }
.bi-cart::before { content: "\\f242"; }
.bi-cart2::before { content: "\\f243"; }
.bi-cart3::before { content: "\\f244"; }
.bi-cart4::before { content: "\\f245"; }
.bi-cash-stack::before { content: "\\f246"; }
.bi-cash::before { content: "\\f247"; }
.bi-cast::before { content: "\\f248"; }
.bi-chat-dots-fill::before { content: "\\f249"; }
.bi-chat-dots::before { content: "\\f24a"; }
.bi-chat-fill::before { content: "\\f24b"; }
.bi-chat-left-dots-fill::before { content: "\\f24c"; }
.bi-chat-left-dots::before { content: "\\f24d"; }
.bi-chat-left-fill::before { content: "\\f24e"; }
.bi-chat-left-quote-fill::before { content: "\\f24f"; }
.bi-chat-left-quote::before { content: "\\f250"; }
.bi-chat-left-text-fill::before { content: "\\f251"; }
.bi-chat-left-text::before { content: "\\f252"; }
.bi-chat-left::before { content: "\\f253"; }
.bi-chat-quote-fill::before { content: "\\f254"; }
.bi-chat-quote::before { content: "\\f255"; }
.bi-chat-right-dots-fill::before { content: "\\f256"; }
.bi-chat-right-dots::before { content: "\\f257"; }
.bi-chat-right-fill::before { content: "\\f258"; }
.bi-chat-right-quote-fill::before { content: "\\f259"; }
.bi-chat-right-quote::before { content: "\\f25a"; }
.bi-chat-right-text-fill::before { content: "\\f25b"; }
.bi-chat-right-text::before { content: "\\f25c"; }
.bi-chat-right::before { content: "\\f25d"; }
.bi-chat-square-dots-fill::before { content: "\\f25e"; }
.bi-chat-square-dots::before { content: "\\f25f"; }
.bi-chat-square-fill::before { content: "\\f260"; }
.bi-chat-square-quote-fill::before { content: "\\f261"; }
.bi-chat-square-quote::before { content: "\\f262"; }
.bi-chat-square-text-fill::before { content: "\\f263"; }
.bi-chat-square-text::before { content: "\\f264"; }
.bi-chat-square::before { content: "\\f265"; }
.bi-chat-text-fill::before { content: "\\f266"; }
.bi-chat-text::before { content: "\\f267"; }
.bi-chat::before { content: "\\f268"; }
.bi-check-all::before { content: "\\f269"; }
.bi-check-circle-fill::before { content: "\\f26a"; }
.bi-check-circle::before { content: "\\f26b"; }
.bi-check-square-fill::before { content: "\\f26c"; }
.bi-check-square::before { content: "\\f26d"; }
.bi-check::before { content: "\\f26e"; }
.bi-check2-all::before { content: "\\f26f"; }
.bi-check2-circle::before { content: "\\f270"; }
.bi-check2-square::before { content: "\\f271"; }
.bi-check2::before { content: "\\f272"; }
.bi-chevron-bar-contract::before { content: "\\f273"; }
.bi-chevron-bar-down::before { content: "\\f274"; }
.bi-chevron-bar-expand::before { content: "\\f275"; }
.bi-chevron-bar-left::before { content: "\\f276"; }
.bi-chevron-bar-right::before { content: "\\f277"; }
.bi-chevron-bar-up::before { content: "\\f278"; }
.bi-chevron-compact-down::before { content: "\\f279"; }
.bi-chevron-compact-left::before { content: "\\f27a"; }
.bi-chevron-compact-right::before { content: "\\f27b"; }
.bi-chevron-compact-up::before { content: "\\f27c"; }
.bi-chevron-contract::before { content: "\\f27d"; }
.bi-chevron-double-down::before { content: "\\f27e"; }
.bi-chevron-double-left::before { content: "\\f27f"; }
.bi-chevron-double-right::before { content: "\\f280"; }
.bi-chevron-double-up::before { content: "\\f281"; }
.bi-chevron-down::before { content: "\\f282"; }
.bi-chevron-expand::before { content: "\\f283"; }
.bi-chevron-left::before { content: "\\f284"; }
.bi-chevron-right::before { content: "\\f285"; }
.bi-chevron-up::before { content: "\\f286"; }
.bi-circle-fill::before { content: "\\f287"; }
.bi-circle-half::before { content: "\\f288"; }
.bi-circle-square::before { content: "\\f289"; }
.bi-circle::before { content: "\\f28a"; }
.bi-clipboard-check::before { content: "\\f28b"; }
.bi-clipboard-data::before { content: "\\f28c"; }
.bi-clipboard-minus::before { content: "\\f28d"; }
.bi-clipboard-plus::before { content: "\\f28e"; }
.bi-clipboard-x::before { content: "\\f28f"; }
.bi-clipboard::before { content: "\\f290"; }
.bi-clock-fill::before { content: "\\f291"; }
.bi-clock-history::before { content: "\\f292"; }
.bi-clock::before { content: "\\f293"; }
.bi-cloud-arrow-down-fill::before { content: "\\f294"; }
.bi-cloud-arrow-down::before { content: "\\f295"; }
.bi-cloud-arrow-up-fill::before { content: "\\f296"; }
.bi-cloud-arrow-up::before { content: "\\f297"; }
.bi-cloud-check-fill::before { content: "\\f298"; }
.bi-cloud-check::before { content: "\\f299"; }
.bi-cloud-download-fill::before { content: "\\f29a"; }
.bi-cloud-download::before { content: "\\f29b"; }
.bi-cloud-drizzle-fill::before { content: "\\f29c"; }
.bi-cloud-drizzle::before { content: "\\f29d"; }
.bi-cloud-fill::before { content: "\\f29e"; }
.bi-cloud-fog-fill::before { content: "\\f29f"; }
.bi-cloud-fog::before { content: "\\f2a0"; }
.bi-cloud-fog2-fill::before { content: "\\f2a1"; }
.bi-cloud-fog2::before { content: "\\f2a2"; }
.bi-cloud-hail-fill::before { content: "\\f2a3"; }
.bi-cloud-hail::before { content: "\\f2a4"; }
.bi-cloud-haze-fill::before { content: "\\f2a6"; }
.bi-cloud-haze::before { content: "\\f2a7"; }
.bi-cloud-haze2-fill::before { content: "\\f2a8"; }
.bi-cloud-lightning-fill::before { content: "\\f2a9"; }
.bi-cloud-lightning-rain-fill::before { content: "\\f2aa"; }
.bi-cloud-lightning-rain::before { content: "\\f2ab"; }
.bi-cloud-lightning::before { content: "\\f2ac"; }
.bi-cloud-minus-fill::before { content: "\\f2ad"; }
.bi-cloud-minus::before { content: "\\f2ae"; }
.bi-cloud-moon-fill::before { content: "\\f2af"; }
.bi-cloud-moon::before { content: "\\f2b0"; }
.bi-cloud-plus-fill::before { content: "\\f2b1"; }
.bi-cloud-plus::before { content: "\\f2b2"; }
.bi-cloud-rain-fill::before { content: "\\f2b3"; }
.bi-cloud-rain-heavy-fill::before { content: "\\f2b4"; }
.bi-cloud-rain-heavy::before { content: "\\f2b5"; }
.bi-cloud-rain::before { content: "\\f2b6"; }
.bi-cloud-slash-fill::before { content: "\\f2b7"; }
.bi-cloud-slash::before { content: "\\f2b8"; }
.bi-cloud-sleet-fill::before { content: "\\f2b9"; }
.bi-cloud-sleet::before { content: "\\f2ba"; }
.bi-cloud-snow-fill::before { content: "\\f2bb"; }
.bi-cloud-snow::before { content: "\\f2bc"; }
.bi-cloud-sun-fill::before { content: "\\f2bd"; }
.bi-cloud-sun::before { content: "\\f2be"; }
.bi-cloud-upload-fill::before { content: "\\f2bf"; }
.bi-cloud-upload::before { content: "\\f2c0"; }
.bi-cloud::before { content: "\\f2c1"; }
.bi-clouds-fill::before { content: "\\f2c2"; }
.bi-clouds::before { content: "\\f2c3"; }
.bi-cloudy-fill::before { content: "\\f2c4"; }
.bi-cloudy::before { content: "\\f2c5"; }
.bi-code-slash::before { content: "\\f2c6"; }
.bi-code-square::before { content: "\\f2c7"; }
.bi-code::before { content: "\\f2c8"; }
.bi-collection-fill::before { content: "\\f2c9"; }
.bi-collection-play-fill::before { content: "\\f2ca"; }
.bi-collection-play::before { content: "\\f2cb"; }
.bi-collection::before { content: "\\f2cc"; }
.bi-columns-gap::before { content: "\\f2cd"; }
.bi-columns::before { content: "\\f2ce"; }
.bi-command::before { content: "\\f2cf"; }
.bi-compass-fill::before { content: "\\f2d0"; }
.bi-compass::before { content: "\\f2d1"; }
.bi-cone-striped::before { content: "\\f2d2"; }
.bi-cone::before { content: "\\f2d3"; }
.bi-controller::before { content: "\\f2d4"; }
.bi-cpu-fill::before { content: "\\f2d5"; }
.bi-cpu::before { content: "\\f2d6"; }
.bi-credit-card-2-back-fill::before { content: "\\f2d7"; }
.bi-credit-card-2-back::before { content: "\\f2d8"; }
.bi-credit-card-2-front-fill::before { content: "\\f2d9"; }
.bi-credit-card-2-front::before { content: "\\f2da"; }
.bi-credit-card-fill::before { content: "\\f2db"; }
.bi-credit-card::before { content: "\\f2dc"; }
.bi-crop::before { content: "\\f2dd"; }
.bi-cup-fill::before { content: "\\f2de"; }
.bi-cup-straw::before { content: "\\f2df"; }
.bi-cup::before { content: "\\f2e0"; }
.bi-cursor-fill::before { content: "\\f2e1"; }
.bi-cursor-text::before { content: "\\f2e2"; }
.bi-cursor::before { content: "\\f2e3"; }
.bi-dash-circle-dotted::before { content: "\\f2e4"; }
.bi-dash-circle-fill::before { content: "\\f2e5"; }
.bi-dash-circle::before { content: "\\f2e6"; }
.bi-dash-square-dotted::before { content: "\\f2e7"; }
.bi-dash-square-fill::before { content: "\\f2e8"; }
.bi-dash-square::before { content: "\\f2e9"; }
.bi-dash::before { content: "\\f2ea"; }
.bi-diagram-2-fill::before { content: "\\f2eb"; }
.bi-diagram-2::before { content: "\\f2ec"; }
.bi-diagram-3-fill::before { content: "\\f2ed"; }
.bi-diagram-3::before { content: "\\f2ee"; }
.bi-diamond-fill::before { content: "\\f2ef"; }
.bi-diamond-half::before { content: "\\f2f0"; }
.bi-diamond::before { content: "\\f2f1"; }
.bi-dice-1-fill::before { content: "\\f2f2"; }
.bi-dice-1::before { content: "\\f2f3"; }
.bi-dice-2-fill::before { content: "\\f2f4"; }
.bi-dice-2::before { content: "\\f2f5"; }
.bi-dice-3-fill::before { content: "\\f2f6"; }
.bi-dice-3::before { content: "\\f2f7"; }
.bi-dice-4-fill::before { content: "\\f2f8"; }
.bi-dice-4::before { content: "\\f2f9"; }
.bi-dice-5-fill::before { content: "\\f2fa"; }
.bi-dice-5::before { content: "\\f2fb"; }
.bi-dice-6-fill::before { content: "\\f2fc"; }
.bi-dice-6::before { content: "\\f2fd"; }
.bi-disc-fill::before { content: "\\f2fe"; }
.bi-disc::before { content: "\\f2ff"; }
.bi-discord::before { content: "\\f300"; }
.bi-display-fill::before { content: "\\f301"; }
.bi-display::before { content: "\\f302"; }
.bi-distribute-horizontal::before { content: "\\f303"; }
.bi-distribute-vertical::before { content: "\\f304"; }
.bi-door-closed-fill::before { content: "\\f305"; }
.bi-door-closed::before { content: "\\f306"; }
.bi-door-open-fill::before { content: "\\f307"; }
.bi-door-open::before { content: "\\f308"; }
.bi-dot::before { content: "\\f309"; }
.bi-download::before { content: "\\f30a"; }
.bi-droplet-fill::before { content: "\\f30b"; }
.bi-droplet-half::before { content: "\\f30c"; }
.bi-droplet::before { content: "\\f30d"; }
.bi-earbuds::before { content: "\\f30e"; }
.bi-easel-fill::before { content: "\\f30f"; }
.bi-easel::before { content: "\\f310"; }
.bi-egg-fill::before { content: "\\f311"; }
.bi-egg-fried::before { content: "\\f312"; }
.bi-egg::before { content: "\\f313"; }
.bi-eject-fill::before { content: "\\f314"; }
.bi-eject::before { content: "\\f315"; }
.bi-emoji-angry-fill::before { content: "\\f316"; }
.bi-emoji-angry::before { content: "\\f317"; }
.bi-emoji-dizzy-fill::before { content: "\\f318"; }
.bi-emoji-dizzy::before { content: "\\f319"; }
.bi-emoji-expressionless-fill::before { content: "\\f31a"; }
.bi-emoji-expressionless::before { content: "\\f31b"; }
.bi-emoji-frown-fill::before { content: "\\f31c"; }
.bi-emoji-frown::before { content: "\\f31d"; }
.bi-emoji-heart-eyes-fill::before { content: "\\f31e"; }
.bi-emoji-heart-eyes::before { content: "\\f31f"; }
.bi-emoji-laughing-fill::before { content: "\\f320"; }
.bi-emoji-laughing::before { content: "\\f321"; }
.bi-emoji-neutral-fill::before { content: "\\f322"; }
.bi-emoji-neutral::before { content: "\\f323"; }
.bi-emoji-smile-fill::before { content: "\\f324"; }
.bi-emoji-smile-upside-down-fill::before { content: "\\f325"; }
.bi-emoji-smile-upside-down::before { content: "\\f326"; }
.bi-emoji-smile::before { content: "\\f327"; }
.bi-emoji-sunglasses-fill::before { content: "\\f328"; }
.bi-emoji-sunglasses::before { content: "\\f329"; }
.bi-emoji-wink-fill::before { content: "\\f32a"; }
.bi-emoji-wink::before { content: "\\f32b"; }
.bi-envelope-fill::before { content: "\\f32c"; }
.bi-envelope-open-fill::before { content: "\\f32d"; }
.bi-envelope-open::before { content: "\\f32e"; }
.bi-envelope::before { content: "\\f32f"; }
.bi-eraser-fill::before { content: "\\f330"; }
.bi-eraser::before { content: "\\f331"; }
.bi-exclamation-circle-fill::before { content: "\\f332"; }
.bi-exclamation-circle::before { content: "\\f333"; }
.bi-exclamation-diamond-fill::before { content: "\\f334"; }
.bi-exclamation-diamond::before { content: "\\f335"; }
.bi-exclamation-octagon-fill::before { content: "\\f336"; }
.bi-exclamation-octagon::before { content: "\\f337"; }
.bi-exclamation-square-fill::before { content: "\\f338"; }
.bi-exclamation-square::before { content: "\\f339"; }
.bi-exclamation-triangle-fill::before { content: "\\f33a"; }
.bi-exclamation-triangle::before { content: "\\f33b"; }
.bi-exclamation::before { content: "\\f33c"; }
.bi-exclude::before { content: "\\f33d"; }
.bi-eye-fill::before { content: "\\f33e"; }
.bi-eye-slash-fill::before { content: "\\f33f"; }
.bi-eye-slash::before { content: "\\f340"; }
.bi-eye::before { content: "\\f341"; }
.bi-eyedropper::before { content: "\\f342"; }
.bi-eyeglasses::before { content: "\\f343"; }
.bi-facebook::before { content: "\\f344"; }
.bi-file-arrow-down-fill::before { content: "\\f345"; }
.bi-file-arrow-down::before { content: "\\f346"; }
.bi-file-arrow-up-fill::before { content: "\\f347"; }
.bi-file-arrow-up::before { content: "\\f348"; }
.bi-file-bar-graph-fill::before { content: "\\f349"; }
.bi-file-bar-graph::before { content: "\\f34a"; }
.bi-file-binary-fill::before { content: "\\f34b"; }
.bi-file-binary::before { content: "\\f34c"; }
.bi-file-break-fill::before { content: "\\f34d"; }
.bi-file-break::before { content: "\\f34e"; }
.bi-file-check-fill::before { content: "\\f34f"; }
.bi-file-check::before { content: "\\f350"; }
.bi-file-code-fill::before { content: "\\f351"; }
.bi-file-code::before { content: "\\f352"; }
.bi-file-diff-fill::before { content: "\\f353"; }
.bi-file-diff::before { content: "\\f354"; }
.bi-file-earmark-arrow-down-fill::before { content: "\\f355"; }
.bi-file-earmark-arrow-down::before { content: "\\f356"; }
.bi-file-earmark-arrow-up-fill::before { content: "\\f357"; }
.bi-file-earmark-arrow-up::before { content: "\\f358"; }
.bi-file-earmark-bar-graph-fill::before { content: "\\f359"; }
.bi-file-earmark-bar-graph::before { content: "\\f35a"; }
.bi-file-earmark-binary-fill::before { content: "\\f35b"; }
.bi-file-earmark-binary::before { content: "\\f35c"; }
.bi-file-earmark-break-fill::before { content: "\\f35d"; }
.bi-file-earmark-break::before { content: "\\f35e"; }
.bi-file-earmark-check-fill::before { content: "\\f35f"; }
.bi-file-earmark-check::before { content: "\\f360"; }
.bi-file-earmark-code-fill::before { content: "\\f361"; }
.bi-file-earmark-code::before { content: "\\f362"; }
.bi-file-earmark-diff-fill::before { content: "\\f363"; }
.bi-file-earmark-diff::before { content: "\\f364"; }
.bi-file-earmark-easel-fill::before { content: "\\f365"; }
.bi-file-earmark-easel::before { content: "\\f366"; }
.bi-file-earmark-excel-fill::before { content: "\\f367"; }
.bi-file-earmark-excel::before { content: "\\f368"; }
.bi-file-earmark-fill::before { content: "\\f369"; }
.bi-file-earmark-font-fill::before { content: "\\f36a"; }
.bi-file-earmark-font::before { content: "\\f36b"; }
.bi-file-earmark-image-fill::before { content: "\\f36c"; }
.bi-file-earmark-image::before { content: "\\f36d"; }
.bi-file-earmark-lock-fill::before { content: "\\f36e"; }
.bi-file-earmark-lock::before { content: "\\f36f"; }
.bi-file-earmark-lock2-fill::before { content: "\\f370"; }
.bi-file-earmark-lock2::before { content: "\\f371"; }
.bi-file-earmark-medical-fill::before { content: "\\f372"; }
.bi-file-earmark-medical::before { content: "\\f373"; }
.bi-file-earmark-minus-fill::before { content: "\\f374"; }
.bi-file-earmark-minus::before { content: "\\f375"; }
.bi-file-earmark-music-fill::before { content: "\\f376"; }
.bi-file-earmark-music::before { content: "\\f377"; }
.bi-file-earmark-person-fill::before { content: "\\f378"; }
.bi-file-earmark-person::before { content: "\\f379"; }
.bi-file-earmark-play-fill::before { content: "\\f37a"; }
.bi-file-earmark-play::before { content: "\\f37b"; }
.bi-file-earmark-plus-fill::before { content: "\\f37c"; }
.bi-file-earmark-plus::before { content: "\\f37d"; }
.bi-file-earmark-post-fill::before { content: "\\f37e"; }
.bi-file-earmark-post::before { content: "\\f37f"; }
.bi-file-earmark-ppt-fill::before { content: "\\f380"; }
.bi-file-earmark-ppt::before { content: "\\f381"; }
.bi-file-earmark-richtext-fill::before { content: "\\f382"; }
.bi-file-earmark-richtext::before { content: "\\f383"; }
.bi-file-earmark-ruled-fill::before { content: "\\f384"; }
.bi-file-earmark-ruled::before { content: "\\f385"; }
.bi-file-earmark-slides-fill::before { content: "\\f386"; }
.bi-file-earmark-slides::before { content: "\\f387"; }
.bi-file-earmark-spreadsheet-fill::before { content: "\\f388"; }
.bi-file-earmark-spreadsheet::before { content: "\\f389"; }
.bi-file-earmark-text-fill::before { content: "\\f38a"; }
.bi-file-earmark-text::before { content: "\\f38b"; }
.bi-file-earmark-word-fill::before { content: "\\f38c"; }
.bi-file-earmark-word::before { content: "\\f38d"; }
.bi-file-earmark-x-fill::before { content: "\\f38e"; }
.bi-file-earmark-x::before { content: "\\f38f"; }
.bi-file-earmark-zip-fill::before { content: "\\f390"; }
.bi-file-earmark-zip::before { content: "\\f391"; }
.bi-file-earmark::before { content: "\\f392"; }
.bi-file-easel-fill::before { content: "\\f393"; }
.bi-file-easel::before { content: "\\f394"; }
.bi-file-excel-fill::before { content: "\\f395"; }
.bi-file-excel::before { content: "\\f396"; }
.bi-file-fill::before { content: "\\f397"; }
.bi-file-font-fill::before { content: "\\f398"; }
.bi-file-font::before { content: "\\f399"; }
.bi-file-image-fill::before { content: "\\f39a"; }
.bi-file-image::before { content: "\\f39b"; }
.bi-file-lock-fill::before { content: "\\f39c"; }
.bi-file-lock::before { content: "\\f39d"; }
.bi-file-lock2-fill::before { content: "\\f39e"; }
.bi-file-lock2::before { content: "\\f39f"; }
.bi-file-medical-fill::before { content: "\\f3a0"; }
.bi-file-medical::before { content: "\\f3a1"; }
.bi-file-minus-fill::before { content: "\\f3a2"; }
.bi-file-minus::before { content: "\\f3a3"; }
.bi-file-music-fill::before { content: "\\f3a4"; }
.bi-file-music::before { content: "\\f3a5"; }
.bi-file-person-fill::before { content: "\\f3a6"; }
.bi-file-person::before { content: "\\f3a7"; }
.bi-file-play-fill::before { content: "\\f3a8"; }
.bi-file-play::before { content: "\\f3a9"; }
.bi-file-plus-fill::before { content: "\\f3aa"; }
.bi-file-plus::before { content: "\\f3ab"; }
.bi-file-post-fill::before { content: "\\f3ac"; }
.bi-file-post::before { content: "\\f3ad"; }
.bi-file-ppt-fill::before { content: "\\f3ae"; }
.bi-file-ppt::before { content: "\\f3af"; }
.bi-file-richtext-fill::before { content: "\\f3b0"; }
.bi-file-richtext::before { content: "\\f3b1"; }
.bi-file-ruled-fill::before { content: "\\f3b2"; }
.bi-file-ruled::before { content: "\\f3b3"; }
.bi-file-slides-fill::before { content: "\\f3b4"; }
.bi-file-slides::before { content: "\\f3b5"; }
.bi-file-spreadsheet-fill::before { content: "\\f3b6"; }
.bi-file-spreadsheet::before { content: "\\f3b7"; }
.bi-file-text-fill::before { content: "\\f3b8"; }
.bi-file-text::before { content: "\\f3b9"; }
.bi-file-word-fill::before { content: "\\f3ba"; }
.bi-file-word::before { content: "\\f3bb"; }
.bi-file-x-fill::before { content: "\\f3bc"; }
.bi-file-x::before { content: "\\f3bd"; }
.bi-file-zip-fill::before { content: "\\f3be"; }
.bi-file-zip::before { content: "\\f3bf"; }
.bi-file::before { content: "\\f3c0"; }
.bi-files-alt::before { content: "\\f3c1"; }
.bi-files::before { content: "\\f3c2"; }
.bi-film::before { content: "\\f3c3"; }
.bi-filter-circle-fill::before { content: "\\f3c4"; }
.bi-filter-circle::before { content: "\\f3c5"; }
.bi-filter-left::before { content: "\\f3c6"; }
.bi-filter-right::before { content: "\\f3c7"; }
.bi-filter-square-fill::before { content: "\\f3c8"; }
.bi-filter-square::before { content: "\\f3c9"; }
.bi-filter::before { content: "\\f3ca"; }
.bi-flag-fill::before { content: "\\f3cb"; }
.bi-flag::before { content: "\\f3cc"; }
.bi-flower1::before { content: "\\f3cd"; }
.bi-flower2::before { content: "\\f3ce"; }
.bi-flower3::before { content: "\\f3cf"; }
.bi-folder-check::before { content: "\\f3d0"; }
.bi-folder-fill::before { content: "\\f3d1"; }
.bi-folder-minus::before { content: "\\f3d2"; }
.bi-folder-plus::before { content: "\\f3d3"; }
.bi-folder-symlink-fill::before { content: "\\f3d4"; }
.bi-folder-symlink::before { content: "\\f3d5"; }
.bi-folder-x::before { content: "\\f3d6"; }
.bi-folder::before { content: "\\f3d7"; }
.bi-folder2-open::before { content: "\\f3d8"; }
.bi-folder2::before { content: "\\f3d9"; }
.bi-fonts::before { content: "\\f3da"; }
.bi-forward-fill::before { content: "\\f3db"; }
.bi-forward::before { content: "\\f3dc"; }
.bi-front::before { content: "\\f3dd"; }
.bi-fullscreen-exit::before { content: "\\f3de"; }
.bi-fullscreen::before { content: "\\f3df"; }
.bi-funnel-fill::before { content: "\\f3e0"; }
.bi-funnel::before { content: "\\f3e1"; }
.bi-gear-fill::before { content: "\\f3e2"; }
.bi-gear-wide-connected::before { content: "\\f3e3"; }
.bi-gear-wide::before { content: "\\f3e4"; }
.bi-gear::before { content: "\\f3e5"; }
.bi-gem::before { content: "\\f3e6"; }
.bi-geo-alt-fill::before { content: "\\f3e7"; }
.bi-geo-alt::before { content: "\\f3e8"; }
.bi-geo-fill::before { content: "\\f3e9"; }
.bi-geo::before { content: "\\f3ea"; }
.bi-gift-fill::before { content: "\\f3eb"; }
.bi-gift::before { content: "\\f3ec"; }
.bi-github::before { content: "\\f3ed"; }
.bi-globe::before { content: "\\f3ee"; }
.bi-globe2::before { content: "\\f3ef"; }
.bi-google::before { content: "\\f3f0"; }
.bi-graph-down::before { content: "\\f3f1"; }
.bi-graph-up::before { content: "\\f3f2"; }
.bi-grid-1x2-fill::before { content: "\\f3f3"; }
.bi-grid-1x2::before { content: "\\f3f4"; }
.bi-grid-3x2-gap-fill::before { content: "\\f3f5"; }
.bi-grid-3x2-gap::before { content: "\\f3f6"; }
.bi-grid-3x2::before { content: "\\f3f7"; }
.bi-grid-3x3-gap-fill::before { content: "\\f3f8"; }
.bi-grid-3x3-gap::before { content: "\\f3f9"; }
.bi-grid-3x3::before { content: "\\f3fa"; }
.bi-grid-fill::before { content: "\\f3fb"; }
.bi-grid::before { content: "\\f3fc"; }
.bi-grip-horizontal::before { content: "\\f3fd"; }
.bi-grip-vertical::before { content: "\\f3fe"; }
.bi-hammer::before { content: "\\f3ff"; }
.bi-hand-index-fill::before { content: "\\f400"; }
.bi-hand-index-thumb-fill::before { content: "\\f401"; }
.bi-hand-index-thumb::before { content: "\\f402"; }
.bi-hand-index::before { content: "\\f403"; }
.bi-hand-thumbs-down-fill::before { content: "\\f404"; }
.bi-hand-thumbs-down::before { content: "\\f405"; }
.bi-hand-thumbs-up-fill::before { content: "\\f406"; }
.bi-hand-thumbs-up::before { content: "\\f407"; }
.bi-handbag-fill::before { content: "\\f408"; }
.bi-handbag::before { content: "\\f409"; }
.bi-hash::before { content: "\\f40a"; }
.bi-hdd-fill::before { content: "\\f40b"; }
.bi-hdd-network-fill::before { content: "\\f40c"; }
.bi-hdd-network::before { content: "\\f40d"; }
.bi-hdd-rack-fill::before { content: "\\f40e"; }
.bi-hdd-rack::before { content: "\\f40f"; }
.bi-hdd-stack-fill::before { content: "\\f410"; }
.bi-hdd-stack::before { content: "\\f411"; }
.bi-hdd::before { content: "\\f412"; }
.bi-headphones::before { content: "\\f413"; }
.bi-headset::before { content: "\\f414"; }
.bi-heart-fill::before { content: "\\f415"; }
.bi-heart-half::before { content: "\\f416"; }
.bi-heart::before { content: "\\f417"; }
.bi-heptagon-fill::before { content: "\\f418"; }
.bi-heptagon-half::before { content: "\\f419"; }
.bi-heptagon::before { content: "\\f41a"; }
.bi-hexagon-fill::before { content: "\\f41b"; }
.bi-hexagon-half::before { content: "\\f41c"; }
.bi-hexagon::before { content: "\\f41d"; }
.bi-hourglass-bottom::before { content: "\\f41e"; }
.bi-hourglass-split::before { content: "\\f41f"; }
.bi-hourglass-top::before { content: "\\f420"; }
.bi-hourglass::before { content: "\\f421"; }
.bi-house-door-fill::before { content: "\\f422"; }
.bi-house-door::before { content: "\\f423"; }
.bi-house-fill::before { content: "\\f424"; }
.bi-house::before { content: "\\f425"; }
.bi-hr::before { content: "\\f426"; }
.bi-hurricane::before { content: "\\f427"; }
.bi-image-alt::before { content: "\\f428"; }
.bi-image-fill::before { content: "\\f429"; }
.bi-image::before { content: "\\f42a"; }
.bi-images::before { content: "\\f42b"; }
.bi-inbox-fill::before { content: "\\f42c"; }
.bi-inbox::before { content: "\\f42d"; }
.bi-inboxes-fill::before { content: "\\f42e"; }
.bi-inboxes::before { content: "\\f42f"; }
.bi-info-circle-fill::before { content: "\\f430"; }
.bi-info-circle::before { content: "\\f431"; }
.bi-info-square-fill::before { content: "\\f432"; }
.bi-info-square::before { content: "\\f433"; }
.bi-info::before { content: "\\f434"; }
.bi-input-cursor-text::before { content: "\\f435"; }
.bi-input-cursor::before { content: "\\f436"; }
.bi-instagram::before { content: "\\f437"; }
.bi-intersect::before { content: "\\f438"; }
.bi-journal-album::before { content: "\\f439"; }
.bi-journal-arrow-down::before { content: "\\f43a"; }
.bi-journal-arrow-up::before { content: "\\f43b"; }
.bi-journal-bookmark-fill::before { content: "\\f43c"; }
.bi-journal-bookmark::before { content: "\\f43d"; }
.bi-journal-check::before { content: "\\f43e"; }
.bi-journal-code::before { content: "\\f43f"; }
.bi-journal-medical::before { content: "\\f440"; }
.bi-journal-minus::before { content: "\\f441"; }
.bi-journal-plus::before { content: "\\f442"; }
.bi-journal-richtext::before { content: "\\f443"; }
.bi-journal-text::before { content: "\\f444"; }
.bi-journal-x::before { content: "\\f445"; }
.bi-journal::before { content: "\\f446"; }
.bi-journals::before { content: "\\f447"; }
.bi-joystick::before { content: "\\f448"; }
.bi-justify-left::before { content: "\\f449"; }
.bi-justify-right::before { content: "\\f44a"; }
.bi-justify::before { content: "\\f44b"; }
.bi-kanban-fill::before { content: "\\f44c"; }
.bi-kanban::before { content: "\\f44d"; }
.bi-key-fill::before { content: "\\f44e"; }
.bi-key::before { content: "\\f44f"; }
.bi-keyboard-fill::before { content: "\\f450"; }
.bi-keyboard::before { content: "\\f451"; }
.bi-ladder::before { content: "\\f452"; }
.bi-lamp-fill::before { content: "\\f453"; }
.bi-lamp::before { content: "\\f454"; }
.bi-laptop-fill::before { content: "\\f455"; }
.bi-laptop::before { content: "\\f456"; }
.bi-layer-backward::before { content: "\\f457"; }
.bi-layer-forward::before { content: "\\f458"; }
.bi-layers-fill::before { content: "\\f459"; }
.bi-layers-half::before { content: "\\f45a"; }
.bi-layers::before { content: "\\f45b"; }
.bi-layout-sidebar-inset-reverse::before { content: "\\f45c"; }
.bi-layout-sidebar-inset::before { content: "\\f45d"; }
.bi-layout-sidebar-reverse::before { content: "\\f45e"; }
.bi-layout-sidebar::before { content: "\\f45f"; }
.bi-layout-split::before { content: "\\f460"; }
.bi-layout-text-sidebar-reverse::before { content: "\\f461"; }
.bi-layout-text-sidebar::before { content: "\\f462"; }
.bi-layout-text-window-reverse::before { content: "\\f463"; }
.bi-layout-text-window::before { content: "\\f464"; }
.bi-layout-three-columns::before { content: "\\f465"; }
.bi-layout-wtf::before { content: "\\f466"; }
.bi-life-preserver::before { content: "\\f467"; }
.bi-lightbulb-fill::before { content: "\\f468"; }
.bi-lightbulb-off-fill::before { content: "\\f469"; }
.bi-lightbulb-off::before { content: "\\f46a"; }
.bi-lightbulb::before { content: "\\f46b"; }
.bi-lightning-charge-fill::before { content: "\\f46c"; }
.bi-lightning-charge::before { content: "\\f46d"; }
.bi-lightning-fill::before { content: "\\f46e"; }
.bi-lightning::before { content: "\\f46f"; }
.bi-link-45deg::before { content: "\\f470"; }
.bi-link::before { content: "\\f471"; }
.bi-linkedin::before { content: "\\f472"; }
.bi-list-check::before { content: "\\f473"; }
.bi-list-nested::before { content: "\\f474"; }
.bi-list-ol::before { content: "\\f475"; }
.bi-list-stars::before { content: "\\f476"; }
.bi-list-task::before { content: "\\f477"; }
.bi-list-ul::before { content: "\\f478"; }
.bi-list::before { content: "\\f479"; }
.bi-lock-fill::before { content: "\\f47a"; }
.bi-lock::before { content: "\\f47b"; }
.bi-mailbox::before { content: "\\f47c"; }
.bi-mailbox2::before { content: "\\f47d"; }
.bi-map-fill::before { content: "\\f47e"; }
.bi-map::before { content: "\\f47f"; }
.bi-markdown-fill::before { content: "\\f480"; }
.bi-markdown::before { content: "\\f481"; }
.bi-mask::before { content: "\\f482"; }
.bi-megaphone-fill::before { content: "\\f483"; }
.bi-megaphone::before { content: "\\f484"; }
.bi-menu-app-fill::before { content: "\\f485"; }
.bi-menu-app::before { content: "\\f486"; }
.bi-menu-button-fill::before { content: "\\f487"; }
.bi-menu-button-wide-fill::before { content: "\\f488"; }
.bi-menu-button-wide::before { content: "\\f489"; }
.bi-menu-button::before { content: "\\f48a"; }
.bi-menu-down::before { content: "\\f48b"; }
.bi-menu-up::before { content: "\\f48c"; }
.bi-mic-fill::before { content: "\\f48d"; }
.bi-mic-mute-fill::before { content: "\\f48e"; }
.bi-mic-mute::before { content: "\\f48f"; }
.bi-mic::before { content: "\\f490"; }
.bi-minecart-loaded::before { content: "\\f491"; }
.bi-minecart::before { content: "\\f492"; }
.bi-moisture::before { content: "\\f493"; }
.bi-moon-fill::before { content: "\\f494"; }
.bi-moon-stars-fill::before { content: "\\f495"; }
.bi-moon-stars::before { content: "\\f496"; }
.bi-moon::before { content: "\\f497"; }
.bi-mouse-fill::before { content: "\\f498"; }
.bi-mouse::before { content: "\\f499"; }
.bi-mouse2-fill::before { content: "\\f49a"; }
.bi-mouse2::before { content: "\\f49b"; }
.bi-mouse3-fill::before { content: "\\f49c"; }
.bi-mouse3::before { content: "\\f49d"; }
.bi-music-note-beamed::before { content: "\\f49e"; }
.bi-music-note-list::before { content: "\\f49f"; }
.bi-music-note::before { content: "\\f4a0"; }
.bi-music-player-fill::before { content: "\\f4a1"; }
.bi-music-player::before { content: "\\f4a2"; }
.bi-newspaper::before { content: "\\f4a3"; }
.bi-node-minus-fill::before { content: "\\f4a4"; }
.bi-node-minus::before { content: "\\f4a5"; }
.bi-node-plus-fill::before { content: "\\f4a6"; }
.bi-node-plus::before { content: "\\f4a7"; }
.bi-nut-fill::before { content: "\\f4a8"; }
.bi-nut::before { content: "\\f4a9"; }
.bi-octagon-fill::before { content: "\\f4aa"; }
.bi-octagon-half::before { content: "\\f4ab"; }
.bi-octagon::before { content: "\\f4ac"; }
.bi-option::before { content: "\\f4ad"; }
.bi-outlet::before { content: "\\f4ae"; }
.bi-paint-bucket::before { content: "\\f4af"; }
.bi-palette-fill::before { content: "\\f4b0"; }
.bi-palette::before { content: "\\f4b1"; }
.bi-palette2::before { content: "\\f4b2"; }
.bi-paperclip::before { content: "\\f4b3"; }
.bi-paragraph::before { content: "\\f4b4"; }
.bi-patch-check-fill::before { content: "\\f4b5"; }
.bi-patch-check::before { content: "\\f4b6"; }
.bi-patch-exclamation-fill::before { content: "\\f4b7"; }
.bi-patch-exclamation::before { content: "\\f4b8"; }
.bi-patch-minus-fill::before { content: "\\f4b9"; }
.bi-patch-minus::before { content: "\\f4ba"; }
.bi-patch-plus-fill::before { content: "\\f4bb"; }
.bi-patch-plus::before { content: "\\f4bc"; }
.bi-patch-question-fill::before { content: "\\f4bd"; }
.bi-patch-question::before { content: "\\f4be"; }
.bi-pause-btn-fill::before { content: "\\f4bf"; }
.bi-pause-btn::before { content: "\\f4c0"; }
.bi-pause-circle-fill::before { content: "\\f4c1"; }
.bi-pause-circle::before { content: "\\f4c2"; }
.bi-pause-fill::before { content: "\\f4c3"; }
.bi-pause::before { content: "\\f4c4"; }
.bi-peace-fill::before { content: "\\f4c5"; }
.bi-peace::before { content: "\\f4c6"; }
.bi-pen-fill::before { content: "\\f4c7"; }
.bi-pen::before { content: "\\f4c8"; }
.bi-pencil-fill::before { content: "\\f4c9"; }
.bi-pencil-square::before { content: "\\f4ca"; }
.bi-pencil::before { content: "\\f4cb"; }
.bi-pentagon-fill::before { content: "\\f4cc"; }
.bi-pentagon-half::before { content: "\\f4cd"; }
.bi-pentagon::before { content: "\\f4ce"; }
.bi-people-fill::before { content: "\\f4cf"; }
.bi-people::before { content: "\\f4d0"; }
.bi-percent::before { content: "\\f4d1"; }
.bi-person-badge-fill::before { content: "\\f4d2"; }
.bi-person-badge::before { content: "\\f4d3"; }
.bi-person-bounding-box::before { content: "\\f4d4"; }
.bi-person-check-fill::before { content: "\\f4d5"; }
.bi-person-check::before { content: "\\f4d6"; }
.bi-person-circle::before { content: "\\f4d7"; }
.bi-person-dash-fill::before { content: "\\f4d8"; }
.bi-person-dash::before { content: "\\f4d9"; }
.bi-person-fill::before { content: "\\f4da"; }
.bi-person-lines-fill::before { content: "\\f4db"; }
.bi-person-plus-fill::before { content: "\\f4dc"; }
.bi-person-plus::before { content: "\\f4dd"; }
.bi-person-square::before { content: "\\f4de"; }
.bi-person-x-fill::before { content: "\\f4df"; }
.bi-person-x::before { content: "\\f4e0"; }
.bi-person::before { content: "\\f4e1"; }
.bi-phone-fill::before { content: "\\f4e2"; }
.bi-phone-landscape-fill::before { content: "\\f4e3"; }
.bi-phone-landscape::before { content: "\\f4e4"; }
.bi-phone-vibrate-fill::before { content: "\\f4e5"; }
.bi-phone-vibrate::before { content: "\\f4e6"; }
.bi-phone::before { content: "\\f4e7"; }
.bi-pie-chart-fill::before { content: "\\f4e8"; }
.bi-pie-chart::before { content: "\\f4e9"; }
.bi-pin-angle-fill::before { content: "\\f4ea"; }
.bi-pin-angle::before { content: "\\f4eb"; }
.bi-pin-fill::before { content: "\\f4ec"; }
.bi-pin::before { content: "\\f4ed"; }
.bi-pip-fill::before { content: "\\f4ee"; }
.bi-pip::before { content: "\\f4ef"; }
.bi-play-btn-fill::before { content: "\\f4f0"; }
.bi-play-btn::before { content: "\\f4f1"; }
.bi-play-circle-fill::before { content: "\\f4f2"; }
.bi-play-circle::before { content: "\\f4f3"; }
.bi-play-fill::before { content: "\\f4f4"; }
.bi-play::before { content: "\\f4f5"; }
.bi-plug-fill::before { content: "\\f4f6"; }
.bi-plug::before { content: "\\f4f7"; }
.bi-plus-circle-dotted::before { content: "\\f4f8"; }
.bi-plus-circle-fill::before { content: "\\f4f9"; }
.bi-plus-circle::before { content: "\\f4fa"; }
.bi-plus-square-dotted::before { content: "\\f4fb"; }
.bi-plus-square-fill::before { content: "\\f4fc"; }
.bi-plus-square::before { content: "\\f4fd"; }
.bi-plus::before { content: "\\f4fe"; }
.bi-power::before { content: "\\f4ff"; }
.bi-printer-fill::before { content: "\\f500"; }
.bi-printer::before { content: "\\f501"; }
.bi-puzzle-fill::before { content: "\\f502"; }
.bi-puzzle::before { content: "\\f503"; }
.bi-question-circle-fill::before { content: "\\f504"; }
.bi-question-circle::before { content: "\\f505"; }
.bi-question-diamond-fill::before { content: "\\f506"; }
.bi-question-diamond::before { content: "\\f507"; }
.bi-question-octagon-fill::before { content: "\\f508"; }
.bi-question-octagon::before { content: "\\f509"; }
.bi-question-square-fill::before { content: "\\f50a"; }
.bi-question-square::before { content: "\\f50b"; }
.bi-question::before { content: "\\f50c"; }
.bi-rainbow::before { content: "\\f50d"; }
.bi-receipt-cutoff::before { content: "\\f50e"; }
.bi-receipt::before { content: "\\f50f"; }
.bi-reception-0::before { content: "\\f510"; }
.bi-reception-1::before { content: "\\f511"; }
.bi-reception-2::before { content: "\\f512"; }
.bi-reception-3::before { content: "\\f513"; }
.bi-reception-4::before { content: "\\f514"; }
.bi-record-btn-fill::before { content: "\\f515"; }
.bi-record-btn::before { content: "\\f516"; }
.bi-record-circle-fill::before { content: "\\f517"; }
.bi-record-circle::before { content: "\\f518"; }
.bi-record-fill::before { content: "\\f519"; }
.bi-record::before { content: "\\f51a"; }
.bi-record2-fill::before { content: "\\f51b"; }
.bi-record2::before { content: "\\f51c"; }
.bi-reply-all-fill::before { content: "\\f51d"; }
.bi-reply-all::before { content: "\\f51e"; }
.bi-reply-fill::before { content: "\\f51f"; }
.bi-reply::before { content: "\\f520"; }
.bi-rss-fill::before { content: "\\f521"; }
.bi-rss::before { content: "\\f522"; }
.bi-rulers::before { content: "\\f523"; }
.bi-save-fill::before { content: "\\f524"; }
.bi-save::before { content: "\\f525"; }
.bi-save2-fill::before { content: "\\f526"; }
.bi-save2::before { content: "\\f527"; }
.bi-scissors::before { content: "\\f528"; }
.bi-screwdriver::before { content: "\\f529"; }
.bi-search::before { content: "\\f52a"; }
.bi-segmented-nav::before { content: "\\f52b"; }
.bi-server::before { content: "\\f52c"; }
.bi-share-fill::before { content: "\\f52d"; }
.bi-share::before { content: "\\f52e"; }
.bi-shield-check::before { content: "\\f52f"; }
.bi-shield-exclamation::before { content: "\\f530"; }
.bi-shield-fill-check::before { content: "\\f531"; }
.bi-shield-fill-exclamation::before { content: "\\f532"; }
.bi-shield-fill-minus::before { content: "\\f533"; }
.bi-shield-fill-plus::before { content: "\\f534"; }
.bi-shield-fill-x::before { content: "\\f535"; }
.bi-shield-fill::before { content: "\\f536"; }
.bi-shield-lock-fill::before { content: "\\f537"; }
.bi-shield-lock::before { content: "\\f538"; }
.bi-shield-minus::before { content: "\\f539"; }
.bi-shield-plus::before { content: "\\f53a"; }
.bi-shield-shaded::before { content: "\\f53b"; }
.bi-shield-slash-fill::before { content: "\\f53c"; }
.bi-shield-slash::before { content: "\\f53d"; }
.bi-shield-x::before { content: "\\f53e"; }
.bi-shield::before { content: "\\f53f"; }
.bi-shift-fill::before { content: "\\f540"; }
.bi-shift::before { content: "\\f541"; }
.bi-shop-window::before { content: "\\f542"; }
.bi-shop::before { content: "\\f543"; }
.bi-shuffle::before { content: "\\f544"; }
.bi-signpost-2-fill::before { content: "\\f545"; }
.bi-signpost-2::before { content: "\\f546"; }
.bi-signpost-fill::before { content: "\\f547"; }
.bi-signpost-split-fill::before { content: "\\f548"; }
.bi-signpost-split::before { content: "\\f549"; }
.bi-signpost::before { content: "\\f54a"; }
.bi-sim-fill::before { content: "\\f54b"; }
.bi-sim::before { content: "\\f54c"; }
.bi-skip-backward-btn-fill::before { content: "\\f54d"; }
.bi-skip-backward-btn::before { content: "\\f54e"; }
.bi-skip-backward-circle-fill::before { content: "\\f54f"; }
.bi-skip-backward-circle::before { content: "\\f550"; }
.bi-skip-backward-fill::before { content: "\\f551"; }
.bi-skip-backward::before { content: "\\f552"; }
.bi-skip-end-btn-fill::before { content: "\\f553"; }
.bi-skip-end-btn::before { content: "\\f554"; }
.bi-skip-end-circle-fill::before { content: "\\f555"; }
.bi-skip-end-circle::before { content: "\\f556"; }
.bi-skip-end-fill::before { content: "\\f557"; }
.bi-skip-end::before { content: "\\f558"; }
.bi-skip-forward-btn-fill::before { content: "\\f559"; }
.bi-skip-forward-btn::before { content: "\\f55a"; }
.bi-skip-forward-circle-fill::before { content: "\\f55b"; }
.bi-skip-forward-circle::before { content: "\\f55c"; }
.bi-skip-forward-fill::before { content: "\\f55d"; }
.bi-skip-forward::before { content: "\\f55e"; }
.bi-skip-start-btn-fill::before { content: "\\f55f"; }
.bi-skip-start-btn::before { content: "\\f560"; }
.bi-skip-start-circle-fill::before { content: "\\f561"; }
.bi-skip-start-circle::before { content: "\\f562"; }
.bi-skip-start-fill::before { content: "\\f563"; }
.bi-skip-start::before { content: "\\f564"; }
.bi-slack::before { content: "\\f565"; }
.bi-slash-circle-fill::before { content: "\\f566"; }
.bi-slash-circle::before { content: "\\f567"; }
.bi-slash-square-fill::before { content: "\\f568"; }
.bi-slash-square::before { content: "\\f569"; }
.bi-slash::before { content: "\\f56a"; }
.bi-sliders::before { content: "\\f56b"; }
.bi-smartwatch::before { content: "\\f56c"; }
.bi-snow::before { content: "\\f56d"; }
.bi-snow2::before { content: "\\f56e"; }
.bi-snow3::before { content: "\\f56f"; }
.bi-sort-alpha-down-alt::before { content: "\\f570"; }
.bi-sort-alpha-down::before { content: "\\f571"; }
.bi-sort-alpha-up-alt::before { content: "\\f572"; }
.bi-sort-alpha-up::before { content: "\\f573"; }
.bi-sort-down-alt::before { content: "\\f574"; }
.bi-sort-down::before { content: "\\f575"; }
.bi-sort-numeric-down-alt::before { content: "\\f576"; }
.bi-sort-numeric-down::before { content: "\\f577"; }
.bi-sort-numeric-up-alt::before { content: "\\f578"; }
.bi-sort-numeric-up::before { content: "\\f579"; }
.bi-sort-up-alt::before { content: "\\f57a"; }
.bi-sort-up::before { content: "\\f57b"; }
.bi-soundwave::before { content: "\\f57c"; }
.bi-speaker-fill::before { content: "\\f57d"; }
.bi-speaker::before { content: "\\f57e"; }
.bi-speedometer::before { content: "\\f57f"; }
.bi-speedometer2::before { content: "\\f580"; }
.bi-spellcheck::before { content: "\\f581"; }
.bi-square-fill::before { content: "\\f582"; }
.bi-square-half::before { content: "\\f583"; }
.bi-square::before { content: "\\f584"; }
.bi-stack::before { content: "\\f585"; }
.bi-star-fill::before { content: "\\f586"; }
.bi-star-half::before { content: "\\f587"; }
.bi-star::before { content: "\\f588"; }
.bi-stars::before { content: "\\f589"; }
.bi-stickies-fill::before { content: "\\f58a"; }
.bi-stickies::before { content: "\\f58b"; }
.bi-sticky-fill::before { content: "\\f58c"; }
.bi-sticky::before { content: "\\f58d"; }
.bi-stop-btn-fill::before { content: "\\f58e"; }
.bi-stop-btn::before { content: "\\f58f"; }
.bi-stop-circle-fill::before { content: "\\f590"; }
.bi-stop-circle::before { content: "\\f591"; }
.bi-stop-fill::before { content: "\\f592"; }
.bi-stop::before { content: "\\f593"; }
.bi-stoplights-fill::before { content: "\\f594"; }
.bi-stoplights::before { content: "\\f595"; }
.bi-stopwatch-fill::before { content: "\\f596"; }
.bi-stopwatch::before { content: "\\f597"; }
.bi-subtract::before { content: "\\f598"; }
.bi-suit-club-fill::before { content: "\\f599"; }
.bi-suit-club::before { content: "\\f59a"; }
.bi-suit-diamond-fill::before { content: "\\f59b"; }
.bi-suit-diamond::before { content: "\\f59c"; }
.bi-suit-heart-fill::before { content: "\\f59d"; }
.bi-suit-heart::before { content: "\\f59e"; }
.bi-suit-spade-fill::before { content: "\\f59f"; }
.bi-suit-spade::before { content: "\\f5a0"; }
.bi-sun-fill::before { content: "\\f5a1"; }
.bi-sun::before { content: "\\f5a2"; }
.bi-sunglasses::before { content: "\\f5a3"; }
.bi-sunrise-fill::before { content: "\\f5a4"; }
.bi-sunrise::before { content: "\\f5a5"; }
.bi-sunset-fill::before { content: "\\f5a6"; }
.bi-sunset::before { content: "\\f5a7"; }
.bi-symmetry-horizontal::before { content: "\\f5a8"; }
.bi-symmetry-vertical::before { content: "\\f5a9"; }
.bi-table::before { content: "\\f5aa"; }
.bi-tablet-fill::before { content: "\\f5ab"; }
.bi-tablet-landscape-fill::before { content: "\\f5ac"; }
.bi-tablet-landscape::before { content: "\\f5ad"; }
.bi-tablet::before { content: "\\f5ae"; }
.bi-tag-fill::before { content: "\\f5af"; }
.bi-tag::before { content: "\\f5b0"; }
.bi-tags-fill::before { content: "\\f5b1"; }
.bi-tags::before { content: "\\f5b2"; }
.bi-telegram::before { content: "\\f5b3"; }
.bi-telephone-fill::before { content: "\\f5b4"; }
.bi-telephone-forward-fill::before { content: "\\f5b5"; }
.bi-telephone-forward::before { content: "\\f5b6"; }
.bi-telephone-inbound-fill::before { content: "\\f5b7"; }
.bi-telephone-inbound::before { content: "\\f5b8"; }
.bi-telephone-minus-fill::before { content: "\\f5b9"; }
.bi-telephone-minus::before { content: "\\f5ba"; }
.bi-telephone-outbound-fill::before { content: "\\f5bb"; }
.bi-telephone-outbound::before { content: "\\f5bc"; }
.bi-telephone-plus-fill::before { content: "\\f5bd"; }
.bi-telephone-plus::before { content: "\\f5be"; }
.bi-telephone-x-fill::before { content: "\\f5bf"; }
.bi-telephone-x::before { content: "\\f5c0"; }
.bi-telephone::before { content: "\\f5c1"; }
.bi-terminal-fill::before { content: "\\f5c2"; }
.bi-terminal::before { content: "\\f5c3"; }
.bi-text-center::before { content: "\\f5c4"; }
.bi-text-indent-left::before { content: "\\f5c5"; }
.bi-text-indent-right::before { content: "\\f5c6"; }
.bi-text-left::before { content: "\\f5c7"; }
.bi-text-paragraph::before { content: "\\f5c8"; }
.bi-text-right::before { content: "\\f5c9"; }
.bi-textarea-resize::before { content: "\\f5ca"; }
.bi-textarea-t::before { content: "\\f5cb"; }
.bi-textarea::before { content: "\\f5cc"; }
.bi-thermometer-half::before { content: "\\f5cd"; }
.bi-thermometer-high::before { content: "\\f5ce"; }
.bi-thermometer-low::before { content: "\\f5cf"; }
.bi-thermometer-snow::before { content: "\\f5d0"; }
.bi-thermometer-sun::before { content: "\\f5d1"; }
.bi-thermometer::before { content: "\\f5d2"; }
.bi-three-dots-vertical::before { content: "\\f5d3"; }
.bi-three-dots::before { content: "\\f5d4"; }
.bi-toggle-off::before { content: "\\f5d5"; }
.bi-toggle-on::before { content: "\\f5d6"; }
.bi-toggle2-off::before { content: "\\f5d7"; }
.bi-toggle2-on::before { content: "\\f5d8"; }
.bi-toggles::before { content: "\\f5d9"; }
.bi-toggles2::before { content: "\\f5da"; }
.bi-tools::before { content: "\\f5db"; }
.bi-tornado::before { content: "\\f5dc"; }
.bi-trash-fill::before { content: "\\f5dd"; }
.bi-trash::before { content: "\\f5de"; }
.bi-trash2-fill::before { content: "\\f5df"; }
.bi-trash2::before { content: "\\f5e0"; }
.bi-tree-fill::before { content: "\\f5e1"; }
.bi-tree::before { content: "\\f5e2"; }
.bi-triangle-fill::before { content: "\\f5e3"; }
.bi-triangle-half::before { content: "\\f5e4"; }
.bi-triangle::before { content: "\\f5e5"; }
.bi-trophy-fill::before { content: "\\f5e6"; }
.bi-trophy::before { content: "\\f5e7"; }
.bi-tropical-storm::before { content: "\\f5e8"; }
.bi-truck-flatbed::before { content: "\\f5e9"; }
.bi-truck::before { content: "\\f5ea"; }
.bi-tsunami::before { content: "\\f5eb"; }
.bi-tv-fill::before { content: "\\f5ec"; }
.bi-tv::before { content: "\\f5ed"; }
.bi-twitch::before { content: "\\f5ee"; }
.bi-twitter::before { content: "\\f5ef"; }
.bi-type-bold::before { content: "\\f5f0"; }
.bi-type-h1::before { content: "\\f5f1"; }
.bi-type-h2::before { content: "\\f5f2"; }
.bi-type-h3::before { content: "\\f5f3"; }
.bi-type-italic::before { content: "\\f5f4"; }
.bi-type-strikethrough::before { content: "\\f5f5"; }
.bi-type-underline::before { content: "\\f5f6"; }
.bi-type::before { content: "\\f5f7"; }
.bi-ui-checks-grid::before { content: "\\f5f8"; }
.bi-ui-checks::before { content: "\\f5f9"; }
.bi-ui-radios-grid::before { content: "\\f5fa"; }
.bi-ui-radios::before { content: "\\f5fb"; }
.bi-umbrella-fill::before { content: "\\f5fc"; }
.bi-umbrella::before { content: "\\f5fd"; }
.bi-union::before { content: "\\f5fe"; }
.bi-unlock-fill::before { content: "\\f5ff"; }
.bi-unlock::before { content: "\\f600"; }
.bi-upc-scan::before { content: "\\f601"; }
.bi-upc::before { content: "\\f602"; }
.bi-upload::before { content: "\\f603"; }
.bi-vector-pen::before { content: "\\f604"; }
.bi-view-list::before { content: "\\f605"; }
.bi-view-stacked::before { content: "\\f606"; }
.bi-vinyl-fill::before { content: "\\f607"; }
.bi-vinyl::before { content: "\\f608"; }
.bi-voicemail::before { content: "\\f609"; }
.bi-volume-down-fill::before { content: "\\f60a"; }
.bi-volume-down::before { content: "\\f60b"; }
.bi-volume-mute-fill::before { content: "\\f60c"; }
.bi-volume-mute::before { content: "\\f60d"; }
.bi-volume-off-fill::before { content: "\\f60e"; }
.bi-volume-off::before { content: "\\f60f"; }
.bi-volume-up-fill::before { content: "\\f610"; }
.bi-volume-up::before { content: "\\f611"; }
.bi-vr::before { content: "\\f612"; }
.bi-wallet-fill::before { content: "\\f613"; }
.bi-wallet::before { content: "\\f614"; }
.bi-wallet2::before { content: "\\f615"; }
.bi-watch::before { content: "\\f616"; }
.bi-water::before { content: "\\f617"; }
.bi-whatsapp::before { content: "\\f618"; }
.bi-wifi-1::before { content: "\\f619"; }
.bi-wifi-2::before { content: "\\f61a"; }
.bi-wifi-off::before { content: "\\f61b"; }
.bi-wifi::before { content: "\\f61c"; }
.bi-wind::before { content: "\\f61d"; }
.bi-window-dock::before { content: "\\f61e"; }
.bi-window-sidebar::before { content: "\\f61f"; }
.bi-window::before { content: "\\f620"; }
.bi-wrench::before { content: "\\f621"; }
.bi-x-circle-fill::before { content: "\\f622"; }
.bi-x-circle::before { content: "\\f623"; }
.bi-x-diamond-fill::before { content: "\\f624"; }
.bi-x-diamond::before { content: "\\f625"; }
.bi-x-octagon-fill::before { content: "\\f626"; }
.bi-x-octagon::before { content: "\\f627"; }
.bi-x-square-fill::before { content: "\\f628"; }
.bi-x-square::before { content: "\\f629"; }
.bi-x::before { content: "\\f62a"; }
.bi-youtube::before { content: "\\f62b"; }
.bi-zoom-in::before { content: "\\f62c"; }
.bi-zoom-out::before { content: "\\f62d"; }
.bi-bank::before { content: "\\f62e"; }
.bi-bank2::before { content: "\\f62f"; }
.bi-bell-slash-fill::before { content: "\\f630"; }
.bi-bell-slash::before { content: "\\f631"; }
.bi-cash-coin::before { content: "\\f632"; }
.bi-check-lg::before { content: "\\f633"; }
.bi-coin::before { content: "\\f634"; }
.bi-currency-bitcoin::before { content: "\\f635"; }
.bi-currency-dollar::before { content: "\\f636"; }
.bi-currency-euro::before { content: "\\f637"; }
.bi-currency-exchange::before { content: "\\f638"; }
.bi-currency-pound::before { content: "\\f639"; }
.bi-currency-yen::before { content: "\\f63a"; }
.bi-dash-lg::before { content: "\\f63b"; }
.bi-exclamation-lg::before { content: "\\f63c"; }
.bi-file-earmark-pdf-fill::before { content: "\\f63d"; }
.bi-file-earmark-pdf::before { content: "\\f63e"; }
.bi-file-pdf-fill::before { content: "\\f63f"; }
.bi-file-pdf::before { content: "\\f640"; }
.bi-gender-ambiguous::before { content: "\\f641"; }
.bi-gender-female::before { content: "\\f642"; }
.bi-gender-male::before { content: "\\f643"; }
.bi-gender-trans::before { content: "\\f644"; }
.bi-headset-vr::before { content: "\\f645"; }
.bi-info-lg::before { content: "\\f646"; }
.bi-mastodon::before { content: "\\f647"; }
.bi-messenger::before { content: "\\f648"; }
.bi-piggy-bank-fill::before { content: "\\f649"; }
.bi-piggy-bank::before { content: "\\f64a"; }
.bi-pin-map-fill::before { content: "\\f64b"; }
.bi-pin-map::before { content: "\\f64c"; }
.bi-plus-lg::before { content: "\\f64d"; }
.bi-question-lg::before { content: "\\f64e"; }
.bi-recycle::before { content: "\\f64f"; }
.bi-reddit::before { content: "\\f650"; }
.bi-safe-fill::before { content: "\\f651"; }
.bi-safe2-fill::before { content: "\\f652"; }
.bi-safe2::before { content: "\\f653"; }
.bi-sd-card-fill::before { content: "\\f654"; }
.bi-sd-card::before { content: "\\f655"; }
.bi-skype::before { content: "\\f656"; }
.bi-slash-lg::before { content: "\\f657"; }
.bi-translate::before { content: "\\f658"; }
.bi-x-lg::before { content: "\\f659"; }
.bi-safe::before { content: "\\f65a"; }
.bi-apple::before { content: "\\f65b"; }
.bi-microsoft::before { content: "\\f65d"; }
.bi-windows::before { content: "\\f65e"; }
.bi-behance::before { content: "\\f65c"; }
.bi-dribbble::before { content: "\\f65f"; }
.bi-line::before { content: "\\f660"; }
.bi-medium::before { content: "\\f661"; }
.bi-paypal::before { content: "\\f662"; }
.bi-pinterest::before { content: "\\f663"; }
.bi-signal::before { content: "\\f664"; }
.bi-snapchat::before { content: "\\f665"; }
.bi-spotify::before { content: "\\f666"; }
.bi-stack-overflow::before { content: "\\f667"; }
.bi-strava::before { content: "\\f668"; }
.bi-wordpress::before { content: "\\f669"; }
.bi-vimeo::before { content: "\\f66a"; }
.bi-activity::before { content: "\\f66b"; }
.bi-easel2-fill::before { content: "\\f66c"; }
.bi-easel2::before { content: "\\f66d"; }
.bi-easel3-fill::before { content: "\\f66e"; }
.bi-easel3::before { content: "\\f66f"; }
.bi-fan::before { content: "\\f670"; }
.bi-fingerprint::before { content: "\\f671"; }
.bi-graph-down-arrow::before { content: "\\f672"; }
.bi-graph-up-arrow::before { content: "\\f673"; }
.bi-hypnotize::before { content: "\\f674"; }
.bi-magic::before { content: "\\f675"; }
.bi-person-rolodex::before { content: "\\f676"; }
.bi-person-video::before { content: "\\f677"; }
.bi-person-video2::before { content: "\\f678"; }
.bi-person-video3::before { content: "\\f679"; }
.bi-person-workspace::before { content: "\\f67a"; }
.bi-radioactive::before { content: "\\f67b"; }
.bi-webcam-fill::before { content: "\\f67c"; }
.bi-webcam::before { content: "\\f67d"; }
.bi-yin-yang::before { content: "\\f67e"; }
.bi-bandaid-fill::before { content: "\\f680"; }
.bi-bandaid::before { content: "\\f681"; }
.bi-bluetooth::before { content: "\\f682"; }
.bi-body-text::before { content: "\\f683"; }
.bi-boombox::before { content: "\\f684"; }
.bi-boxes::before { content: "\\f685"; }
.bi-dpad-fill::before { content: "\\f686"; }
.bi-dpad::before { content: "\\f687"; }
.bi-ear-fill::before { content: "\\f688"; }
.bi-ear::before { content: "\\f689"; }
.bi-envelope-check-fill::before { content: "\\f68b"; }
.bi-envelope-check::before { content: "\\f68c"; }
.bi-envelope-dash-fill::before { content: "\\f68e"; }
.bi-envelope-dash::before { content: "\\f68f"; }
.bi-envelope-exclamation-fill::before { content: "\\f691"; }
.bi-envelope-exclamation::before { content: "\\f692"; }
.bi-envelope-plus-fill::before { content: "\\f693"; }
.bi-envelope-plus::before { content: "\\f694"; }
.bi-envelope-slash-fill::before { content: "\\f696"; }
.bi-envelope-slash::before { content: "\\f697"; }
.bi-envelope-x-fill::before { content: "\\f699"; }
.bi-envelope-x::before { content: "\\f69a"; }
.bi-explicit-fill::before { content: "\\f69b"; }
.bi-explicit::before { content: "\\f69c"; }
.bi-git::before { content: "\\f69d"; }
.bi-infinity::before { content: "\\f69e"; }
.bi-list-columns-reverse::before { content: "\\f69f"; }
.bi-list-columns::before { content: "\\f6a0"; }
.bi-meta::before { content: "\\f6a1"; }
.bi-nintendo-switch::before { content: "\\f6a4"; }
.bi-pc-display-horizontal::before { content: "\\f6a5"; }
.bi-pc-display::before { content: "\\f6a6"; }
.bi-pc-horizontal::before { content: "\\f6a7"; }
.bi-pc::before { content: "\\f6a8"; }
.bi-playstation::before { content: "\\f6a9"; }
.bi-plus-slash-minus::before { content: "\\f6aa"; }
.bi-projector-fill::before { content: "\\f6ab"; }
.bi-projector::before { content: "\\f6ac"; }
.bi-qr-code-scan::before { content: "\\f6ad"; }
.bi-qr-code::before { content: "\\f6ae"; }
.bi-quora::before { content: "\\f6af"; }
.bi-quote::before { content: "\\f6b0"; }
.bi-robot::before { content: "\\f6b1"; }
.bi-send-check-fill::before { content: "\\f6b2"; }
.bi-send-check::before { content: "\\f6b3"; }
.bi-send-dash-fill::before { content: "\\f6b4"; }
.bi-send-dash::before { content: "\\f6b5"; }
.bi-send-exclamation-fill::before { content: "\\f6b7"; }
.bi-send-exclamation::before { content: "\\f6b8"; }
.bi-send-fill::before { content: "\\f6b9"; }
.bi-send-plus-fill::before { content: "\\f6ba"; }
.bi-send-plus::before { content: "\\f6bb"; }
.bi-send-slash-fill::before { content: "\\f6bc"; }
.bi-send-slash::before { content: "\\f6bd"; }
.bi-send-x-fill::before { content: "\\f6be"; }
.bi-send-x::before { content: "\\f6bf"; }
.bi-send::before { content: "\\f6c0"; }
.bi-steam::before { content: "\\f6c1"; }
.bi-terminal-dash::before { content: "\\f6c3"; }
.bi-terminal-plus::before { content: "\\f6c4"; }
.bi-terminal-split::before { content: "\\f6c5"; }
.bi-ticket-detailed-fill::before { content: "\\f6c6"; }
.bi-ticket-detailed::before { content: "\\f6c7"; }
.bi-ticket-fill::before { content: "\\f6c8"; }
.bi-ticket-perforated-fill::before { content: "\\f6c9"; }
.bi-ticket-perforated::before { content: "\\f6ca"; }
.bi-ticket::before { content: "\\f6cb"; }
.bi-tiktok::before { content: "\\f6cc"; }
.bi-window-dash::before { content: "\\f6cd"; }
.bi-window-desktop::before { content: "\\f6ce"; }
.bi-window-fullscreen::before { content: "\\f6cf"; }
.bi-window-plus::before { content: "\\f6d0"; }
.bi-window-split::before { content: "\\f6d1"; }
.bi-window-stack::before { content: "\\f6d2"; }
.bi-window-x::before { content: "\\f6d3"; }
.bi-xbox::before { content: "\\f6d4"; }
.bi-ethernet::before { content: "\\f6d5"; }
.bi-hdmi-fill::before { content: "\\f6d6"; }
.bi-hdmi::before { content: "\\f6d7"; }
.bi-usb-c-fill::before { content: "\\f6d8"; }
.bi-usb-c::before { content: "\\f6d9"; }
.bi-usb-fill::before { content: "\\f6da"; }
.bi-usb-plug-fill::before { content: "\\f6db"; }
.bi-usb-plug::before { content: "\\f6dc"; }
.bi-usb-symbol::before { content: "\\f6dd"; }
.bi-usb::before { content: "\\f6de"; }
.bi-boombox-fill::before { content: "\\f6df"; }
.bi-displayport::before { content: "\\f6e1"; }
.bi-gpu-card::before { content: "\\f6e2"; }
.bi-memory::before { content: "\\f6e3"; }
.bi-modem-fill::before { content: "\\f6e4"; }
.bi-modem::before { content: "\\f6e5"; }
.bi-motherboard-fill::before { content: "\\f6e6"; }
.bi-motherboard::before { content: "\\f6e7"; }
.bi-optical-audio-fill::before { content: "\\f6e8"; }
.bi-optical-audio::before { content: "\\f6e9"; }
.bi-pci-card::before { content: "\\f6ea"; }
.bi-router-fill::before { content: "\\f6eb"; }
.bi-router::before { content: "\\f6ec"; }
.bi-thunderbolt-fill::before { content: "\\f6ef"; }
.bi-thunderbolt::before { content: "\\f6f0"; }
.bi-usb-drive-fill::before { content: "\\f6f1"; }
.bi-usb-drive::before { content: "\\f6f2"; }
.bi-usb-micro-fill::before { content: "\\f6f3"; }
.bi-usb-micro::before { content: "\\f6f4"; }
.bi-usb-mini-fill::before { content: "\\f6f5"; }
.bi-usb-mini::before { content: "\\f6f6"; }
.bi-cloud-haze2::before { content: "\\f6f7"; }
.bi-device-hdd-fill::before { content: "\\f6f8"; }
.bi-device-hdd::before { content: "\\f6f9"; }
.bi-device-ssd-fill::before { content: "\\f6fa"; }
.bi-device-ssd::before { content: "\\f6fb"; }
.bi-displayport-fill::before { content: "\\f6fc"; }
.bi-mortarboard-fill::before { content: "\\f6fd"; }
.bi-mortarboard::before { content: "\\f6fe"; }
.bi-terminal-x::before { content: "\\f6ff"; }
.bi-arrow-through-heart-fill::before { content: "\\f700"; }
.bi-arrow-through-heart::before { content: "\\f701"; }
.bi-badge-sd-fill::before { content: "\\f702"; }
.bi-badge-sd::before { content: "\\f703"; }
.bi-bag-heart-fill::before { content: "\\f704"; }
.bi-bag-heart::before { content: "\\f705"; }
.bi-balloon-fill::before { content: "\\f706"; }
.bi-balloon-heart-fill::before { content: "\\f707"; }
.bi-balloon-heart::before { content: "\\f708"; }
.bi-balloon::before { content: "\\f709"; }
.bi-box2-fill::before { content: "\\f70a"; }
.bi-box2-heart-fill::before { content: "\\f70b"; }
.bi-box2-heart::before { content: "\\f70c"; }
.bi-box2::before { content: "\\f70d"; }
.bi-braces-asterisk::before { content: "\\f70e"; }
.bi-calendar-heart-fill::before { content: "\\f70f"; }
.bi-calendar-heart::before { content: "\\f710"; }
.bi-calendar2-heart-fill::before { content: "\\f711"; }
.bi-calendar2-heart::before { content: "\\f712"; }
.bi-chat-heart-fill::before { content: "\\f713"; }
.bi-chat-heart::before { content: "\\f714"; }
.bi-chat-left-heart-fill::before { content: "\\f715"; }
.bi-chat-left-heart::before { content: "\\f716"; }
.bi-chat-right-heart-fill::before { content: "\\f717"; }
.bi-chat-right-heart::before { content: "\\f718"; }
.bi-chat-square-heart-fill::before { content: "\\f719"; }
.bi-chat-square-heart::before { content: "\\f71a"; }
.bi-clipboard-check-fill::before { content: "\\f71b"; }
.bi-clipboard-data-fill::before { content: "\\f71c"; }
.bi-clipboard-fill::before { content: "\\f71d"; }
.bi-clipboard-heart-fill::before { content: "\\f71e"; }
.bi-clipboard-heart::before { content: "\\f71f"; }
.bi-clipboard-minus-fill::before { content: "\\f720"; }
.bi-clipboard-plus-fill::before { content: "\\f721"; }
.bi-clipboard-pulse::before { content: "\\f722"; }
.bi-clipboard-x-fill::before { content: "\\f723"; }
.bi-clipboard2-check-fill::before { content: "\\f724"; }
.bi-clipboard2-check::before { content: "\\f725"; }
.bi-clipboard2-data-fill::before { content: "\\f726"; }
.bi-clipboard2-data::before { content: "\\f727"; }
.bi-clipboard2-fill::before { content: "\\f728"; }
.bi-clipboard2-heart-fill::before { content: "\\f729"; }
.bi-clipboard2-heart::before { content: "\\f72a"; }
.bi-clipboard2-minus-fill::before { content: "\\f72b"; }
.bi-clipboard2-minus::before { content: "\\f72c"; }
.bi-clipboard2-plus-fill::before { content: "\\f72d"; }
.bi-clipboard2-plus::before { content: "\\f72e"; }
.bi-clipboard2-pulse-fill::before { content: "\\f72f"; }
.bi-clipboard2-pulse::before { content: "\\f730"; }
.bi-clipboard2-x-fill::before { content: "\\f731"; }
.bi-clipboard2-x::before { content: "\\f732"; }
.bi-clipboard2::before { content: "\\f733"; }
.bi-emoji-kiss-fill::before { content: "\\f734"; }
.bi-emoji-kiss::before { content: "\\f735"; }
.bi-envelope-heart-fill::before { content: "\\f736"; }
.bi-envelope-heart::before { content: "\\f737"; }
.bi-envelope-open-heart-fill::before { content: "\\f738"; }
.bi-envelope-open-heart::before { content: "\\f739"; }
.bi-envelope-paper-fill::before { content: "\\f73a"; }
.bi-envelope-paper-heart-fill::before { content: "\\f73b"; }
.bi-envelope-paper-heart::before { content: "\\f73c"; }
.bi-envelope-paper::before { content: "\\f73d"; }
.bi-filetype-aac::before { content: "\\f73e"; }
.bi-filetype-ai::before { content: "\\f73f"; }
.bi-filetype-bmp::before { content: "\\f740"; }
.bi-filetype-cs::before { content: "\\f741"; }
.bi-filetype-css::before { content: "\\f742"; }
.bi-filetype-csv::before { content: "\\f743"; }
.bi-filetype-doc::before { content: "\\f744"; }
.bi-filetype-docx::before { content: "\\f745"; }
.bi-filetype-exe::before { content: "\\f746"; }
.bi-filetype-gif::before { content: "\\f747"; }
.bi-filetype-heic::before { content: "\\f748"; }
.bi-filetype-html::before { content: "\\f749"; }
.bi-filetype-java::before { content: "\\f74a"; }
.bi-filetype-jpg::before { content: "\\f74b"; }
.bi-filetype-js::before { content: "\\f74c"; }
.bi-filetype-jsx::before { content: "\\f74d"; }
.bi-filetype-key::before { content: "\\f74e"; }
.bi-filetype-m4p::before { content: "\\f74f"; }
.bi-filetype-md::before { content: "\\f750"; }
.bi-filetype-mdx::before { content: "\\f751"; }
.bi-filetype-mov::before { content: "\\f752"; }
.bi-filetype-mp3::before { content: "\\f753"; }
.bi-filetype-mp4::before { content: "\\f754"; }
.bi-filetype-otf::before { content: "\\f755"; }
.bi-filetype-pdf::before { content: "\\f756"; }
.bi-filetype-php::before { content: "\\f757"; }
.bi-filetype-png::before { content: "\\f758"; }
.bi-filetype-ppt::before { content: "\\f75a"; }
.bi-filetype-psd::before { content: "\\f75b"; }
.bi-filetype-py::before { content: "\\f75c"; }
.bi-filetype-raw::before { content: "\\f75d"; }
.bi-filetype-rb::before { content: "\\f75e"; }
.bi-filetype-sass::before { content: "\\f75f"; }
.bi-filetype-scss::before { content: "\\f760"; }
.bi-filetype-sh::before { content: "\\f761"; }
.bi-filetype-svg::before { content: "\\f762"; }
.bi-filetype-tiff::before { content: "\\f763"; }
.bi-filetype-tsx::before { content: "\\f764"; }
.bi-filetype-ttf::before { content: "\\f765"; }
.bi-filetype-txt::before { content: "\\f766"; }
.bi-filetype-wav::before { content: "\\f767"; }
.bi-filetype-woff::before { content: "\\f768"; }
.bi-filetype-xls::before { content: "\\f76a"; }
.bi-filetype-xml::before { content: "\\f76b"; }
.bi-filetype-yml::before { content: "\\f76c"; }
.bi-heart-arrow::before { content: "\\f76d"; }
.bi-heart-pulse-fill::before { content: "\\f76e"; }
.bi-heart-pulse::before { content: "\\f76f"; }
.bi-heartbreak-fill::before { content: "\\f770"; }
.bi-heartbreak::before { content: "\\f771"; }
.bi-hearts::before { content: "\\f772"; }
.bi-hospital-fill::before { content: "\\f773"; }
.bi-hospital::before { content: "\\f774"; }
.bi-house-heart-fill::before { content: "\\f775"; }
.bi-house-heart::before { content: "\\f776"; }
.bi-incognito::before { content: "\\f777"; }
.bi-magnet-fill::before { content: "\\f778"; }
.bi-magnet::before { content: "\\f779"; }
.bi-person-heart::before { content: "\\f77a"; }
.bi-person-hearts::before { content: "\\f77b"; }
.bi-phone-flip::before { content: "\\f77c"; }
.bi-plugin::before { content: "\\f77d"; }
.bi-postage-fill::before { content: "\\f77e"; }
.bi-postage-heart-fill::before { content: "\\f77f"; }
.bi-postage-heart::before { content: "\\f780"; }
.bi-postage::before { content: "\\f781"; }
.bi-postcard-fill::before { content: "\\f782"; }
.bi-postcard-heart-fill::before { content: "\\f783"; }
.bi-postcard-heart::before { content: "\\f784"; }
.bi-postcard::before { content: "\\f785"; }
.bi-search-heart-fill::before { content: "\\f786"; }
.bi-search-heart::before { content: "\\f787"; }
.bi-sliders2-vertical::before { content: "\\f788"; }
.bi-sliders2::before { content: "\\f789"; }
.bi-trash3-fill::before { content: "\\f78a"; }
.bi-trash3::before { content: "\\f78b"; }
.bi-valentine::before { content: "\\f78c"; }
.bi-valentine2::before { content: "\\f78d"; }
.bi-wrench-adjustable-circle-fill::before { content: "\\f78e"; }
.bi-wrench-adjustable-circle::before { content: "\\f78f"; }
.bi-wrench-adjustable::before { content: "\\f790"; }
.bi-filetype-json::before { content: "\\f791"; }
.bi-filetype-pptx::before { content: "\\f792"; }
.bi-filetype-xlsx::before { content: "\\f793"; }
.bi-1-circle-fill::before { content: "\\f796"; }
.bi-1-circle::before { content: "\\f797"; }
.bi-1-square-fill::before { content: "\\f798"; }
.bi-1-square::before { content: "\\f799"; }
.bi-2-circle-fill::before { content: "\\f79c"; }
.bi-2-circle::before { content: "\\f79d"; }
.bi-2-square-fill::before { content: "\\f79e"; }
.bi-2-square::before { content: "\\f79f"; }
.bi-3-circle-fill::before { content: "\\f7a2"; }
.bi-3-circle::before { content: "\\f7a3"; }
.bi-3-square-fill::before { content: "\\f7a4"; }
.bi-3-square::before { content: "\\f7a5"; }
.bi-4-circle-fill::before { content: "\\f7a8"; }
.bi-4-circle::before { content: "\\f7a9"; }
.bi-4-square-fill::before { content: "\\f7aa"; }
.bi-4-square::before { content: "\\f7ab"; }
.bi-5-circle-fill::before { content: "\\f7ae"; }
.bi-5-circle::before { content: "\\f7af"; }
.bi-5-square-fill::before { content: "\\f7b0"; }
.bi-5-square::before { content: "\\f7b1"; }
.bi-6-circle-fill::before { content: "\\f7b4"; }
.bi-6-circle::before { content: "\\f7b5"; }
.bi-6-square-fill::before { content: "\\f7b6"; }
.bi-6-square::before { content: "\\f7b7"; }
.bi-7-circle-fill::before { content: "\\f7ba"; }
.bi-7-circle::before { content: "\\f7bb"; }
.bi-7-square-fill::before { content: "\\f7bc"; }
.bi-7-square::before { content: "\\f7bd"; }
.bi-8-circle-fill::before { content: "\\f7c0"; }
.bi-8-circle::before { content: "\\f7c1"; }
.bi-8-square-fill::before { content: "\\f7c2"; }
.bi-8-square::before { content: "\\f7c3"; }
.bi-9-circle-fill::before { content: "\\f7c6"; }
.bi-9-circle::before { content: "\\f7c7"; }
.bi-9-square-fill::before { content: "\\f7c8"; }
.bi-9-square::before { content: "\\f7c9"; }
.bi-airplane-engines-fill::before { content: "\\f7ca"; }
.bi-airplane-engines::before { content: "\\f7cb"; }
.bi-airplane-fill::before { content: "\\f7cc"; }
.bi-airplane::before { content: "\\f7cd"; }
.bi-alexa::before { content: "\\f7ce"; }
.bi-alipay::before { content: "\\f7cf"; }
.bi-android::before { content: "\\f7d0"; }
.bi-android2::before { content: "\\f7d1"; }
.bi-box-fill::before { content: "\\f7d2"; }
.bi-box-seam-fill::before { content: "\\f7d3"; }
.bi-browser-chrome::before { content: "\\f7d4"; }
.bi-browser-edge::before { content: "\\f7d5"; }
.bi-browser-firefox::before { content: "\\f7d6"; }
.bi-browser-safari::before { content: "\\f7d7"; }
.bi-c-circle-fill::before { content: "\\f7da"; }
.bi-c-circle::before { content: "\\f7db"; }
.bi-c-square-fill::before { content: "\\f7dc"; }
.bi-c-square::before { content: "\\f7dd"; }
.bi-capsule-pill::before { content: "\\f7de"; }
.bi-capsule::before { content: "\\f7df"; }
.bi-car-front-fill::before { content: "\\f7e0"; }
.bi-car-front::before { content: "\\f7e1"; }
.bi-cassette-fill::before { content: "\\f7e2"; }
.bi-cassette::before { content: "\\f7e3"; }
.bi-cc-circle-fill::before { content: "\\f7e6"; }
.bi-cc-circle::before { content: "\\f7e7"; }
.bi-cc-square-fill::before { content: "\\f7e8"; }
.bi-cc-square::before { content: "\\f7e9"; }
.bi-cup-hot-fill::before { content: "\\f7ea"; }
.bi-cup-hot::before { content: "\\f7eb"; }
.bi-currency-rupee::before { content: "\\f7ec"; }
.bi-dropbox::before { content: "\\f7ed"; }
.bi-escape::before { content: "\\f7ee"; }
.bi-fast-forward-btn-fill::before { content: "\\f7ef"; }
.bi-fast-forward-btn::before { content: "\\f7f0"; }
.bi-fast-forward-circle-fill::before { content: "\\f7f1"; }
.bi-fast-forward-circle::before { content: "\\f7f2"; }
.bi-fast-forward-fill::before { content: "\\f7f3"; }
.bi-fast-forward::before { content: "\\f7f4"; }
.bi-filetype-sql::before { content: "\\f7f5"; }
.bi-fire::before { content: "\\f7f6"; }
.bi-google-play::before { content: "\\f7f7"; }
.bi-h-circle-fill::before { content: "\\f7fa"; }
.bi-h-circle::before { content: "\\f7fb"; }
.bi-h-square-fill::before { content: "\\f7fc"; }
.bi-h-square::before { content: "\\f7fd"; }
.bi-indent::before { content: "\\f7fe"; }
.bi-lungs-fill::before { content: "\\f7ff"; }
.bi-lungs::before { content: "\\f800"; }
.bi-microsoft-teams::before { content: "\\f801"; }
.bi-p-circle-fill::before { content: "\\f804"; }
.bi-p-circle::before { content: "\\f805"; }
.bi-p-square-fill::before { content: "\\f806"; }
.bi-p-square::before { content: "\\f807"; }
.bi-pass-fill::before { content: "\\f808"; }
.bi-pass::before { content: "\\f809"; }
.bi-prescription::before { content: "\\f80a"; }
.bi-prescription2::before { content: "\\f80b"; }
.bi-r-circle-fill::before { content: "\\f80e"; }
.bi-r-circle::before { content: "\\f80f"; }
.bi-r-square-fill::before { content: "\\f810"; }
.bi-r-square::before { content: "\\f811"; }
.bi-repeat-1::before { content: "\\f812"; }
.bi-repeat::before { content: "\\f813"; }
.bi-rewind-btn-fill::before { content: "\\f814"; }
.bi-rewind-btn::before { content: "\\f815"; }
.bi-rewind-circle-fill::before { content: "\\f816"; }
.bi-rewind-circle::before { content: "\\f817"; }
.bi-rewind-fill::before { content: "\\f818"; }
.bi-rewind::before { content: "\\f819"; }
.bi-train-freight-front-fill::before { content: "\\f81a"; }
.bi-train-freight-front::before { content: "\\f81b"; }
.bi-train-front-fill::before { content: "\\f81c"; }
.bi-train-front::before { content: "\\f81d"; }
.bi-train-lightrail-front-fill::before { content: "\\f81e"; }
.bi-train-lightrail-front::before { content: "\\f81f"; }
.bi-truck-front-fill::before { content: "\\f820"; }
.bi-truck-front::before { content: "\\f821"; }
.bi-ubuntu::before { content: "\\f822"; }
.bi-unindent::before { content: "\\f823"; }
.bi-unity::before { content: "\\f824"; }
.bi-universal-access-circle::before { content: "\\f825"; }
.bi-universal-access::before { content: "\\f826"; }
.bi-virus::before { content: "\\f827"; }
.bi-virus2::before { content: "\\f828"; }
.bi-wechat::before { content: "\\f829"; }
.bi-yelp::before { content: "\\f82a"; }
.bi-sign-stop-fill::before { content: "\\f82b"; }
.bi-sign-stop-lights-fill::before { content: "\\f82c"; }
.bi-sign-stop-lights::before { content: "\\f82d"; }
.bi-sign-stop::before { content: "\\f82e"; }
.bi-sign-turn-left-fill::before { content: "\\f82f"; }
.bi-sign-turn-left::before { content: "\\f830"; }
.bi-sign-turn-right-fill::before { content: "\\f831"; }
.bi-sign-turn-right::before { content: "\\f832"; }
.bi-sign-turn-slight-left-fill::before { content: "\\f833"; }
.bi-sign-turn-slight-left::before { content: "\\f834"; }
.bi-sign-turn-slight-right-fill::before { content: "\\f835"; }
.bi-sign-turn-slight-right::before { content: "\\f836"; }
.bi-sign-yield-fill::before { content: "\\f837"; }
.bi-sign-yield::before { content: "\\f838"; }
.bi-ev-station-fill::before { content: "\\f839"; }
.bi-ev-station::before { content: "\\f83a"; }
.bi-fuel-pump-diesel-fill::before { content: "\\f83b"; }
.bi-fuel-pump-diesel::before { content: "\\f83c"; }
.bi-fuel-pump-fill::before { content: "\\f83d"; }
.bi-fuel-pump::before { content: "\\f83e"; }
.bi-0-circle-fill::before { content: "\\f83f"; }
.bi-0-circle::before { content: "\\f840"; }
.bi-0-square-fill::before { content: "\\f841"; }
.bi-0-square::before { content: "\\f842"; }
.bi-rocket-fill::before { content: "\\f843"; }
.bi-rocket-takeoff-fill::before { content: "\\f844"; }
.bi-rocket-takeoff::before { content: "\\f845"; }
.bi-rocket::before { content: "\\f846"; }
.bi-stripe::before { content: "\\f847"; }
.bi-subscript::before { content: "\\f848"; }
.bi-superscript::before { content: "\\f849"; }
.bi-trello::before { content: "\\f84a"; }
.bi-envelope-at-fill::before { content: "\\f84b"; }
.bi-envelope-at::before { content: "\\f84c"; }
.bi-regex::before { content: "\\f84d"; }
.bi-text-wrap::before { content: "\\f84e"; }
.bi-sign-dead-end-fill::before { content: "\\f84f"; }
.bi-sign-dead-end::before { content: "\\f850"; }
.bi-sign-do-not-enter-fill::before { content: "\\f851"; }
.bi-sign-do-not-enter::before { content: "\\f852"; }
.bi-sign-intersection-fill::before { content: "\\f853"; }
.bi-sign-intersection-side-fill::before { content: "\\f854"; }
.bi-sign-intersection-side::before { content: "\\f855"; }
.bi-sign-intersection-t-fill::before { content: "\\f856"; }
.bi-sign-intersection-t::before { content: "\\f857"; }
.bi-sign-intersection-y-fill::before { content: "\\f858"; }
.bi-sign-intersection-y::before { content: "\\f859"; }
.bi-sign-intersection::before { content: "\\f85a"; }
.bi-sign-merge-left-fill::before { content: "\\f85b"; }
.bi-sign-merge-left::before { content: "\\f85c"; }
.bi-sign-merge-right-fill::before { content: "\\f85d"; }
.bi-sign-merge-right::before { content: "\\f85e"; }
.bi-sign-no-left-turn-fill::before { content: "\\f85f"; }
.bi-sign-no-left-turn::before { content: "\\f860"; }
.bi-sign-no-parking-fill::before { content: "\\f861"; }
.bi-sign-no-parking::before { content: "\\f862"; }
.bi-sign-no-right-turn-fill::before { content: "\\f863"; }
.bi-sign-no-right-turn::before { content: "\\f864"; }
.bi-sign-railroad-fill::before { content: "\\f865"; }
.bi-sign-railroad::before { content: "\\f866"; }
.bi-building-add::before { content: "\\f867"; }
.bi-building-check::before { content: "\\f868"; }
.bi-building-dash::before { content: "\\f869"; }
.bi-building-down::before { content: "\\f86a"; }
.bi-building-exclamation::before { content: "\\f86b"; }
.bi-building-fill-add::before { content: "\\f86c"; }
.bi-building-fill-check::before { content: "\\f86d"; }
.bi-building-fill-dash::before { content: "\\f86e"; }
.bi-building-fill-down::before { content: "\\f86f"; }
.bi-building-fill-exclamation::before { content: "\\f870"; }
.bi-building-fill-gear::before { content: "\\f871"; }
.bi-building-fill-lock::before { content: "\\f872"; }
.bi-building-fill-slash::before { content: "\\f873"; }
.bi-building-fill-up::before { content: "\\f874"; }
.bi-building-fill-x::before { content: "\\f875"; }
.bi-building-fill::before { content: "\\f876"; }
.bi-building-gear::before { content: "\\f877"; }
.bi-building-lock::before { content: "\\f878"; }
.bi-building-slash::before { content: "\\f879"; }
.bi-building-up::before { content: "\\f87a"; }
.bi-building-x::before { content: "\\f87b"; }
.bi-buildings-fill::before { content: "\\f87c"; }
.bi-buildings::before { content: "\\f87d"; }
.bi-bus-front-fill::before { content: "\\f87e"; }
.bi-bus-front::before { content: "\\f87f"; }
.bi-ev-front-fill::before { content: "\\f880"; }
.bi-ev-front::before { content: "\\f881"; }
.bi-globe-americas::before { content: "\\f882"; }
.bi-globe-asia-australia::before { content: "\\f883"; }
.bi-globe-central-south-asia::before { content: "\\f884"; }
.bi-globe-europe-africa::before { content: "\\f885"; }
.bi-house-add-fill::before { content: "\\f886"; }
.bi-house-add::before { content: "\\f887"; }
.bi-house-check-fill::before { content: "\\f888"; }
.bi-house-check::before { content: "\\f889"; }
.bi-house-dash-fill::before { content: "\\f88a"; }
.bi-house-dash::before { content: "\\f88b"; }
.bi-house-down-fill::before { content: "\\f88c"; }
.bi-house-down::before { content: "\\f88d"; }
.bi-house-exclamation-fill::before { content: "\\f88e"; }
.bi-house-exclamation::before { content: "\\f88f"; }
.bi-house-gear-fill::before { content: "\\f890"; }
.bi-house-gear::before { content: "\\f891"; }
.bi-house-lock-fill::before { content: "\\f892"; }
.bi-house-lock::before { content: "\\f893"; }
.bi-house-slash-fill::before { content: "\\f894"; }
.bi-house-slash::before { content: "\\f895"; }
.bi-house-up-fill::before { content: "\\f896"; }
.bi-house-up::before { content: "\\f897"; }
.bi-house-x-fill::before { content: "\\f898"; }
.bi-house-x::before { content: "\\f899"; }
.bi-person-add::before { content: "\\f89a"; }
.bi-person-down::before { content: "\\f89b"; }
.bi-person-exclamation::before { content: "\\f89c"; }
.bi-person-fill-add::before { content: "\\f89d"; }
.bi-person-fill-check::before { content: "\\f89e"; }
.bi-person-fill-dash::before { content: "\\f89f"; }
.bi-person-fill-down::before { content: "\\f8a0"; }
.bi-person-fill-exclamation::before { content: "\\f8a1"; }
.bi-person-fill-gear::before { content: "\\f8a2"; }
.bi-person-fill-lock::before { content: "\\f8a3"; }
.bi-person-fill-slash::before { content: "\\f8a4"; }
.bi-person-fill-up::before { content: "\\f8a5"; }
.bi-person-fill-x::before { content: "\\f8a6"; }
.bi-person-gear::before { content: "\\f8a7"; }
.bi-person-lock::before { content: "\\f8a8"; }
.bi-person-slash::before { content: "\\f8a9"; }
.bi-person-up::before { content: "\\f8aa"; }
.bi-scooter::before { content: "\\f8ab"; }
.bi-taxi-front-fill::before { content: "\\f8ac"; }
.bi-taxi-front::before { content: "\\f8ad"; }
.bi-amd::before { content: "\\f8ae"; }
.bi-database-add::before { content: "\\f8af"; }
.bi-database-check::before { content: "\\f8b0"; }
.bi-database-dash::before { content: "\\f8b1"; }
.bi-database-down::before { content: "\\f8b2"; }
.bi-database-exclamation::before { content: "\\f8b3"; }
.bi-database-fill-add::before { content: "\\f8b4"; }
.bi-database-fill-check::before { content: "\\f8b5"; }
.bi-database-fill-dash::before { content: "\\f8b6"; }
.bi-database-fill-down::before { content: "\\f8b7"; }
.bi-database-fill-exclamation::before { content: "\\f8b8"; }
.bi-database-fill-gear::before { content: "\\f8b9"; }
.bi-database-fill-lock::before { content: "\\f8ba"; }
.bi-database-fill-slash::before { content: "\\f8bb"; }
.bi-database-fill-up::before { content: "\\f8bc"; }
.bi-database-fill-x::before { content: "\\f8bd"; }
.bi-database-fill::before { content: "\\f8be"; }
.bi-database-gear::before { content: "\\f8bf"; }
.bi-database-lock::before { content: "\\f8c0"; }
.bi-database-slash::before { content: "\\f8c1"; }
.bi-database-up::before { content: "\\f8c2"; }
.bi-database-x::before { content: "\\f8c3"; }
.bi-database::before { content: "\\f8c4"; }
.bi-houses-fill::before { content: "\\f8c5"; }
.bi-houses::before { content: "\\f8c6"; }
.bi-nvidia::before { content: "\\f8c7"; }
.bi-person-vcard-fill::before { content: "\\f8c8"; }
.bi-person-vcard::before { content: "\\f8c9"; }
.bi-sina-weibo::before { content: "\\f8ca"; }
.bi-tencent-qq::before { content: "\\f8cb"; }
.bi-wikipedia::before { content: "\\f8cc"; }
.bi-alphabet-uppercase::before { content: "\\f2a5"; }
.bi-alphabet::before { content: "\\f68a"; }
.bi-amazon::before { content: "\\f68d"; }
.bi-arrows-collapse-vertical::before { content: "\\f690"; }
.bi-arrows-expand-vertical::before { content: "\\f695"; }
.bi-arrows-vertical::before { content: "\\f698"; }
.bi-arrows::before { content: "\\f6a2"; }
.bi-ban-fill::before { content: "\\f6a3"; }
.bi-ban::before { content: "\\f6b6"; }
.bi-bing::before { content: "\\f6c2"; }
.bi-cake::before { content: "\\f6e0"; }
.bi-cake2::before { content: "\\f6ed"; }
.bi-cookie::before { content: "\\f6ee"; }
.bi-copy::before { content: "\\f759"; }
.bi-crosshair::before { content: "\\f769"; }
.bi-crosshair2::before { content: "\\f794"; }
.bi-emoji-astonished-fill::before { content: "\\f795"; }
.bi-emoji-astonished::before { content: "\\f79a"; }
.bi-emoji-grimace-fill::before { content: "\\f79b"; }
.bi-emoji-grimace::before { content: "\\f7a0"; }
.bi-emoji-grin-fill::before { content: "\\f7a1"; }
.bi-emoji-grin::before { content: "\\f7a6"; }
.bi-emoji-surprise-fill::before { content: "\\f7a7"; }
.bi-emoji-surprise::before { content: "\\f7ac"; }
.bi-emoji-tear-fill::before { content: "\\f7ad"; }
.bi-emoji-tear::before { content: "\\f7b2"; }
.bi-envelope-arrow-down-fill::before { content: "\\f7b3"; }
.bi-envelope-arrow-down::before { content: "\\f7b8"; }
.bi-envelope-arrow-up-fill::before { content: "\\f7b9"; }
.bi-envelope-arrow-up::before { content: "\\f7be"; }
.bi-feather::before { content: "\\f7bf"; }
.bi-feather2::before { content: "\\f7c4"; }
.bi-floppy-fill::before { content: "\\f7c5"; }
.bi-floppy::before { content: "\\f7d8"; }
.bi-floppy2-fill::before { content: "\\f7d9"; }
.bi-floppy2::before { content: "\\f7e4"; }
.bi-gitlab::before { content: "\\f7e5"; }
.bi-highlighter::before { content: "\\f7f8"; }
.bi-marker-tip::before { content: "\\f802"; }
.bi-nvme-fill::before { content: "\\f803"; }
.bi-nvme::before { content: "\\f80c"; }
.bi-opencollective::before { content: "\\f80d"; }
.bi-pci-card-network::before { content: "\\f8cd"; }
.bi-pci-card-sound::before { content: "\\f8ce"; }
.bi-radar::before { content: "\\f8cf"; }
.bi-send-arrow-down-fill::before { content: "\\f8d0"; }
.bi-send-arrow-down::before { content: "\\f8d1"; }
.bi-send-arrow-up-fill::before { content: "\\f8d2"; }
.bi-send-arrow-up::before { content: "\\f8d3"; }
.bi-sim-slash-fill::before { content: "\\f8d4"; }
.bi-sim-slash::before { content: "\\f8d5"; }
.bi-sourceforge::before { content: "\\f8d6"; }
.bi-substack::before { content: "\\f8d7"; }
.bi-threads-fill::before { content: "\\f8d8"; }
.bi-threads::before { content: "\\f8d9"; }
.bi-transparency::before { content: "\\f8da"; }
.bi-twitter-x::before { content: "\\f8db"; }
.bi-type-h4::before { content: "\\f8dc"; }
.bi-type-h5::before { content: "\\f8dd"; }
.bi-type-h6::before { content: "\\f8de"; }
.bi-backpack-fill::before { content: "\\f8df"; }
.bi-backpack::before { content: "\\f8e0"; }
.bi-backpack2-fill::before { content: "\\f8e1"; }
.bi-backpack2::before { content: "\\f8e2"; }
.bi-backpack3-fill::before { content: "\\f8e3"; }
.bi-backpack3::before { content: "\\f8e4"; }
.bi-backpack4-fill::before { content: "\\f8e5"; }
.bi-backpack4::before { content: "\\f8e6"; }
.bi-brilliance::before { content: "\\f8e7"; }
.bi-cake-fill::before { content: "\\f8e8"; }
.bi-cake2-fill::before { content: "\\f8e9"; }
.bi-duffle-fill::before { content: "\\f8ea"; }
.bi-duffle::before { content: "\\f8eb"; }
.bi-exposure::before { content: "\\f8ec"; }
.bi-gender-neuter::before { content: "\\f8ed"; }
.bi-highlights::before { content: "\\f8ee"; }
.bi-luggage-fill::before { content: "\\f8ef"; }
.bi-luggage::before { content: "\\f8f0"; }
.bi-mailbox-flag::before { content: "\\f8f1"; }
.bi-mailbox2-flag::before { content: "\\f8f2"; }
.bi-noise-reduction::before { content: "\\f8f3"; }
.bi-passport-fill::before { content: "\\f8f4"; }
.bi-passport::before { content: "\\f8f5"; }
.bi-person-arms-up::before { content: "\\f8f6"; }
.bi-person-raised-hand::before { content: "\\f8f7"; }
.bi-person-standing-dress::before { content: "\\f8f8"; }
.bi-person-standing::before { content: "\\f8f9"; }
.bi-person-walking::before { content: "\\f8fa"; }
.bi-person-wheelchair::before { content: "\\f8fb"; }
.bi-shadows::before { content: "\\f8fc"; }
.bi-suitcase-fill::before { content: "\\f8fd"; }
.bi-suitcase-lg-fill::before { content: "\\f8fe"; }
.bi-suitcase-lg::before { content: "\\f8ff"; }
.bi-suitcase::before { content: "\\f900"; }
.bi-suitcase2-fill::before { content: "\\f901"; }
.bi-suitcase2::before { content: "\\f902"; }
.bi-vignette::before { content: "\\f903"; }
`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 6351:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Mode = __webpack_require__(8674);
const NumericData = __webpack_require__(2127);
const AlphanumericData = __webpack_require__(5367);
const ByteData = __webpack_require__(8148);
const KanjiData = __webpack_require__(4271);
const Regex = __webpack_require__(4846);
const Utils = __webpack_require__(3340);
const dijkstra = __webpack_require__(4758);
function getStringByteLength(str) {
  return unescape(encodeURIComponent(str)).length;
}
function getSegments(regex, mode, str) {
  const segments = [];
  let result;
  while ((result = regex.exec(str)) !== null) {
    segments.push({
      data: result[0],
      index: result.index,
      mode: mode,
      length: result[0].length
    });
  }
  return segments;
}
function getSegmentsFromString(dataStr) {
  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
  let byteSegs;
  let kanjiSegs;
  if (Utils.isKanjiModeEnabled()) {
    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
  } else {
    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
    kanjiSegs = [];
  }
  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
  return segs.sort(function (s1, s2) {
    return s1.index - s2.index;
  }).map(function (obj) {
    return {
      data: obj.data,
      mode: obj.mode,
      length: obj.length
    };
  });
}
function getSegmentBitsLength(length, mode) {
  switch (mode) {
    case Mode.NUMERIC:
      return NumericData.getBitsLength(length);
    case Mode.ALPHANUMERIC:
      return AlphanumericData.getBitsLength(length);
    case Mode.KANJI:
      return KanjiData.getBitsLength(length);
    case Mode.BYTE:
      return ByteData.getBitsLength(length);
  }
}
function mergeSegments(segs) {
  return segs.reduce(function (acc, curr) {
    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
    if (prevSeg && prevSeg.mode === curr.mode) {
      acc[acc.length - 1].data += curr.data;
      return acc;
    }
    acc.push(curr);
    return acc;
  }, []);
}
function buildNodes(segs) {
  const nodes = [];
  for (let i = 0; i < segs.length; i++) {
    const seg = segs[i];
    switch (seg.mode) {
      case Mode.NUMERIC:
        nodes.push([seg, {
          data: seg.data,
          mode: Mode.ALPHANUMERIC,
          length: seg.length
        }, {
          data: seg.data,
          mode: Mode.BYTE,
          length: seg.length
        }]);
        break;
      case Mode.ALPHANUMERIC:
        nodes.push([seg, {
          data: seg.data,
          mode: Mode.BYTE,
          length: seg.length
        }]);
        break;
      case Mode.KANJI:
        nodes.push([seg, {
          data: seg.data,
          mode: Mode.BYTE,
          length: getStringByteLength(seg.data)
        }]);
        break;
      case Mode.BYTE:
        nodes.push([{
          data: seg.data,
          mode: Mode.BYTE,
          length: getStringByteLength(seg.data)
        }]);
    }
  }
  return nodes;
}
function buildGraph(nodes, version) {
  const table = {};
  const graph = {
    start: {}
  };
  let prevNodeIds = ['start'];
  for (let i = 0; i < nodes.length; i++) {
    const nodeGroup = nodes[i];
    const currentNodeIds = [];
    for (let j = 0; j < nodeGroup.length; j++) {
      const node = nodeGroup[j];
      const key = '' + i + j;
      currentNodeIds.push(key);
      table[key] = {
        node: node,
        lastCount: 0
      };
      graph[key] = {};
      for (let n = 0; n < prevNodeIds.length; n++) {
        const prevNodeId = prevNodeIds[n];
        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
          graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
          table[prevNodeId].lastCount += node.length;
        } else {
          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
        }
      }
    }
    prevNodeIds = currentNodeIds;
  }
  for (let n = 0; n < prevNodeIds.length; n++) {
    graph[prevNodeIds[n]].end = 0;
  }
  return {
    map: graph,
    table: table
  };
}
function buildSingleSegment(data, modesHint) {
  let mode;
  const bestMode = Mode.getBestModeForData(data);
  mode = Mode.from(modesHint, bestMode);
  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
    throw new Error('"' + data + '"' + ' cannot be encoded with mode ' + Mode.toString(mode) + '.\n Suggested mode is: ' + Mode.toString(bestMode));
  }
  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
    mode = Mode.BYTE;
  }
  switch (mode) {
    case Mode.NUMERIC:
      return new NumericData(data);
    case Mode.ALPHANUMERIC:
      return new AlphanumericData(data);
    case Mode.KANJI:
      return new KanjiData(data);
    case Mode.BYTE:
      return new ByteData(data);
  }
}
exports.fromArray = function fromArray(array) {
  return array.reduce(function (acc, seg) {
    if (typeof seg === 'string') {
      acc.push(buildSingleSegment(seg, null));
    } else if (seg.data) {
      acc.push(buildSingleSegment(seg.data, seg.mode));
    }
    return acc;
  }, []);
};
exports.fromString = function fromString(data, version) {
  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
  const nodes = buildNodes(segs);
  const graph = buildGraph(nodes, version);
  const path = dijkstra.find_path(graph.map, 'start', 'end');
  const optimizedSegs = [];
  for (let i = 1; i < path.length - 1; i++) {
    optimizedSegs.push(graph.table[path[i]].node);
  }
  return exports.fromArray(mergeSegments(optimizedSegs));
};
exports.rawSplit = function rawSplit(data) {
  return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
};

/***/ }),

/***/ 6411:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/bootstrap-icons.woff";

/***/ }),

/***/ 6693:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function loadMomentJS(root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(8123)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
  if (root) {
    root.momentJDateFormatParserSetup = root.moment ? factory(root.moment) : factory;
  }
})(this, function loadPlugin(moment) {
  var javaDateFormats = {};
  var momentDateFormats = {};
  var javaFormatMapping = {
    d: 'D',
    dd: 'DD',
    y: 'YYYY',
    yy: 'YY',
    yyy: 'YYYY',
    yyyy: 'YYYY',
    a: 'a',
    A: 'A',
    M: 'M',
    MM: 'MM',
    MMM: 'MMM',
    MMMM: 'MMMM',
    h: 'h',
    hh: 'hh',
    H: 'H',
    HH: 'HH',
    m: 'm',
    mm: 'mm',
    s: 's',
    ss: 'ss',
    S: 'SSS',
    SS: 'SSS',
    SSS: 'SSS',
    E: 'ddd',
    EE: 'ddd',
    EEE: 'ddd',
    EEEE: 'dddd',
    EEEEE: 'dddd',
    EEEEEE: 'dddd',
    D: 'DDD',
    w: 'W',
    ww: 'WW',
    z: 'ZZ',
    zzzz: 'Z',
    Z: 'ZZ',
    X: 'ZZ',
    XX: 'ZZ',
    XXX: 'Z',
    u: 'E'
  };
  var momentFormatMapping = {
    D: 'd',
    DD: 'dd',
    YY: 'yy',
    YYY: 'yyyy',
    YYYY: 'yyyy',
    a: 'a',
    A: 'a',
    M: 'M',
    MM: 'MM',
    MMM: 'MMM',
    MMMM: 'MMMM',
    h: 'h',
    hh: 'hh',
    H: 'H',
    HH: 'HH',
    m: 'm',
    mm: 'mm',
    s: 's',
    ss: 'ss',
    S: 'S',
    SS: 'S',
    SSS: 'S',
    ddd: 'E',
    dddd: 'EEEE',
    DDD: 'D',
    W: 'w',
    WW: 'ww',
    ZZ: 'z',
    Z: 'XXX',
    E: 'u'
  };
  var translateFormat = function (formatString, mapping) {
    var len = formatString.length;
    var i = 0;
    var startIndex = -1;
    var lastChar = null;
    var currentChar = "";
    var resultString = "";
    for (; i < len; i++) {
      currentChar = formatString.charAt(i);
      if (lastChar === null || lastChar !== currentChar) {
        resultString = _appendMappedString(formatString, mapping, startIndex, i, resultString);
        startIndex = i;
      }
      lastChar = currentChar;
    }
    return _appendMappedString(formatString, mapping, startIndex, i, resultString);
  };
  var _appendMappedString = function (formatString, mapping, startIndex, currentIndex, resultString) {
    if (startIndex !== -1) {
      var tempString = formatString.substring(startIndex, currentIndex);
      if (mapping[tempString]) {
        tempString = mapping[tempString];
      }
      resultString += tempString;
    }
    return resultString;
  };
  function init(momentJS) {
    if (!momentJS) {
      throw new Error("Moment JDateFormatParser Plugin - Cannot find moment.js instance.");
    }
    momentJS.fn.__translateJavaFormat = translateFormat;
    momentJS.fn.toMomentFormatString = function (formatString) {
      if (!javaDateFormats[formatString]) {
        var mapped = "";
        var regexp = /[^']+|('[^']*')/g;
        var part = '';
        while (part = regexp.exec(formatString)) {
          part = part[0];
          if (part.match(/'.?'/)) {
            mapped += "[" + part.substring(1, part.length - 1) + "]";
          } else {
            mapped += translateFormat(part, javaFormatMapping);
          }
        }
        javaDateFormats[formatString] = mapped;
      }
      return javaDateFormats[formatString];
    };
    momentJS.fn.formatWithJDF = function (formatString) {
      return this.format(this.toMomentFormatString(formatString));
    };
    momentJS.fn.toJDFString = function (formatString) {
      if (!momentDateFormats[formatString]) {
        momentDateFormats[formatString] = translateFormat(formatString, momentFormatMapping);
      }
      return momentDateFormats[formatString];
    };
  }
  init(moment);
  return init;
});

/***/ }),

/***/ 6877:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const canPromise = __webpack_require__(2063);
const QRCode = __webpack_require__(7503);
const CanvasRenderer = __webpack_require__(4165);
const SvgRenderer = __webpack_require__(7146);
function renderCanvas(renderFunc, canvas, text, opts, cb) {
  const args = [].slice.call(arguments, 1);
  const argsNum = args.length;
  const isLastArgCb = typeof args[argsNum - 1] === 'function';
  if (!isLastArgCb && !canPromise()) {
    throw new Error('Callback required as last argument');
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error('Too few arguments provided');
    }
    if (argsNum === 2) {
      cb = text;
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 3) {
      if (canvas.getContext && typeof cb === 'undefined') {
        cb = opts;
        opts = undefined;
      } else {
        cb = opts;
        opts = text;
        text = canvas;
        canvas = undefined;
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error('Too few arguments provided');
    }
    if (argsNum === 1) {
      text = canvas;
      canvas = opts = undefined;
    } else if (argsNum === 2 && !canvas.getContext) {
      opts = text;
      text = canvas;
      canvas = undefined;
    }
    return new Promise(function (resolve, reject) {
      try {
        const data = QRCode.create(text, opts);
        resolve(renderFunc(data, canvas, opts));
      } catch (e) {
        reject(e);
      }
    });
  }
  try {
    const data = QRCode.create(text, opts);
    cb(null, renderFunc(data, canvas, opts));
  } catch (e) {
    cb(e);
  }
}
exports.create = QRCode.create;
exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
exports.toString = renderCanvas.bind(null, function (data, _, opts) {
  return SvgRenderer.render(data, opts);
});

/***/ }),

/***/ 6967:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(2691);

/***/ }),

/***/ 7009:
/***/ ((__unused_webpack_module, exports) => {

const EXP_TABLE = new Uint8Array(512);
const LOG_TABLE = new Uint8Array(256);
(function initTables() {
  let x = 1;
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x;
    LOG_TABLE[x] = i;
    x <<= 1;
    if (x & 0x100) {
      x ^= 0x11D;
    }
  }
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255];
  }
})();
exports.log = function log(n) {
  if (n < 1) throw new Error('log(' + n + ')');
  return LOG_TABLE[n];
};
exports.exp = function exp(n) {
  return EXP_TABLE[n];
};
exports.mul = function mul(x, y) {
  if (x === 0 || y === 0) return 0;
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
};

/***/ }),

/***/ 7146:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Utils = __webpack_require__(9984);
function getColorAttrib(color, attrib) {
  const alpha = color.a / 255;
  const str = attrib + '="' + color.hex + '"';
  return alpha < 1 ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
}
function svgCmd(cmd, x, y) {
  let str = cmd + x;
  if (typeof y !== 'undefined') str += ' ' + y;
  return str;
}
function qrToPath(data, size, margin) {
  let path = '';
  let moveBy = 0;
  let newRow = false;
  let lineLength = 0;
  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size);
    const row = Math.floor(i / size);
    if (!col && !newRow) newRow = true;
    if (data[i]) {
      lineLength++;
      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow ? svgCmd('M', col + margin, 0.5 + row + margin) : svgCmd('m', moveBy, 0);
        moveBy = 0;
        newRow = false;
      }
      if (!(col + 1 < size && data[i + 1])) {
        path += svgCmd('h', lineLength);
        lineLength = 0;
      }
    } else {
      moveBy++;
    }
  }
  return path;
}
exports.render = function render(qrData, options, cb) {
  const opts = Utils.getOptions(options);
  const size = qrData.modules.size;
  const data = qrData.modules.data;
  const qrcodesize = size + opts.margin * 2;
  const bg = !opts.color.light.a ? '' : '<path ' + getColorAttrib(opts.color.light, 'fill') + ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';
  const path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
  const viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';
  const width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';
  const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';
  if (typeof cb === 'function') {
    cb(null, svgTag);
  }
  return svgTag;
};

/***/ }),

/***/ 7399:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8095);
/* harmony import */ var _node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7968);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_node_modules_bootstrap_icons_font_bootstrap_icons_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6142);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2187);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3__);
// Imports




var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(4491), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_1___ = new URL(/* asset import */ __webpack_require__(9419), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_2___ = new URL(/* asset import */ __webpack_require__(3363), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_3___ = new URL(/* asset import */ __webpack_require__(2045), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_4___ = new URL(/* asset import */ __webpack_require__(2221), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_5___ = new URL(/* asset import */ __webpack_require__(1683), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_6___ = new URL(/* asset import */ __webpack_require__(5299), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_7___ = new URL(/* asset import */ __webpack_require__(2907), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_8___ = new URL(/* asset import */ __webpack_require__(2213), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_9___ = new URL(/* asset import */ __webpack_require__(805), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_10___ = new URL(/* asset import */ __webpack_require__(8078), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_11___ = new URL(/* asset import */ __webpack_require__(410), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_12___ = new URL(/* asset import */ __webpack_require__(8232), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_13___ = new URL(/* asset import */ __webpack_require__(4996), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_14___ = new URL(/* asset import */ __webpack_require__(8456), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_15___ = new URL(/* asset import */ __webpack_require__(3819), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_16___ = new URL(/* asset import */ __webpack_require__(1712), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_17___ = new URL(/* asset import */ __webpack_require__(3552), __webpack_require__.b);
var ___CSS_LOADER_URL_IMPORT_18___ = new URL(/* asset import */ __webpack_require__(1195), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_noSourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_node_modules_bootstrap_icons_font_bootstrap_icons_css__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A);
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_0___);
var ___CSS_LOADER_URL_REPLACEMENT_1___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_0___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_2___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_1___);
var ___CSS_LOADER_URL_REPLACEMENT_3___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_2___);
var ___CSS_LOADER_URL_REPLACEMENT_4___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_3___, { hash: "#open_sansregular" });
var ___CSS_LOADER_URL_REPLACEMENT_5___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_4___);
var ___CSS_LOADER_URL_REPLACEMENT_6___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_5___);
var ___CSS_LOADER_URL_REPLACEMENT_7___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_5___, { hash: "?#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_8___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_6___);
var ___CSS_LOADER_URL_REPLACEMENT_9___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_7___);
var ___CSS_LOADER_URL_REPLACEMENT_10___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_8___, { hash: "#open_sanslight" });
var ___CSS_LOADER_URL_REPLACEMENT_11___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_9___);
var ___CSS_LOADER_URL_REPLACEMENT_12___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_10___);
var ___CSS_LOADER_URL_REPLACEMENT_13___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_10___, { hash: "#iefix" });
var ___CSS_LOADER_URL_REPLACEMENT_14___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_11___);
var ___CSS_LOADER_URL_REPLACEMENT_15___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_12___);
var ___CSS_LOADER_URL_REPLACEMENT_16___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_13___, { hash: "#ami" });
var ___CSS_LOADER_URL_REPLACEMENT_17___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_14___);
var ___CSS_LOADER_URL_REPLACEMENT_18___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_15___);
var ___CSS_LOADER_URL_REPLACEMENT_19___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_16___);
var ___CSS_LOADER_URL_REPLACEMENT_20___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_17___);
var ___CSS_LOADER_URL_REPLACEMENT_21___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_3___default()(___CSS_LOADER_URL_IMPORT_18___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `@font-face{font-family:"Open Sans";font-weight:normal;font-style:normal;src:url(${___CSS_LOADER_URL_REPLACEMENT_0___});src:local("Open Sans"),local("OpenSans"),url(${___CSS_LOADER_URL_REPLACEMENT_1___}) format("embedded-opentype"),url(${___CSS_LOADER_URL_REPLACEMENT_2___}) format("woff2"),url(${___CSS_LOADER_URL_REPLACEMENT_3___}) format("woff"),url(${___CSS_LOADER_URL_REPLACEMENT_4___}) format("svg"),url(${___CSS_LOADER_URL_REPLACEMENT_5___}) format("truetype")}@font-face{font-family:"Open Sans Light";font-weight:normal;font-style:normal;src:url(${___CSS_LOADER_URL_REPLACEMENT_6___});src:local("Open Sans Light"),local("OpenSans Light"),url(${___CSS_LOADER_URL_REPLACEMENT_7___}) format("embedded-opentype"),url(${___CSS_LOADER_URL_REPLACEMENT_8___}) format("woff2"),url(${___CSS_LOADER_URL_REPLACEMENT_9___}) format("woff"),url(${___CSS_LOADER_URL_REPLACEMENT_10___}) format("svg"),url(${___CSS_LOADER_URL_REPLACEMENT_11___}) format("truetype")}@font-face{font-family:"ami";font-weight:normal;font-style:normal;src:url(${___CSS_LOADER_URL_REPLACEMENT_12___});src:url(${___CSS_LOADER_URL_REPLACEMENT_13___}) format("embedded-opentype"),url(${___CSS_LOADER_URL_REPLACEMENT_14___}) format("woff2"),url(${___CSS_LOADER_URL_REPLACEMENT_15___}) format("woff"),url(${___CSS_LOADER_URL_REPLACEMENT_16___}) format("svg"),url(${___CSS_LOADER_URL_REPLACEMENT_17___}) format("truetype")}@font-face{font-family:"Trochut";font-weight:normal;font-style:normal;src:url(${___CSS_LOADER_URL_REPLACEMENT_18___}) format("truetype")}a{text-decoration:none}h1,h2,h3,h4,h5,h6{font-family:"Open Sans Light","Open Sans"}pre{background-image:url(${___CSS_LOADER_URL_REPLACEMENT_19___});border:1px solid #ced4da;border-radius:.2rem;padding:.5rem}.bi-lpsc:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-cern:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-ami:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-rucio:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-node-red:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-arrow-down-circle-fill:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-arrow-right-circle-fill:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-arrow-left-circle-fill:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-arrow-up-circle-fill:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-key:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-leaf:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-flask:before{font-family:ami !important;vertical-align:0 !important;content:""}.bi-slack:before{font-family:ami !important;vertical-align:0 !important;content:""}.w-lg-25{width:100%}.w-lg-50{width:100%}.w-lg-75{width:100%}@media screen and (min-width: 992px){.w-lg-25{width:25%}.w-lg-50{width:50%}.w-lg-75{width:75%}}[data-bs-theme=light] .bg-light,[data-bs-theme=light] .modal-header{background:var(--bs-body-bg) url(${___CSS_LOADER_URL_REPLACEMENT_20___})}[data-bs-theme=light] .bg-light2,[data-bs-theme=light] .breadcrumb,[data-bs-theme=light] .card-header,[data-bs-theme=light] .card-footer,[data-bs-theme=light] .modal-footer{background:var(--bs-tertiary-bg) url(${___CSS_LOADER_URL_REPLACEMENT_21___})}[data-bs-theme=dark] .bg-light{background-color:var(--bs-body-bg) !important}[data-bs-theme=dark] .bg-light2,[data-bs-theme=dark] .breadcrumb{background-color:var(--bs-tertiary-bg) !important}.breadcrumb{border-radius:.125rem;padding:.25rem .5rem}.modal-header{border-radius:.25rem .25rem 0 0}.modal-footer{border-radius:0 0 .25rem .25rem}.navbar-nav .dropdown-menu{padding:.3rem 0}.navbar-nav .dropdown-divider{margin:.2rem 0}.navbar-nav .dropdown-item{padding:.2rem 1rem}@media(min-width: 768px){.navbar-nav>li>.dropdown-menu::before{border-bottom:7px solid rgba(0,0,0,.2);border-left:7px solid rgba(0,0,0,0);border-right:7px solid rgba(0,0,0,0);content:"";display:inline-block;left:9px;position:absolute;top:-7px}.navbar-nav>li>.dropdown-menu::after{border-bottom:6px solid #fff;border-left:6px solid rgba(0,0,0,0);border-right:6px solid rgba(0,0,0,0);content:"";display:inline-block;left:10px;position:absolute;top:-6px}.navbar-nav.navbar-right>li>.dropdown-menu::before{left:auto;right:12px}.navbar-nav.navbar-right>li>.dropdown-menu::after{left:auto;right:13px}}.nav-tabs .nav-link{background:none}.form-label{margin-bottom:.125rem}#jsdoc_content{text-align:justify}#jsdoc_content dl.details{border-left:2px solid #ccc;margin-top:.5rem}#jsdoc_content dl.details dt{padding-left:.5rem}#jsdoc_content dl.details dd{padding-left:1.5rem}#jsdoc_content .signature-name{color:#007bff;font-size:calc(1.3*var(--bs-body-font-size, 0.9375rem))}#jsdoc_content .signature-params{color:#000;font-size:calc(1.3*var(--bs-body-font-size, 0.9375rem))}#jsdoc_content .signature-params-attrs{color:#aaa;font-size:calc(1*var(--bs-body-font-size, 0.9375rem))}#jsdoc_content .signature-attrs{color:#aaa;font-size:calc(1.3*var(--bs-body-font-size, 0.9375rem))}#jsdoc_content .signature-params-attrs{font-style:italic;margin-left:2px}#ami_alert_content{position:absolute;z-index:99999999;top:8px;right:8px}.ami-code{text-align:left}.ami-code,.ami-code code{white-space:pre-wrap;word-break:break-all}.form-editor-done{opacity:0;pointer-events:none;position:fixed;z-index:-9999;top:0;left:0;height:0;width:0}.select2-container--default{width:100% !important}.select2-container--default .select2-selection--single,.select2-container--default .select2-selection--multiple,.select2-container--default .select2-selection--multiple .select2-selection__choice{border:1px solid #ced4da !important;border-radius:.2rem !important}.select2-container--default .select2-selection--single,.select2-container--default .select2-selection--single .select2-selection__arrow{height:calc(1.5em + .75rem + 2px) !important}.select2-container--default .select2-selection--single{padding:calc((1.5em + .75rem)/2 - 14px) .25rem !important}.form-control-sm~.select2-container--default .select2-selection--single,.form-control-sm~.select2-container--default .select2-selection--single .select2-selection__arrow,.input-group-sm .select2-container--default .select2-selection--single,.input-group-sm .select2-container--default .select2-selection--single .select2-selection__arrow{height:calc(1.5em + .5rem + 2px) !important}.form-control-sm~.select2-container--default .select2-selection--single,.input-group-sm .select2-container--default .select2-selection--single{padding:calc((1.5em + .5rem)/2 - 14px) 0rem !important}.form-control-lg~.select2-container--default .select2-selection--single,.form-control-lg~.select2-container--default .select2-selection--single .select2-selection__arrow,.input-group-lg .select2-container--default .select2-selection--single,.input-group-lg .select2-container--default .select2-selection--single .select2-selection__arrow{height:calc(1.5em + 1rem + 2px) !important}.form-control-lg~.select2-container--default .select2-selection--single,.input-group-lg .select2-container--default .select2-selection--single{padding:calc((1.5em + 1rem)/2 - 14px) .5rem !important}input.form-datetime,input.form-date,input.form-time,input.form-time-hm{background-color:#fff !important}.flatpickr-calendar .dayContainer{padding-bottom:2px}`, ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 7432:
/***/ ((__unused_webpack_module, exports) => {

exports.isValid = function isValid(version) {
  return !isNaN(version) && version >= 1 && version <= 40;
};

/***/ }),

/***/ 7503:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Utils = __webpack_require__(3340);
const ECLevel = __webpack_require__(151);
const BitBuffer = __webpack_require__(93);
const BitMatrix = __webpack_require__(5458);
const AlignmentPattern = __webpack_require__(3099);
const FinderPattern = __webpack_require__(4726);
const MaskPattern = __webpack_require__(5106);
const ECCode = __webpack_require__(3020);
const ReedSolomonEncoder = __webpack_require__(9394);
const Version = __webpack_require__(5617);
const FormatInfo = __webpack_require__(3487);
const Mode = __webpack_require__(8674);
const Segments = __webpack_require__(6351);
function setupFinderPattern(matrix, version) {
  const size = matrix.size;
  const pos = FinderPattern.getPositions(version);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r = -1; r <= 7; r++) {
      if (row + r <= -1 || size <= row + r) continue;
      for (let c = -1; c <= 7; c++) {
        if (col + c <= -1 || size <= col + c) continue;
        if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size = matrix.size;
  for (let r = 8; r < size - 8; r++) {
    const value = r % 2 === 0;
    matrix.set(r, 6, value, true);
    matrix.set(6, r, value, true);
  }
}
function setupAlignmentPattern(matrix, version) {
  const pos = AlignmentPattern.getPositions(version);
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0];
    const col = pos[i][1];
    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
          matrix.set(row + r, col + c, true, true);
        } else {
          matrix.set(row + r, col + c, false, true);
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version) {
  const size = matrix.size;
  const bits = Version.getEncodedBits(version);
  let row, col, mod;
  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3);
    col = i % 3 + size - 8 - 3;
    mod = (bits >> i & 1) === 1;
    matrix.set(row, col, mod, true);
    matrix.set(col, row, mod, true);
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
  const size = matrix.size;
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
  let i, mod;
  for (i = 0; i < 15; i++) {
    mod = (bits >> i & 1) === 1;
    if (i < 6) {
      matrix.set(i, 8, mod, true);
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true);
    } else {
      matrix.set(size - 15 + i, 8, mod, true);
    }
    if (i < 8) {
      matrix.set(8, size - i - 1, mod, true);
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true);
    } else {
      matrix.set(8, 15 - i - 1, mod, true);
    }
  }
  matrix.set(size - 8, 8, 1, true);
}
function setupData(matrix, data) {
  const size = matrix.size;
  let inc = -1;
  let row = size - 1;
  let bitIndex = 7;
  let byteIndex = 0;
  for (let col = size - 1; col > 0; col -= 2) {
    if (col === 6) col--;
    while (true) {
      for (let c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          let dark = false;
          if (byteIndex < data.length) {
            dark = (data[byteIndex] >>> bitIndex & 1) === 1;
          }
          matrix.set(row, col - c, dark);
          bitIndex--;
          if (bitIndex === -1) {
            byteIndex++;
            bitIndex = 7;
          }
        }
      }
      row += inc;
      if (row < 0 || size <= row) {
        row -= inc;
        inc = -inc;
        break;
      }
    }
  }
}
function createData(version, errorCorrectionLevel, segments) {
  const buffer = new BitBuffer();
  segments.forEach(function (data) {
    buffer.put(data.mode.bit, 4);
    buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
    data.write(buffer);
  });
  const totalCodewords = Utils.getSymbolTotalCodewords(version);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer.put(0, 4);
  }
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(0);
  }
  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
  for (let i = 0; i < remainingByte; i++) {
    buffer.put(i % 2 ? 0x11 : 0xEC, 8);
  }
  return createCodewords(buffer, version, errorCorrectionLevel);
}
function createCodewords(bitBuffer, version, errorCorrectionLevel) {
  const totalCodewords = Utils.getSymbolTotalCodewords(version);
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
  const dataTotalCodewords = totalCodewords - ecTotalCodewords;
  const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
  const blocksInGroup2 = totalCodewords % ecTotalBlocks;
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
  const rs = new ReedSolomonEncoder(ecCount);
  let offset = 0;
  const dcData = new Array(ecTotalBlocks);
  const ecData = new Array(ecTotalBlocks);
  let maxDataSize = 0;
  const buffer = new Uint8Array(bitBuffer.buffer);
  for (let b = 0; b < ecTotalBlocks; b++) {
    const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
    dcData[b] = buffer.slice(offset, offset + dataSize);
    ecData[b] = rs.encode(dcData[b]);
    offset += dataSize;
    maxDataSize = Math.max(maxDataSize, dataSize);
  }
  const data = new Uint8Array(totalCodewords);
  let index = 0;
  let i, r;
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index++] = dcData[r][i];
      }
    }
  }
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index++] = ecData[r][i];
    }
  }
  return data;
}
function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
  let segments;
  if (Array.isArray(data)) {
    segments = Segments.fromArray(data);
  } else if (typeof data === 'string') {
    let estimatedVersion = version;
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data);
      estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
    }
    segments = Segments.fromString(data, estimatedVersion || 40);
  } else {
    throw new Error('Invalid data');
  }
  const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
  if (!bestVersion) {
    throw new Error('The amount of data is too big to be stored in a QR Code');
  }
  if (!version) {
    version = bestVersion;
  } else if (version < bestVersion) {
    throw new Error('\n' + 'The chosen QR Code version cannot contain this amount of data.\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\n');
  }
  const dataBits = createData(version, errorCorrectionLevel, segments);
  const moduleCount = Utils.getSymbolSize(version);
  const modules = new BitMatrix(moduleCount);
  setupFinderPattern(modules, version);
  setupTimingPattern(modules);
  setupAlignmentPattern(modules, version);
  setupFormatInfo(modules, errorCorrectionLevel, 0);
  if (version >= 7) {
    setupVersionInfo(modules, version);
  }
  setupData(modules, dataBits);
  if (isNaN(maskPattern)) {
    maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
  }
  MaskPattern.applyMask(maskPattern, modules);
  setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
  return {
    modules: modules,
    version: version,
    errorCorrectionLevel: errorCorrectionLevel,
    maskPattern: maskPattern,
    segments: segments
  };
}
exports.create = function create(data, options) {
  if (typeof data === 'undefined' || data === '') {
    throw new Error('No input text');
  }
  let errorCorrectionLevel = ECLevel.M;
  let version;
  let mask;
  if (typeof options !== 'undefined') {
    errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
    version = Version.from(options.version);
    mask = MaskPattern.from(options.maskPattern);
    if (options.toSJISFunc) {
      Utils.setToSJISFunction(options.toSJISFunc);
    }
  }
  return createSymbol(data, version, errorCorrectionLevel, mask);
};

/***/ }),

/***/ 7659:
/***/ ((module) => {

"use strict";


var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ 7825:
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ 7968:
/***/ ((module) => {

"use strict";

module.exports = function (cssWithMappingToString) {
  var list = [];
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ 8078:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/ami.eot";

/***/ }),

/***/ 8095:
/***/ ((module) => {

"use strict";


module.exports = function (i) {
  return i[1];
};

/***/ }),

/***/ 8123:
/***/ ((module) => {

"use strict";
module.exports = moment;

/***/ }),

/***/ 8148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Mode = __webpack_require__(8674);
function ByteData(data) {
  this.mode = Mode.BYTE;
  if (typeof data === 'string') {
    this.data = new TextEncoder().encode(data);
  } else {
    this.data = new Uint8Array(data);
  }
}
ByteData.getBitsLength = function getBitsLength(length) {
  return length * 8;
};
ByteData.prototype.getLength = function getLength() {
  return this.data.length;
};
ByteData.prototype.getBitsLength = function getBitsLength() {
  return ByteData.getBitsLength(this.data.length);
};
ByteData.prototype.write = function (bitBuffer) {
  for (let i = 0, l = this.data.length; i < l; i++) {
    bitBuffer.put(this.data[i], 8);
  }
};
module.exports = ByteData;

/***/ }),

/***/ 8232:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/ami.woff";

/***/ }),

/***/ 8456:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/ami.ttf";

/***/ }),

/***/ 8674:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const VersionCheck = __webpack_require__(7432);
const Regex = __webpack_require__(4846);
exports.NUMERIC = {
  id: 'Numeric',
  bit: 1 << 0,
  ccBits: [10, 12, 14]
};
exports.ALPHANUMERIC = {
  id: 'Alphanumeric',
  bit: 1 << 1,
  ccBits: [9, 11, 13]
};
exports.BYTE = {
  id: 'Byte',
  bit: 1 << 2,
  ccBits: [8, 16, 16]
};
exports.KANJI = {
  id: 'Kanji',
  bit: 1 << 3,
  ccBits: [8, 10, 12]
};
exports.MIXED = {
  bit: -1
};
exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
  if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);
  if (!VersionCheck.isValid(version)) {
    throw new Error('Invalid version: ' + version);
  }
  if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];
  return mode.ccBits[2];
};
exports.getBestModeForData = function getBestModeForData(dataStr) {
  if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;
};
exports.toString = function toString(mode) {
  if (mode && mode.id) return mode.id;
  throw new Error('Invalid mode');
};
exports.isValid = function isValid(mode) {
  return mode && mode.bit && mode.ccBits;
};
function fromString(string) {
  if (typeof string !== 'string') {
    throw new Error('Param is not a string');
  }
  const lcStr = string.toLowerCase();
  switch (lcStr) {
    case 'numeric':
      return exports.NUMERIC;
    case 'alphanumeric':
      return exports.ALPHANUMERIC;
    case 'kanji':
      return exports.KANJI;
    case 'byte':
      return exports.BYTE;
    default:
      throw new Error('Unknown mode: ' + string);
  }
}
exports.from = function from(value, defaultValue) {
  if (exports.isValid(value)) {
    return value;
  }
  try {
    return fromString(value);
  } catch (e) {
    return defaultValue;
  }
};

/***/ }),

/***/ 9394:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Polynomial = __webpack_require__(3075);
function ReedSolomonEncoder(degree) {
  this.genPoly = undefined;
  this.degree = degree;
  if (this.degree) this.initialize(this.degree);
}
ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
  this.degree = degree;
  this.genPoly = Polynomial.generateECPolynomial(this.degree);
};
ReedSolomonEncoder.prototype.encode = function encode(data) {
  if (!this.genPoly) {
    throw new Error('Encoder not initialized');
  }
  const paddedData = new Uint8Array(data.length + this.degree);
  paddedData.set(data);
  const remainder = Polynomial.mod(paddedData, this.genPoly);
  const start = this.degree - remainder.length;
  if (start > 0) {
    const buff = new Uint8Array(this.degree);
    buff.set(remainder, start);
    return buff;
  }
  return remainder;
};
module.exports = ReedSolomonEncoder;

/***/ }),

/***/ 9419:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "assets/fonts/OpenSans-Regular-webfont.woff2";

/***/ }),

/***/ 9984:
/***/ ((__unused_webpack_module, exports) => {

function hex2rgba(hex) {
  if (typeof hex === 'number') {
    hex = hex.toString();
  }
  if (typeof hex !== 'string') {
    throw new Error('Color should be defined as hex string');
  }
  let hexCode = hex.slice().replace('#', '').split('');
  if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
    throw new Error('Invalid hex color: ' + hex);
  }
  if (hexCode.length === 3 || hexCode.length === 4) {
    hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
      return [c, c];
    }));
  }
  if (hexCode.length === 6) hexCode.push('F', 'F');
  const hexValue = parseInt(hexCode.join(''), 16);
  return {
    r: hexValue >> 24 & 255,
    g: hexValue >> 16 & 255,
    b: hexValue >> 8 & 255,
    a: hexValue & 255,
    hex: '#' + hexCode.slice(0, 6).join('')
  };
}
exports.getOptions = function getOptions(options) {
  if (!options) options = {};
  if (!options.color) options.color = {};
  const margin = typeof options.margin === 'undefined' || options.margin === null || options.margin < 0 ? 4 : options.margin;
  const width = options.width && options.width >= 21 ? options.width : undefined;
  const scale = options.scale || 4;
  return {
    width: width,
    scale: width ? 4 : scale,
    margin: margin,
    color: {
      dark: hex2rgba(options.color.dark || '#000000ff'),
      light: hex2rgba(options.color.light || '#ffffffff')
    },
    type: options.type,
    rendererOpts: options.rendererOpts || {}
  };
};
exports.getScale = function getScale(qrSize, opts) {
  return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
};
exports.getImageWidth = function getImageWidth(qrSize, opts) {
  const scale = exports.getScale(qrSize, opts);
  return Math.floor((qrSize + opts.margin * 2) * scale);
};
exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
  const size = qr.modules.size;
  const data = qr.modules.data;
  const scale = exports.getScale(size, opts);
  const symbolSize = Math.floor((size + opts.margin * 2) * scale);
  const scaledMargin = opts.margin * scale;
  const palette = [opts.color.light, opts.color.dark];
  for (let i = 0; i < symbolSize; i++) {
    for (let j = 0; j < symbolSize; j++) {
      let posDst = (i * symbolSize + j) * 4;
      let pxColor = opts.color.light;
      if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
        const iSrc = Math.floor((i - scaledMargin) / scale);
        const jSrc = Math.floor((j - scaledMargin) / scale);
        pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
      }
      imgData[posDst++] = pxColor.r;
      imgData[posDst++] = pxColor.g;
      imgData[posDst++] = pxColor.b;
      imgData[posDst] = pxColor.a;
    }
  }
};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "assets/js/chunks/" + chunkId + ".min.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "awf:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			2548: 0,
/******/ 			7802: 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkawf"] = self["webpackChunkawf"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

;// ./src/js/AMIObject.js

let $this;
if (typeof window !== 'undefined') {
  $this = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  $this = __webpack_require__.g;
} else {
  throw 'Neither \'window\' nor \'global\' is defined';
}
function _$createNamespace($name, x) {
  let i;
  let parent = $this;
  const parts = $name.split(/\s*\.\s*/g),
    l = parts.length - 1;
  for (i = 0; i < l; i++) {
    if (parent[parts[i]]) {
      parent = parent[parts[i]];
    } else {
      parent = parent[parts[i]] = {};
    }
  }
  parent[parts[i]] = x;
}
function _$addToNamespace($name, x) {
  let i;
  let parent = $this;
  const parts = $name.split(/\s*\.\s*/g),
    l = parts.length - 1;
  for (i = 0; i < l; i++) {
    if (parent[parts[i]]) {
      parent = parent[parts[i]];
    } else {
      throw `'${$name}' ('${parts[i]}') not declared`;
    }
  }
  parent[parts[i]] = x;
}
function $AMINamespace($name, $descr) {
  $descr = $descr || {};
  $descr.$name = $name;
  _$createNamespace($name, $descr);
  if ($descr.$) {
    $descr.$.apply($descr);
  }
}
function $AMIInterface($name, $descr) {
  $descr = $descr || {};
  const $class = function () {
    throw 'could nor instantiate interface';
  };
  if ($descr.$extends) {
    throw '`$extends` not allowed for interface';
  }
  if ($descr.$implements) {
    throw '`$implements` not allowed for interface';
  }
  if ($descr.$) {
    throw '`$` not allowed for interface';
  }
  if ($descr.$init) {
    throw '`$init` not allowed for interface';
  }
  $class.$name = $name;
  $class.$class = $class;
  $class.$members = $descr;
  _$addToNamespace($name, $class);
}
function $AMIClass($name, $descr) {
  $descr = $descr || {};
  const $super = $descr.$extends instanceof Function ? $descr.$extends.prototype : {};
  const $super_implements = $super.$implements instanceof Array ? $super.$implements : [];
  const $descr_implements = $descr.$implements instanceof Array ? $descr.$implements : [];
  const $class = function () {
    for (const i in this.$implements) {
      if (this.$implements.hasOwnProperty(i)) {
          const $interface = this.$implements[i];
          for (const j in $interface.$members) {
            if ($interface.$members.hasOwnProperty(j)) {
                const $member = $interface.$members[j];
                if (typeof this[j] !== typeof $member) {
                  alert(`class '${this.$name}' must implement '${$interface.$name}.${j}'`);
                }
              }
          }
        }
    }
    const _super = this.$class._internal_super;
    const _added = this.$class._internal_added;
    this.$super = {};
    for (const name in _super) {
      if (_super.hasOwnProperty(name)) {
          this.$super[name] = ((_super, name, that) => function () {
            return _super[name].apply(that, arguments);
          })(_super, name, this);
        }
    }
    this.$added = {};
    for (const name in _added) {
      if (_added.hasOwnProperty(name)) {
          this.$added[name] = ((_added, name, that) => function () {
            return _added[name].apply(that, arguments);
          })(_added, name, this);
        }
    }
    if (this.$init) {
      this.$init.apply(this, arguments);
    }
  };
  $class._internal_super = {};
  $class._internal_added = {};
  for (const name in $super) {
    if (name === '$init' || name.charAt(0) !== '$' || $super.hasOwnProperty(name)) {
      $class._internal_super[name] = $super[name];
      $class.prototype[name] = $super[name];
    }
  }
  for (const name in $descr) {
    if (name === '$init' || name.charAt(0) !== '$' || $descr.hasOwnProperty(name)) {
      $class._internal_added[name] = $descr[name];
      $class.prototype[name] = $descr[name];
    }
  }
  $class.prototype.$name = $name;
  $class.prototype.$class = $class;
  $class.prototype.$implements = $super_implements.concat($descr_implements);
  _$addToNamespace($name, $class);
  if ($descr.$) {
    $descr.$.apply($class);
  }
}
if (typeof jQuery !== 'undefined') {
  jQuery.Namespace = $AMINamespace;
  jQuery.Interface = $AMIInterface;
  jQuery.Class = $AMIClass;
}
// EXTERNAL MODULE: ./node_modules/jspath/index.js
var jspath = __webpack_require__(6967);
var jspath_default = /*#__PURE__*/__webpack_require__.n(jspath);
;// ./node_modules/ami-http-client/src/client.js


class AMIHTTPClient {
  version = '{{VERSION}}';
  #endpoint = '';
  #converter = 'AMIXmlToJson.xsl';
  #paramRegExp = (() => new RegExp('-\\W*([a-zA-Z][a-zA-Z0-9]*)\\W*=\\W*\\?', 'g'))();
  #errorMessage = 'resource temporarily unreachable';
  constructor(endpoint) {
    this.#endpoint = endpoint;
  }
  getEndpoint() {
    return this.#endpoint;
  }
  static #response(data, message, urlWithParameters, jsonError) {
    if (jsonError) {
      data = {
        'AMIMessage': [{
          'error': [{
            '$': data
          }]
        }]
      };
    }
    return {
      data: data,
      message: message,
      urlWithParameters: urlWithParameters
    };
  }
  execute(command, options) {
    options = options || {};
    const endpoint = (options.endpoint || this.#endpoint).trim();
    const converter = (options.converter || this.#converter).trim();
    const extras = options.extras || {};
    const params = options.params || [];
    const timeout = options.timeout || 120000;
    command = (command || '').trim().replace(this.#paramRegExp, (x, y) => {
      const rawValue = params.shift();
      return Object.prototype.toString.call(rawValue) === '[object String]' ? `-${y}=${JSON.stringify(rawValue)}` : `-${y}="${JSON.stringify(rawValue)}"`;
    });
    const data = {
      Command: command,
      Converter: converter,
      ...extras
    };
    const body = Object.entries(data).map(_ref => {
      let [k, v] = _ref;
      return `${encodeURIComponent(k)}=${encodeURIComponent(v)}`;
    }).join('&');
    const url = endpoint;
    const urlWithParameters = endpoint + '?' + body;
    return new Promise((resolve, reject) => {
      if (converter === 'AMIXmlToJson.xsl') {
        let inTime = true;
        const timeoutId = setTimeout(() => {
          reject(AMIHTTPClient.#response('timeout', 'timeout', urlWithParameters, true));
          inTime = false;
        }, timeout);
        fetch(url, {
          body: body,
          method: 'POST',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
          },
          credentials: 'include',
          cache: 'no-cache',
          mode: 'cors'
        }).finally(() => {
          clearTimeout(timeoutId);
        }).then(response => {
          if (inTime) {
            response.json().then(data => {
              const info = jspath_default().apply('.AMIMessage.info.$', data);
              const error = jspath_default().apply('.AMIMessage.error.$', data);
              if (error.length === 0) {
                resolve(AMIHTTPClient.#response(data, info.join('. '), urlWithParameters, false));
              } else {
                reject(AMIHTTPClient.#response(data, error.join('. '), urlWithParameters, true));
              }
            }).catch(() => {
              reject(AMIHTTPClient.#response(this.#errorMessage, this.#errorMessage, urlWithParameters, true));
            });
          }
        }).catch(() => {
          if (inTime) {
            reject(AMIHTTPClient.#response(this.#errorMessage, this.#errorMessage, urlWithParameters, true));
          }
        });
      } else {
        let inTime = true;
        const timeoutId = setTimeout(() => {
          reject(AMIHTTPClient.#response('timeout', 'timeout', urlWithParameters, false));
          inTime = false;
        }, timeout);
        fetch(url, {
          body: body,
          method: 'POST',
          headers: {
            'Accept': 'text/plain',
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
          },
          credentials: 'include',
          cache: 'no-cache',
          mode: 'cors'
        }).finally(() => {
          clearTimeout(timeoutId);
        }).then(response => {
          if (inTime) {
            response.text().then(data => {
              resolve(AMIHTTPClient.#response(data, data, urlWithParameters, false));
            }).catch(() => {
              reject(AMIHTTPClient.#response(this.#errorMessage, this.#errorMessage, urlWithParameters, false));
            });
          }
        }).catch(() => {
          if (inTime) {
            reject(AMIHTTPClient.#response(this.#errorMessage, this.#errorMessage, urlWithParameters, false));
          }
        });
      }
    });
  }
  static #guest() {
    return {
      AMIUser: 'guest',
      guestUser: 'guest',
      clientDNInAMI: '',
      issuerDNInAMI: '',
      clientDNInSession: '',
      issuerDNInSession: '',
      notBefore: '',
      notAfter: '',
      mqttToken: '',
      firstName: 'guest',
      lastName: 'guest',
      email: 'N/A',
      country: 'N/A',
      valid: 'false'
    };
  }
  #getUserInfo(promise) {
    return new Promise((resolve, reject) => {
      promise.then(response => {
        const userInfo = {};
        const roleInfo = {};
        const bookmarkInfo = {};
        const dashboardInfo = {};
        const awfInfo = {};
        jspath_default().apply('..rowset{.@type==="user"}.row.field', response.data).forEach(item => {
          userInfo[item['@name']] = item['$'];
        });
        jspath_default().apply('..rowset{.@type==="awf"}.row.field', response.data).forEach(item => {
          awfInfo[item['@name']] = item['$'];
        });
        jspath_default().apply('..rowset{.@type==="role"}.row', response.data).forEach(row => {
          let name = '';
          const role = {};
          row.field.forEach(field => {
            role[field['@name']] = field['$'];
            if (field['@name'] === 'name') {
              name = field['$'];
            }
          });
          roleInfo[name] = role;
        });
        jspath_default().apply('..rowset{.@type==="bookmark"}.row', response.data).forEach(row => {
          let hash = '';
          const bookmark = {};
          row.field.forEach(field => {
            bookmark[field['@name']] = field['$'];
            if (field['@name'] === 'hash') {
              hash = field['$'];
            }
          });
          bookmarkInfo[hash] = bookmark;
        });
        jspath_default().apply('..rowset{.@type==="dashboard"}.row', response.data).forEach(row => {
          let hash = '';
          const dashboard = {};
          row.field.forEach(field => {
            dashboard[field['@name']] = field['$'];
            if (field['@name'] === 'hash') {
              hash = field['$'];
            }
          });
          dashboardInfo[hash] = dashboard;
        });
        resolve({
          data: response.data,
          message: response.message,
          userInfo: userInfo,
          roleInfo: roleInfo,
          bookmarkInfo: bookmarkInfo,
          dashboardInfo: dashboardInfo,
          awfInfo: awfInfo
        });
      }).catch(response => {
        reject({
          data: response.data,
          message: response.message,
          userInfo: AMIHTTPClient.#guest(),
          roleInfo: {},
          bookmarkInfo: {},
          dashboardInfo: {},
          awfInfo: {}
        });
      });
    });
  }
  signInByCode(code, options) {
    options = options || {};
    options['extras'] = {
      'NoCert': null
    };
    options['params'] = [code];
    return this.#getUserInfo(this.execute('GetSessionInfo -AMIUser="__oidc_code__" -AMIPass=?', options));
  }
  signInByToken(token, options) {
    options = options || {};
    options['extras'] = {
      'NoCert': null
    };
    options['params'] = [token];
    return this.#getUserInfo(this.execute('GetSessionInfo -AMIUser="__oidc_token__" -AMIPass=?', options));
  }
  signInByPassword(username, password, options) {
    options = options || {};
    options['extras'] = {
      'NoCert': null
    };
    options['params'] = [username, password];
    return this.#getUserInfo(this.execute('GetSessionInfo -AMIUser=? -AMIPass=?', options));
  }
  signInByCertificate(options) {
    options = options || {};
    options['extras'] = {};
    options['params'] = [];
    return this.#getUserInfo(this.execute('GetSessionInfo', options));
  }
  signOut(options) {
    options = options || {};
    options['extras'] = {
      'NoCert': null
    };
    options['params'] = ['', ''];
    return this.#getUserInfo(this.execute('GetSessionInfo -AMIUser=? -AMIPass=?', options));
  }
  jspath(path, json) {
    return jspath_default().apply(path, json);
  }
}
if (typeof window !== 'undefined') window.AMIHTTPClient = AMIHTTPClient;
/* harmony default export */ const client = (AMIHTTPClient);
;// ./node_modules/ami-http-client/index.js


/* harmony default export */ const ami_http_client = (client);
// EXTERNAL MODULE: ./node_modules/paho-mqtt/paho-mqtt.js
var paho_mqtt = __webpack_require__(2725);
;// ./node_modules/ami-mqtt-client/src/client.js



function parseJwt(token) {
  try {
    const parts = token.split('.');
    if (parts.length > 1) {
      const payload = decodeURIComponent(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')).split('').map(c => {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
      }).join(''));
      return JSON.parse(payload);
    } else {
      return {};
    }
  } catch (e) {
    return {};
  }
}
class AMIMQTTClient {
  version = '{{VERSION}}';
  #L = {};
  #cnt = 0x01;
  #connected = false;
  #converter = 'AMIXmlToJson.xsl';
  #paramRegExp = (() => new RegExp('-\\W*([a-zA-Z][a-zA-Z0-9]*)\\W*=\\W*\\?', 'g'))();
  #responseRegExp = (() => new RegExp('AMI-RESPONSE<([0-9]+),(true|false)>(.*)', 's'))();
  constructor(endpoint, options) {
    var _this = this;
    options = options || {};
    const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = 16 * Math.random(),
        v = c === 'x' ? r | 0x000000000 : r & 0x03 | 0x08;
      return v.toString(16);
    });
    this._uuid = uuid;
    this._endpoint = endpoint;
    this._discoveryTopic = options.discoveryTopic;
    this._triggerDiscoveryTopic = options.triggerDiscoveryTopic;
    this._userOnConnected = options.onConnected || null;
    this._userOnConnectionLost = options.onConnectionLost || null;
    this._userOnMessageArrived = options.onMessageArrived || null;
    this._userOnMessageDelivered = options.onMessageDelivered || null;
    const url = new URL(endpoint);
    this._useSSL = url.protocol === 'wss:';
    this._client = new paho_mqtt.Client(url.hostname, parseInt(url.port || '443'), url.pathname, uuid);
    this._client.onConnected = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _this.#onConnected.apply(_this, args);
    };
    this._client.onConnectionLost = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.#onConnectionLost.apply(_this, args);
    };
    this._client.onMessageArrived = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.#onMessageArrived.apply(_this, args);
    };
    this._client.onMessageDelivered = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.#onMessageDelivered.apply(_this, args);
    };
  }
  setOnConnected(onConnected) {
    this._userOnConnected = onConnected;
    return this;
  }
  setOnConnectionLost(onConnectionLost) {
    this._userOnConnectionLost = onConnectionLost;
    return this;
  }
  setOnMessageArrived(onMessageArrived) {
    this._userOnMessageArrived = onMessageArrived;
    return this;
  }
  setOnMessageDelivered(onMessageDelivered) {
    this._userOnMessageDelivered = onMessageDelivered;
    return this;
  }
  signInByToken(password, serverName) {
    if (serverName === void 0) {
      serverName = '';
    }
    return new Promise((resolve, reject) => {
      const username = parseJwt(password).sub;
      if (username) {
        this._username = username;
        this._serverName = serverName;
        if (this._serverName || this._discoveryTopic) {
          try {
            this._client.connect({
              useSSL: this._useSSL,
              userName: username,
              password: password,
              reconnect: true,
              onSuccess: () => {
                resolve(this._uuid);
              },
              onFailure: (x, y, errorMessage) => {
                reject(`error connecting to MQTT broker: ${errorMessage}`);
              }
            });
          } catch (errorMessage) {
            reject(`error connecting to MQTT broker: ${errorMessage}`);
          }
        } else {
          reject('option `discoveryTopic` is null');
        }
      } else {
        reject('invalid token');
      }
    });
  }
  signOut() {
    return new Promise((resolve, reject) => {
      try {
        this._client.disconnect();
        resolve(this._uuid);
      } catch (errorMessage) {
        reject(errorMessage);
      }
    });
  }
  isConnected() {
    return this.#connected;
  }
  getUUID() {
    return this._uuid;
  }
  getEndpoint() {
    return this._endpoint;
  }
  getServerName() {
    return this._serverName;
  }
  getUsername() {
    return this._username;
  }
  subscribe(topic, options) {
    options = options || {};
    return new Promise((resolve, reject) => {
      try {
        this._client.subscribe(topic, {
          qos: options.qos || 0,
          timeout: options.timeout || 10000,
          onSuccess: () => {
            resolve();
          },
          onFailure: (x, y, errorMessage) => {
            reject(`error subscribing to topic \`${topic}\`: ${errorMessage}`);
          }
        });
      } catch (errorMessage) {
        reject(`error subscribing to topic \`${topic}\`: ${errorMessage}`);
      }
    });
  }
  unsubscribe(topic, options) {
    options = options || {};
    return new Promise((resolve, reject) => {
      try {
        this._client.unsubscribe(topic, {
          qos: options.qos || 0,
          timeout: options.timeout || 10000,
          onSuccess: () => {
            resolve();
          },
          onFailure: (x, y, errorMessage) => {
            reject(`error unsubscribing to topic \`${topic}\`: ${errorMessage}`);
          }
        });
      } catch (errorMessage) {
        reject(`error unsubscribing to topic \`${topic}\`: ${errorMessage}`);
      }
    });
  }
  send(topic, payload, options) {
    options = options || {};
    const token = this.#cnt++;
    const message = new paho_mqtt.Message(payload);
    message.token = token;
    message.topic = topic;
    message.qos = options.qos || 0x000;
    message.retained = options.retained || false;
    this._client.send(message);
    return token;
  }
  static #response(data, message, urlWithParameters, jsonError) {
    if (jsonError) {
      data = {
        'AMIMessage': [{
          'error': [{
            '$': data
          }]
        }]
      };
    }
    return {
      data: data,
      message: message,
      urlWithParameters: urlWithParameters
    };
  }
  execute(command, options) {
    options = options || {};
    const token = this.#cnt++;
    const params = options.params || [];
    const serverName = 'serverName' in options ? options.serverName || this._serverName : this._serverName;
    const converter = 'converter' in options ? options.converter || '' : this.#converter;
    command = (command || '').trim().replace(this.#paramRegExp, (x, y) => {
      const rawValue = params.shift();
      return Object.prototype.toString.call(rawValue) === '[object String]' ? `-${y}=${JSON.stringify(rawValue)}` : `-${y}="${JSON.stringify(rawValue)}"`;
    });
    const topic = `ami/${serverName}/command/${converter}`;
    const message = new paho_mqtt.Message(`AMI-COMMAND<${token},"${this._uuid}","${this._username}">${command}`);
    message.token = token;
    message.topic = topic;
    message.qos = options.qos || 0x000;
    message.retained = options.retained || false;
    return new Promise((resolve, reject) => {
      try {
        this._client.send(message);
      } catch (errorMessage) {
        reject(`error sending command \`${command}\`: ${errorMessage}`);
      }
      this.#L[token] = {
        resolve: resolve,
        reject: reject
      };
      setTimeout(() => {
        if (token in this.#L) {
          reject(AMIMQTTClient.#response('timeout', 'timeout', token, converter === 'AMIXmlToJson.xsl'));
          delete this.#L[token];
        }
      }, options.timeout || 10000);
    });
  }
  jspath(path, json) {
    return jspath_default().apply(path, json);
  }
  #onConnected(reconnect, endpoint) {
    this.#connected = true;
    if (reconnect) {
      console.log(`onConnected: client \`${this._uuid}\` reconnected to server \`${this._endpoint}\``);
    } else {
      console.log(`onConnected: client \`${this._uuid}\` connected to server \`${this._endpoint}\``);
    }
    this.subscribe(this._uuid).finally(() => {
      if (!this._serverName) {
        if (this._discoveryTopic) {
          this.subscribe(this._discoveryTopic).then(() => {
            if (this._triggerDiscoveryTopic) {
              this.send(this._triggerDiscoveryTopic, '{}');
            }
          });
        }
      } else {
        if (this._userOnConnected) {
          this._userOnConnected(this, reconnect, endpoint);
        }
      }
    });
  }
  #onConnectionLost(responseObject) {
    this.#connected = false;
    if (responseObject.errorCode !== 0) {
      console.log(`onConnectionLost: client \`${this._uuid}\` disconnected, cause: ${responseObject.errorMessage}`);
      if (this._userOnConnectionLost) {
        this._userOnConnectionLost(this, responseObject.errorMessage);
      }
    }
  }
  #onMessageArrived(message) {
    const m = message.payloadString.match(this.#responseRegExp);
    if (message.topic === this._discoveryTopic && !this._serverName) {
      const json = JSON.parse(message.payloadString);
      if (json['server_name']) {
        this._serverName = json['server_name'];
        if (this._userOnConnected) {
          this._userOnConnected(this, false, this._endpoint);
        }
      }
    } else if (message.topic === this._uuid && m) {
      const token = parseInt(m[1]);
      const json = m[2];
      const data = m[3];
      if (token in this.#L) {
        if (json === 'true') {
          try {
            const json = JSON.parse(data);
            const info = jspath_default().apply('.AMIMessage.info.$', json);
            const error = jspath_default().apply('.AMIMessage.error.$', json);
            if (error.length === 0) {
              this.#L[token].resolve(AMIMQTTClient.#response(json, info.join('. '), token, false));
            } else {
              this.#L[token].reject(AMIMQTTClient.#response(json, error.join('. '), token, true));
            }
          } catch (e) {
            this.#L[token].reject(AMIMQTTClient.#response('invalid JSON', 'invalid JSON', token, true));
          }
        } else {
          this.#L[token].resolve(AMIMQTTClient.#response(data, '', token, false));
        }
        delete this.#L[token];
      }
    } else {
      if (this._userOnMessageArrived) {
        this._userOnMessageArrived(this, message.topic, message.payloadString, message.qos, message.retained);
      }
    }
  }
  #onMessageDelivered(message) {
    if (this._userOnMessageDelivered) {
      this._userOnMessageDelivered(this, message.token);
    }
  }
}
if (typeof window !== 'undefined') window.AMIMQTTClient = AMIMQTTClient;
/* harmony default export */ const src_client = (AMIMQTTClient);
;// ./node_modules/ami-mqtt-client/index.js


/* harmony default export */ const ami_mqtt_client = (src_client);
;// ./src/js/AMICommand.js




class AMICommand {
  #httpClient = null;
  #mqttClient = null;
  initHttpClient(endpoint) {
    this.#httpClient = new ami_http_client(endpoint);
  }
  initMqttClient(endpoint) {
    this.#mqttClient = new ami_mqtt_client(endpoint);
  }
  getHttpEndpoint() {
    return this.#httpClient ? this.#httpClient.getEndpoint() : '';
  }
  getMqttEndpoint() {
    return this.#mqttClient ? this.#mqttClient.getEndpoint() : '';
  }
  execute(command, options) {
    const result = $.Deferred();
    const promise = typeof options === 'object' && 'mqtt' in options ? this.#mqttClient.execute(command, options) : this.#httpClient.execute(command, options);
    promise.then(response => {
      result.resolve(response.data, response.message, response.urlWithParameters);
    }).catch(response => {
      result.reject(response.data, response.message, response.urlWithParameters);
    });
    return result;
  }
  static #toDeferred(promise) {
    const result = $.Deferred();
    promise.then(response => {
      result.resolve(response.data, response.message, response.userInfo, response.roleInfo, response.bookmarkInfo, response.dashboardInfo, response.awfInfo);
    }).catch(response => {
      result.reject(response.data, response.message, response.userInfo, response.roleInfo, response.bookmarkInfo, response.dashboardInfo, response.awfInfo);
    });
    return result;
  }
  mqttSignInByToken(token, serverName, options) {
    return AMICommand.#toDeferred(this.#mqttClient.signInByToken(token, serverName));
  }
  mqttSignOut(options) {
    return AMICommand.#toDeferred(this.#mqttClient.signOut(options));
  }
  signInByCode(code, options) {
    return AMICommand.#toDeferred(this.#httpClient.signInByCode(code, options));
  }
  signInByToken(token, options) {
    return AMICommand.#toDeferred(this.#httpClient.signInByToken(token, options));
  }
  signInByPassword(username, password, options) {
    return AMICommand.#toDeferred(this.#httpClient.signInByPassword(username, password, options));
  }
  signInByCertificate(options) {
    return AMICommand.#toDeferred(this.#httpClient.signInByCertificate(options));
  }
  signOut(options) {
    return AMICommand.#toDeferred(this.#httpClient.signOut(options)).always(() => {});
  }
  attachCertificate(options) {
    options = options || {};
    return this.execute('GetSessionInfo -attachCert', options);
  }
  detachCertificate(options) {
    options = options || {};
    return this.execute('GetSessionInfo -detachCert', options);
  }
  addUser(username, password, firstName, lastName, email, captchaHash, captchaText, attachCert, agree, options) {
    options = options || {};
    options.params = [username, password, firstName, lastName, email, captchaHash, captchaText];
    return this.execute(`AddUser -amiLogin=? -amiPassword=? -firstName=? -lastName=? -email=? -captchaHash=? -captchaText=? ${attachCert ? ' -attachCert' : ''}${agree ? ' -agree' : ''}`, options);
  }
  changeInfo(firstName, lastName, email, options) {
    options = options || {};
    options.params = [firstName, lastName, email];
    return this.execute('SetUserInfo -firstName=? -lastName=? -email=?', options);
  }
  changePassword(username, oldPassword, newPassword, options) {
    options = options || {};
    options.params = [username, oldPassword, newPassword];
    return this.execute('ChangePassword -amiLogin=? -amiPasswordOld=? -amiPasswordNew=?', options);
  }
  resetPassword(username, captchaHash, captchaText, options) {
    options = options || {};
    options.params = [username, captchaHash, captchaText];
    return this.execute('ResetPassword -amiLogin=? -captchaHash=? -captchaText=?', options);
  }
}
/* harmony default export */ const js_AMICommand = (new AMICommand());
// EXTERNAL MODULE: ./node_modules/ami-twig/index.js
var ami_twig = __webpack_require__(3154);
;// ./src/js/utilities/tools.js



function _internal_then(deferred, doneCallback, failCallback) {
  if (deferred && deferred.then) {
    deferred.then(doneCallback, failCallback);
  } else {
    doneCallback();
  }
}
function _internal_always(deferred, alwaysCallback) {
  if (deferred && deferred.always) {
    deferred.always(alwaysCallback);
  } else {
    alwaysCallback();
  }
}
function typeOf(x) {
  const name = Object.prototype.toString.call(x);
  return name.startsWith('[object ') ? name.substring(8, name.length - 1) : '';
}
function isString(x) {
  return ami_twig/* default */.A.stdlib.isString(x);
}
function isArray(x) {
  return ami_twig/* default */.A.stdlib.isArray(x);
}
function isObject(x) {
  return ami_twig/* default */.A.stdlib.isObject(x);
}
function isSet(x) {
  return ami_twig/* default */.A.stdlib.isSet(x);
}
function isMap(x) {
  return ami_twig/* default */.A.stdlib.isMap(x);
}
function asArray(x) {
  return Array.isArray(x) ? x : [x];
}
function setupParams(immutables, defaults, options) {
  const result = {};
  if (options) {
    for (var _i = 0, _Object$entries = Object.entries(options); _i < _Object$entries.length; _i++) {
      let [key, val] = _Object$entries[_i];
      result[key] = val;
    }
  }
  if (defaults) {
    for (var _i2 = 0, _Object$entries2 = Object.entries(defaults); _i2 < _Object$entries2.length; _i2++) {
      let [key, val] = _Object$entries2[_i2];
      if (!(key in result)) {
        result[key] = val;
      }
    }
  }
  if (immutables) {
    for (var _i3 = 0, _Object$entries3 = Object.entries(immutables); _i3 < _Object$entries3.length; _i3++) {
      let [key, val] = _Object$entries3[_i3];
      result[key] = val;
    }
  }
  return result;
}
function setup(optionNames, optionDefaults, options) {
  const result = [];
  const l = optionNames.length;
  const m = optionDefaults.length;
  if (l !== m) {
    throw 'internal error';
  }
  if (options) {
    for (let i = 0; i < l; i++) {
      result.push(optionNames[i] in options ? options[optionNames[i]] : optionDefaults[i]);
    }
  } else {
    for (let i = 0; i < l; i++) {
      result.push(optionDefaults[i]);
    }
  }
  return result;
}
;// ./src/js/AMIRouter.js

function _createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

class AMIRouter {
  #webAppURL = '';
  #webAppArgs = {};
  #webAppHash = '';
  #scriptURL = '';
  #scriptArgs = {};
  #scriptHash = '';
  #originURL = '';
  #routes = [];
  constructor(prodJsFilename, devJsFilename) {
    const webappUrl = new URL(window.location);
    const scriptUrl = AMIRouter.#findThisJs(prodJsFilename, devJsFilename);
    if (!scriptUrl) {
      throw `cannot find neither '${prodJsFilename}' nor '${devJsFilename}'`;
    }
    this.#webAppURL = webappUrl.protocol === 'file:' ? `file://${webappUrl.pathname}` : `${webappUrl.origin}${webappUrl.pathname}`;
    this.#webAppArgs = AMIRouter.#searchParamToDict(webappUrl);
    this.#webAppHash = webappUrl.hash.substring(1);
    this.#scriptURL = scriptUrl.protocol === 'file:' ? `file://${scriptUrl.pathname}` : `${scriptUrl.origin}${scriptUrl.pathname}`;
    this.#scriptArgs = AMIRouter.#searchParamToDict(scriptUrl);
    this.#scriptHash = scriptUrl.hash.substring(1);
    let idx;
    if ((idx = this.#scriptURL.indexOf(prodJsFilename)) > 0) {
      this.#originURL = AMIRouter.#eatSlashes(this.#scriptURL.substring(0, idx));
    } else if ((idx = this.#scriptURL.indexOf(devJsFilename)) > 0) {
      this.#originURL = AMIRouter.#eatSlashes(this.#scriptURL.substring(0, idx));
    }
  }
  static #findThisJs(prodJsFilename, devJsFilename) {
    const scripts = document.getElementsByTagName('script');
    for (let i = 0; i < scripts.length; i++) {
      try {
        const url = new URL(scripts[i].src);
        if (url.pathname.endsWith(prodJsFilename) > 0 || url.pathname.endsWith(devJsFilename) > 0) {
          return url;
        }
      } catch (e) {}
    }
    return null;
  }
  static #searchParamToDict(url) {
    const result = {};
    for (var _iterator = _createForOfIteratorHelperLoose(url.searchParams.entries()), _step; !(_step = _iterator()).done;) {
      const [name, value] = _step.value;
      result[name] = value;
    }
    return result;
  }
  static #eatSlashes(url) {
    url = url.trim();
    while (url[url.length - 1] === '/') {
      url = url.substring(0, url.length - 1);
    }
    return url;
  }
  getWebAppURL() {
    return this.#webAppURL;
  }
  getWebAppArgs() {
    return this.#webAppArgs;
  }
  getWebAppHash() {
    return this.#webAppHash;
  }
  getScriptURL() {
    return this.#scriptURL;
  }
  getScriptArgs() {
    return this.#scriptArgs;
  }
  getWebappHash() {
    return this.#scriptHash;
  }
  getOriginURL() {
    return this.#originURL;
  }
  append(regExp, callback) {
    this.#routes.unshift({
      regExp: regExp,
      callback: callback
    });
    return this;
  }
  remove(regExp) {
    this.#routes = this.#routes.filter(route => {
      return route.regExp.toString() !== regExp.toString();
    });
    return this;
  }
  check() {
    let m;
    for (let i = 0; i < this.#routes.length; i++) {
      m = this.#webAppHash.match(this.#routes[i].regExp);
      if (m) {
        this.#routes[i].callback.apply(this, m);
        return true;
      }
    }
    return false;
  }
  #buildURL(searchParams, hash) {
    const result = new URL(this.#webAppURL);
    for (var _i = 0, _Object$entries = Object.entries(searchParams); _i < _Object$entries.length; _i++) {
      const [name, value] = _Object$entries[_i];
      if (typeof value === 'string') {
        result.searchParams.set(name, value);
      }
    }
    if (hash) {
      result.hash = hash;
    }
    return result;
  }
  #goto(hash) {
    if (hash) {
      setTimeout(() => {
        const el = $(hash);
        if (el.length > 0) {
          $(document).scrollTop(el.offset().top);
        }
      }, 1000);
    }
  }
  appendHistoryEntry(options) {
    if (history.pushState) {
      const [context, searchParams, hash] = setup(['context', 'searchParams', 'hash'], [{}, {}, null], options);
      const url = this.#buildURL(searchParams, hash);
      if (window.location !== url.toString()) {
        history.pushState(context, null, url.toString());
      }
      this.#goto(url.hash);
      return true;
    }
    return false;
  }
  replaceHistoryEntry(options) {
    if (history.replaceState) {
      const [context, searchParams, hash] = setup(['context', 'searchParams', 'hash'], [{}, {}, null], options);
      const url = this.#buildURL(searchParams, hash);
      if (window.location !== url.toString()) {
        history.replaceState(context, null, url.toString());
      }
      this.#goto(url.hash);
      return true;
    }
    return false;
  }
}
/* harmony default export */ const js_AMIRouter = (new AMIRouter('js/ami.min.js', 'js/ami.js'));
;// ./src/js/utilities/locks.js

function _throwError() {
  throw Error();
}
function getStack() {
  try {
    _throwError();
  } catch (e1) {
    try {
      return e1.stack;
    } catch (e2) {
      return '';
    }
  }
}
let _curLockCnt = 0;
let _tmpLockCnt = 0;
function lock() {
  let lines = getStack().split('\n');
  if (lines.length > 3) {
    console.log(`lock[${_curLockCnt}] :: ${lines[3]}`);
  }
  if (_curLockCnt <= 0) {
    $('#ami_locker').css('display', 'flex');
    _curLockCnt = 1;
  } else {
    _curLockCnt++;
  }
}
function unlock() {
  if (_curLockCnt <= 1) {
    $('#ami_locker').css('display', 'none');
    _curLockCnt = 0;
  } else {
    _curLockCnt--;
  }
  let lines = getStack().split('\n');
  if (lines.length > 3) {
    console.log(`unlock[${_curLockCnt}] :: ${lines[3]}`);
  }
}
function modalLeave() {
  const lines = getStack().split('\n');
  if (lines.length > 2) {
    console.log(`modalLock[${_curLockCnt}] :: ${lines[2]}`);
  }
  _curLockCnt = _tmpLockCnt;
  if (_curLockCnt > 0) {
    $('#ami_locker').css('display', 'flex');
  }
}
function modalEnter() {
  _tmpLockCnt = _curLockCnt;
  if (_curLockCnt > 0) {
    $('#ami_locker').css('display', 'none');
  }
  const lines = getStack().split('\n');
  if (lines.length > 2) {
    console.log(`modalUnlock[${_curLockCnt}] :: ${lines[2]}`);
  }
}
let _canLeave = true;
function canLeave(canLeave) {
  _canLeave = canLeave;
}
;// ./src/js/utilities/strings.js



function base64Encode(s) {
  return btoa(encodeURIComponent(s || '').replace(/%([0-9A-F]{2})/g, (_, $1) => {
    return String.fromCharCode(parseInt($1, 16));
  })).replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
}
function base64Decode(s) {
  return decodeURIComponent(atob((s || '').replace(/-/g, '+').replace(/_/g, '/')).split('').map(c => {
    return `%${`00${c.charCodeAt(0).toString(16)}`.slice(-2)}`;
  }).join(''));
}
const _replace = ami_twig/* default */.A.stdlib._replace;
const _textToHtmlX = ['&', '"', '<', '>'];
const _textToHtmlY = ['&amp;', '&quot;', '&lt;', '&gt;'];
function textToHtml(s) {
  return _replace(s || '', _textToHtmlX, _textToHtmlY);
}
function htmlToText(s) {
  return _replace(s || '', _textToHtmlY, _textToHtmlX);
}
const _textToStringX = ['\\', '\r', '\n', '"', '\''];
const _textToStringY = ['\\\\', '\\r', '\\n', '\\"', '\\\''];
function textToString(s) {
  return _replace(s || '', _textToStringX, _textToStringY);
}
function stringToText(s) {
  return _replace(s || '', _textToStringY, _textToStringX);
}
const _htmlToStringX = ['\\', '\r', '\n', '&quot;', '\''];
const _htmlToStringY = ['\\\\', '\\r', '\\n', '\\&quot;', '\\\''];
function htmlToString(s) {
  return _replace(s || '', _htmlToStringX, _htmlToStringY);
}
function stringToHtml(s) {
  return _replace(s || '', _htmlToStringY, _htmlToStringX);
}
const _textToSQLX = ['\''];
const _textToSQLY = ['\'\''];
function textToSQL(s) {
  return _replace(s || '', _textToSQLX, _textToSQLY);
}
function sqlToText(s) {
  return _replace(s || '', _textToSQLY, _textToSQLX);
}
;// ./src/twigs/message.twig
const message_namespaceObject = "<div class=\"toast mb-2\" role=\"alert\" {% if fadeOut %}data-bs-delay=\"60000\" {% else %}data-bs-autohide=\"false\"{% endif %} data-ami-hash=\"{{ hash }}\" data-ami-cnt=\"1\">\n\t<div class=\"toast-header py-1\">\n\t\t<strong class=\"me-auto text-{{ clazz|e }}\">{{ title|e }}</strong>\n\t\t<small>{{ date|e }}</small>\n\t\t<button class=\"btn btn-link text-muted p-0 ms-2\" type=\"button\" data-bs-dismiss=\"toast\">\n\t\t\t<i class=\"bi bi-x-circle\"></i>\n\t\t</button>\n\t</div>\n\t<div class=\"toast-body\">\n\t\t{{ message|e }}\n\t</div>\n</div>\n";
;// ./src/js/utilities/messages.js






const _linkExp = /\[\s*([^\s\]]*)\s*\]\(\s*([^\s\)]*)\s*\)(?:\{\s*([^\s\)]*)\s*\})?/g;
function _publishAlert(clazz, title, message, fadeOut) {
  if (Array.isArray(message)) {
    message = message.map(MESSAGE => (MESSAGE || '').toString()).join('. ');
  } else {
    message = (message || '').toString();
  }
  const hash = message.hashCode();
  const date = moment().format('DD MMM, HH:mm:ss');
  const toast = $(`#ami_alert_content > .toast[data-ami-hash="${hash}"]`);
  if (toast.length === 0) {
    const html = formatTWIG(message_namespaceObject, {
      date: date,
      hash: hash,
      clazz: clazz,
      title: title,
      fadeOut: fadeOut,
      message: message
    });
    $('#ami_alert_content').append(html.replace(_linkExp, (_, g1, g2, g3) => `<a href="${g1}" ${g3 || 'target="_blank"'}>${g2}</a>`)).promise().done(() => {
      $(`#ami_alert_content > .toast[data-ami-hash="${hash}"]`).toast('show');
    });
  } else {
    toast.find('.toast-header > strong').html(textToHtml(title) + ` <span class="badge badge-${clazz}">${toast.attr('data-ami-cnt', parseInt(toast.attr('data-ami-cnt')) + 1).attr('data-ami-cnt')}</span>`);
    toast.find('.toast-header > small').html(textToHtml(date));
    toast.toast('show');
  }
  console.log(`AMI :: ${title.toUpperCase()}: ${message}\n${getStack()}`);
  $(document).scrollTop(0);
  unlock();
}
function info(message, fadeOut) {
  _publishAlert('info', 'Info', message, fadeOut);
}
function success(message, fadeOut) {
  _publishAlert('success', 'Success', message, fadeOut);
}
function warning(message, fadeOut) {
  _publishAlert('warning', 'Warning', message, fadeOut);
}
function error(message, fadeOut) {
  _publishAlert('danger', 'Error', message, fadeOut);
}
function flush() {
  $('#ami_alert_content').empty();
}
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js
var injectStylesIntoStyleTag = __webpack_require__(5072);
var injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js
var styleDomAPI = __webpack_require__(7825);
var styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js
var insertBySelector = __webpack_require__(7659);
var insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js
var setAttributesWithoutAttributes = __webpack_require__(5056);
var setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js
var insertStyleElement = __webpack_require__(540);
var insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);
// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js
var styleTagTransform = __webpack_require__(1113);
var styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);
// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[4].use[2]!./node_modules/flatpickr/dist/flatpickr.min.css
var flatpickr_min = __webpack_require__(2211);
;// ./node_modules/flatpickr/dist/flatpickr.min.css

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (styleTagTransform_default());
options.setAttributes = (setAttributesWithoutAttributes_default());
options.insert = insertBySelector_default().bind(null, "head");
options.domAPI = (styleDomAPI_default());
options.insertStyleElement = (insertStyleElement_default());

var update = injectStylesIntoStyleTag_default()(flatpickr_min/* default */.A, options);




       /* harmony default export */ const dist_flatpickr_min = (flatpickr_min/* default */.A && flatpickr_min/* default */.A.locals ? flatpickr_min/* default */.A.locals : undefined);

;// ./node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange", "onPreCalendarPosition"];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function (err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function (givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: undefined,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};
;// ./node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  },
  months: {
    shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function (nth) {
    var s = nth % 100;
    if (s > 3 && s < 21) return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
/* harmony default export */ const l10n_default = (english);
;// ./node_modules/flatpickr/dist/esm/utils/index.js
var pad = function (number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var utils_int = function (bool) {
  return bool === true ? 1 : 0;
};
function debounce(fn, wait) {
  var t;
  return function () {
    var _this = this;
    var args = arguments;
    clearTimeout(t);
    t = setTimeout(function () {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function (obj) {
  return obj instanceof Array ? obj : [obj];
};
;// ./node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass(elem, className, bool) {
  if (bool === true) return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e.className = className;
  if (content !== undefined) e.textContent = content;
  return e;
}
function clearNode(node) {
  while (node.firstChild) node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node)) return node;else if (node.parentNode) return findParent(node.parentNode, condition);
  return undefined;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"),
    numInput = createElement("input", "numInput " + inputClassName),
    arrowUp = createElement("span", "arrowUp"),
    arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== undefined) for (var key in opts) numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error) {
    return event.target;
  }
}
;// ./node_modules/flatpickr/dist/esm/utils/formatting.js

var doNothing = function () {
  return undefined;
};
var monthToStr = function (monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function (dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function (dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function (dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function (dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * utils_int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function (dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function (dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function (_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1000);
  },
  W: function (dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function (dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function (_, ISODate) {
    return new Date(ISODate);
  },
  d: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function (dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function (dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function (dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function (dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function (dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function (dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function (_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function (dateObj, year) {
    dateObj.setFullYear(2000 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function (date) {
    return date.toISOString();
  },
  D: function (date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function (date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function (date, locale, options) {
    return pad(formats.h(date, locale, options));
  },
  H: function (date) {
    return pad(date.getHours());
  },
  J: function (date, locale) {
    return locale.ordinal !== undefined ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function (date, locale) {
    return locale.amPM[utils_int(date.getHours() > 11)];
  },
  M: function (date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function (date) {
    return pad(date.getSeconds());
  },
  U: function (date) {
    return date.getTime() / 1000;
  },
  W: function (date, _, options) {
    return options.getWeek(date);
  },
  Y: function (date) {
    return pad(date.getFullYear(), 4);
  },
  d: function (date) {
    return pad(date.getDate());
  },
  h: function (date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function (date) {
    return pad(date.getMinutes());
  },
  j: function (date) {
    return date.getDate();
  },
  l: function (date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function (date) {
    return pad(date.getMonth() + 1);
  },
  n: function (date) {
    return date.getMonth() + 1;
  },
  s: function (date) {
    return date.getSeconds();
  },
  u: function (date) {
    return date.getTime();
  },
  w: function (date) {
    return date.getDay();
  },
  y: function (date) {
    return String(date.getFullYear()).substring(2);
  }
};
;// ./node_modules/flatpickr/dist/esm/utils/dates.js



var createDateFormatter = function (_a) {
  var _b = _a.config,
    config = _b === void 0 ? defaults : _b,
    _c = _a.l10n,
    l10n = _c === void 0 ? english : _c,
    _d = _a.isMobile,
    isMobile = _d === void 0 ? false : _d;
  return function (dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n;
    if (config.formatDate !== undefined && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function (c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function (_a) {
  var _b = _a.config,
    config = _b === void 0 ? defaults : _b,
    _c = _a.l10n,
    l10n = _c === void 0 ? english : _c;
  return function (date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date) return undefined;
    var locale = customLocale || l10n;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date) parsedDate = new Date(date.getTime());else if (typeof date !== "string" && date.toFixed !== undefined) parsedDate = new Date(date);else if (typeof date === "string") {
      var format = givenFormat || (config || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0,
          ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match = new RegExp(regexStr).exec(date);
            if (match && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match[++matchIndex]
              });
            }
          } else if (!isBackSlash) regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));
        ops.forEach(function (_a) {
          var fn = _a.fn,
            val = _a.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : undefined;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return undefined;
    }
    if (timeless === true) parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
function compareTimes(date1, date2) {
  return 3600 * (date1.getHours() - date2.getHours()) + 60 * (date1.getMinutes() - date2.getMinutes()) + date1.getSeconds() - date2.getSeconds();
}
var isBetween = function (ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function (hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function (secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600),
    minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 86400000
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== undefined) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds) seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== undefined) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr) minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes) seconds = config.maxDate.getSeconds();
  }
  return {
    hours: hours,
    minutes: minutes,
    seconds: seconds
  };
}
// EXTERNAL MODULE: ./node_modules/flatpickr/dist/esm/utils/polyfills.js
var polyfills = __webpack_require__(5252);
;// ./node_modules/flatpickr/dist/esm/index.js
var __assign = undefined && undefined.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __spreadArrays = undefined && undefined.__spreadArrays || function () {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
  return r;
};







var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self = {
    config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
    l10n: l10n_default
  };
  self.parseDate = createDateParser({
    config: self.config,
    l10n: self.l10n
  });
  self._handlers = [];
  self.pluginElements = [];
  self.loadedPlugins = [];
  self._bind = bind;
  self._setHoursFromDate = setHoursFromDate;
  self._positionCalendar = positionCalendar;
  self.changeMonth = changeMonth;
  self.changeYear = changeYear;
  self.clear = clear;
  self.close = close;
  self.onMouseOver = onMouseOver;
  self._createElement = createElement;
  self.createDay = createDay;
  self.destroy = destroy;
  self.isEnabled = isEnabled;
  self.jumpToDate = jumpToDate;
  self.updateValue = updateValue;
  self.open = open;
  self.redraw = redraw;
  self.set = set;
  self.setDate = setDate;
  self.toggle = toggle;
  function setupHelperFunctions() {
    self.utils = {
      getDaysInMonth: function (month, yr) {
        if (month === void 0) {
          month = self.currentMonth;
        }
        if (yr === void 0) {
          yr = self.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;
        return self.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self.element = self.input = element;
    self.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self.isMobile) build();
    bindEvents();
    if (self.selectedDates.length || self.config.noCalendar) {
      if (self.config.enableTime) {
        setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self.isMobile && isSafari) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self);
  }
  function setCalendarWidth() {
    var config = self.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function () {
        if (self.calendarContainer !== undefined) {
          self.calendarContainer.style.visibility = "hidden";
          self.calendarContainer.style.display = "block";
        }
        if (self.daysContainer !== undefined) {
          var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
          self.daysContainer.style.width = daysWidth + "px";
          self.calendarContainer.style.width = daysWidth + (self.weekWrapper !== undefined ? self.weekWrapper.offsetWidth : 0) + "px";
          self.calendarContainer.style.removeProperty("visibility");
          self.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e) {
    if (self.selectedDates.length === 0) {
      var defaultDate = self.config.minDate === undefined || compareDates(new Date(), self.config.minDate) >= 0 ? new Date() : new Date(self.config.minDate.getTime());
      var defaults = getDefaultHours(self.config);
      defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
      self.selectedDates = [defaultDate];
      self.latestSelectedDateObj = defaultDate;
    }
    if (e !== undefined && e.type !== "blur") {
      timeWrapper(e);
    }
    var prevValue = self._input.value;
    setHoursFromInputs();
    updateValue();
    if (self._input.value !== prevValue) {
      self._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * utils_int(amPM === self.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self.hourElement === undefined || self.minuteElement === undefined) return;
    var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24,
      minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
      seconds = self.secondElement !== undefined ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;
    if (self.amPM !== undefined) {
      hours = ampm2military(hours, self.amPM.textContent);
    }
    var limitMinHours = self.config.minTime !== undefined || self.config.minDate && self.minDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.minDate, true) === 0;
    var limitMaxHours = self.config.maxTime !== undefined || self.config.maxDate && self.maxDateHasTime && self.latestSelectedDateObj && compareDates(self.latestSelectedDateObj, self.config.maxDate, true) === 0;
    if (self.config.maxTime !== undefined && self.config.minTime !== undefined && self.config.minTime > self.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self.config.maxTime !== undefined ? self.config.maxTime : self.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours()) minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes()) seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self.config.minTime !== undefined ? self.config.minTime : self.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes()) minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes()) seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self.latestSelectedDateObj !== undefined) {
      self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self.hourElement || !self.minuteElement || self.isMobile) return;
    self.hourElement.value = pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * utils_int(hours % 12 === 0) : hours);
    self.minuteElement.value = pad(minutes);
    if (self.amPM !== undefined) self.amPM.textContent = self.l10n.amPM[utils_int(hours >= 12)];
    if (self.secondElement !== undefined) self.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1000 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element, event, handler, options) {
    if (event instanceof Array) return event.forEach(function (ev) {
      return bind(element, ev, handler, options);
    });
    if (element instanceof Array) return element.forEach(function (el) {
      return bind(el, event, handler, options);
    });
    element.addEventListener(event, handler, options);
    self._handlers.push({
      remove: function () {
        return element.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function (evt) {
        Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
          return bind(el, "click", self[evt]);
        });
      });
    }
    if (self.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce(onResize, 50);
    self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent)) bind(self.daysContainer, "mouseover", function (e) {
      if (self.config.mode === "range") onMouseOver(getEventTarget(e));
    });
    bind(self._input, "keydown", onKeyDown);
    if (self.calendarContainer !== undefined) {
      bind(self.calendarContainer, "keydown", onKeyDown);
    }
    if (!self.config.inline && !self.config.static) bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);else bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, {
      capture: true
    });
    if (self.config.clickOpens === true) {
      bind(self._input, "focus", self.open);
      bind(self._input, "click", self.open);
    }
    if (self.daysContainer !== undefined) {
      bind(self.monthNav, "click", onMonthNavClick);
      bind(self.monthNav, ["keyup", "increment"], onYearInput);
      bind(self.daysContainer, "click", selectDate);
    }
    if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined) {
      var selText = function (e) {
        return getEventTarget(e).select();
      };
      bind(self.timeContainer, ["increment"], updateTime);
      bind(self.timeContainer, "blur", updateTime, {
        capture: true
      });
      bind(self.timeContainer, "click", timeIncrement);
      bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
      if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
        return self.secondElement && self.secondElement.select();
      });
      if (self.amPM !== undefined) {
        bind(self.amPM, "click", function (e) {
          updateTime(e);
        });
      }
    }
    if (self.config.allowInput) {
      bind(self._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange) {
    var jumpTo = jumpDate !== undefined ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate && self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);
    var oldYear = self.currentYear;
    var oldMonth = self.currentMonth;
    try {
      if (jumpTo !== undefined) {
        self.currentYear = jumpTo.getFullYear();
        self.currentMonth = jumpTo.getMonth();
      }
    } catch (e) {
      e.message = "Invalid date supplied: " + jumpTo;
      self.config.errorHandler(e);
    }
    if (triggerChange && self.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange && (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self.redraw();
  }
  function timeIncrement(e) {
    var eventTarget = getEventTarget(e);
    if (~eventTarget.className.indexOf("arrow")) incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e, delta, inputElem) {
    var target = e && getEventTarget(e);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self.calendarContainer = createElement("div", "flatpickr-calendar");
    self.calendarContainer.tabIndex = -1;
    if (!self.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self.config.weekNumbers) {
        var _a = buildWeeks(),
          weekWrapper = _a.weekWrapper,
          weekNumbers = _a.weekNumbers;
        self.innerContainer.appendChild(weekWrapper);
        self.weekNumbers = weekNumbers;
        self.weekWrapper = weekWrapper;
      }
      self.rContainer = createElement("div", "flatpickr-rContainer");
      self.rContainer.appendChild(buildWeekdays());
      if (!self.daysContainer) {
        self.daysContainer = createElement("div", "flatpickr-days");
        self.daysContainer.tabIndex = -1;
      }
      buildDays();
      self.rContainer.appendChild(self.daysContainer);
      self.innerContainer.appendChild(self.rContainer);
      fragment.appendChild(self.innerContainer);
    }
    if (self.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
    toggleClass(self.calendarContainer, "animate", self.config.animate === true);
    toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
    self.calendarContainer.appendChild(fragment);
    var customAppend = self.config.appendTo !== undefined && self.config.appendTo.nodeType !== undefined;
    if (self.config.inline || self.config.static) {
      self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
      if (self.config.inline) {
        if (!customAppend && self.element.parentNode) self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);else if (self.config.appendTo !== undefined) self.config.appendTo.appendChild(self.calendarContainer);
      }
      if (self.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self.element.parentNode) self.element.parentNode.insertBefore(wrapper, self.element);
        wrapper.appendChild(self.element);
        if (self.altInput) wrapper.appendChild(self.altInput);
        wrapper.appendChild(self.calendarContainer);
      }
    }
    if (!self.config.static && !self.config.inline) (self.config.appendTo !== undefined ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true),
      dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self.now) === 0) {
      self.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self.selectedDateElem = dayElement;
        if (self.config.mode === "range") {
          toggleClass(dayElement, "startRange", self.selectedDates[0] && compareDates(date, self.selectedDates[0], true) === 0);
          toggleClass(dayElement, "endRange", self.selectedDates[1] && compareDates(date, self.selectedDates[1], true) === 0);
          if (className === "nextMonthDay") dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");
    }
    if (self.weekNumbers && self.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self.config.mode === "range") onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj)) return c;
      }
    }
    return undefined;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self.currentMonth;
    var endMonth = delta > 0 ? self.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
      var month = self.daysContainer.children[m];
      var startIndex = givenMonth - self.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta)) return focusOnDayElem(c);
      }
    }
    self.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return undefined;
  }
  function focusOnDay(current, offset) {
    var activeElement = getClosestActiveElement();
    var dayFocused = isInView(activeElement || document.body);
    var startElem = current !== undefined ? current : dayFocused ? activeElement : self.selectedDateElem !== undefined && isInView(self.selectedDateElem) ? self.selectedDateElem : self.todayDateElem !== undefined && isInView(self.todayDateElem) ? self.todayDateElem : getFirstAvailableDay(offset > 0 ? 1 : -1);
    if (startElem === undefined) {
      self._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self.utils.getDaysInMonth(month, year),
      days = window.document.createDocumentFragment(),
      isMultiMonth = self.config.showMonths > 1,
      prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay",
      nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth,
      dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self.daysContainer === undefined) {
      return;
    }
    clearNode(self.daysContainer);
    if (self.weekNumbers) clearNode(self.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self.config.showMonths; i++) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self.daysContainer.appendChild(frag);
    self.days = self.daysContainer.firstChild;
    if (self.config.mode === "range" && self.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self.config.showMonths > 1 || self.config.monthSelectorType !== "dropdown") return;
    var shouldBuildMonth = function (month) {
      if (self.config.minDate !== undefined && self.currentYear === self.config.minDate.getFullYear() && month < self.config.minDate.getMonth()) {
        return false;
      }
      return !(self.config.maxDate !== undefined && self.currentYear === self.config.maxDate.getFullYear() && month > self.config.maxDate.getMonth());
    };
    self.monthsDropdownContainer.tabIndex = -1;
    self.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i)) continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
      month.tabIndex = -1;
      if (self.currentMonth === i) {
        month.selected = true;
      }
      self.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
      bind(self.monthsDropdownContainer, "change", function (e) {
        var target = getEventTarget(e);
        var selectedMonth = parseInt(target.value, 10);
        self.changeMonth(selectedMonth - self.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", {
      tabindex: "-1"
    });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
    if (self.config.minDate) {
      yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
    }
    if (self.config.maxDate) {
      yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container: container,
      yearElement: yearElement,
      monthElement: monthElement
    };
  }
  function buildMonths() {
    clearNode(self.monthNav);
    self.monthNav.appendChild(self.prevMonthNav);
    if (self.config.showMonths) {
      self.yearElements = [];
      self.monthElements = [];
    }
    for (var m = self.config.showMonths; m--;) {
      var month = buildMonth();
      self.yearElements.push(month.yearElement);
      self.monthElements.push(month.monthElement);
      self.monthNav.appendChild(month.container);
    }
    self.monthNav.appendChild(self.nextMonthNav);
  }
  function buildMonthNav() {
    self.monthNav = createElement("div", "flatpickr-months");
    self.yearElements = [];
    self.monthElements = [];
    self.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self.prevMonthNav.innerHTML = self.config.prevArrow;
    self.nextMonthNav = createElement("span", "flatpickr-next-month");
    self.nextMonthNav.innerHTML = self.config.nextArrow;
    buildMonths();
    Object.defineProperty(self, "_hidePrevMonthArrow", {
      get: function () {
        return self.__hidePrevMonthArrow;
      },
      set: function (bool) {
        if (self.__hidePrevMonthArrow !== bool) {
          toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
          self.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self, "_hideNextMonthArrow", {
      get: function () {
        return self.__hideNextMonthArrow;
      },
      set: function (bool) {
        if (self.__hideNextMonthArrow !== bool) {
          toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
          self.__hideNextMonthArrow = bool;
        }
      }
    });
    self.currentYearElement = self.yearElements[0];
    updateNavigationCurrentMonth();
    return self.monthNav;
  }
  function buildTime() {
    self.calendarContainer.classList.add("hasTime");
    if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
    var defaults = getDefaultHours(self.config);
    self.timeContainer = createElement("div", "flatpickr-time");
    self.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self.l10n.hourAriaLabel
    });
    self.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self.l10n.minuteAriaLabel
    });
    self.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
    self.hourElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.time_24hr ? defaults.hours : military2ampm(defaults.hours));
    self.minuteElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : defaults.minutes);
    self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
    self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
    self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
    self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
    self.hourElement.setAttribute("maxlength", "2");
    self.minuteElement.setAttribute("min", "0");
    self.minuteElement.setAttribute("max", "59");
    self.minuteElement.setAttribute("maxlength", "2");
    self.timeContainer.appendChild(hourInput);
    self.timeContainer.appendChild(separator);
    self.timeContainer.appendChild(minuteInput);
    if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");
    if (self.config.enableSeconds) {
      self.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self.secondElement = secondInput.getElementsByTagName("input")[0];
      self.secondElement.value = pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : defaults.seconds);
      self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
      self.secondElement.setAttribute("min", "0");
      self.secondElement.setAttribute("max", "59");
      self.secondElement.setAttribute("maxlength", "2");
      self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self.timeContainer.appendChild(secondInput);
    }
    if (!self.config.time_24hr) {
      self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[utils_int((self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11)]);
      self.amPM.title = self.l10n.toggleTitle;
      self.amPM.tabIndex = -1;
      self.timeContainer.appendChild(self.amPM);
    }
    return self.timeContainer;
  }
  function buildWeekdays() {
    if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");else clearNode(self.weekdayContainer);
    for (var i = self.config.showMonths; i--;) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self.config.showMonths; i--;) {
      self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper: weekWrapper,
      weekNumbers: weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self.currentMonth;
    if (delta < 0 && self._hidePrevMonthArrow === true || delta > 0 && self._hideNextMonthArrow === true) return;
    self.currentMonth += delta;
    if (self.currentMonth < 0 || self.currentMonth > 11) {
      self.currentYear += self.currentMonth > 11 ? 1 : -1;
      self.currentMonth = (self.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self.input.value = "";
    if (self.altInput !== undefined) self.altInput.value = "";
    if (self.mobileInput !== undefined) self.mobileInput.value = "";
    self.selectedDates = [];
    self.latestSelectedDateObj = undefined;
    if (toInitial === true) {
      self.currentYear = self._initialDate.getFullYear();
      self.currentMonth = self._initialDate.getMonth();
    }
    if (self.config.enableTime === true) {
      var _a = getDefaultHours(self.config),
        hours = _a.hours,
        minutes = _a.minutes,
        seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self.redraw();
    if (triggerChangeEvent) triggerEvent("onChange");
  }
  function close() {
    self.isOpen = false;
    if (!self.isMobile) {
      if (self.calendarContainer !== undefined) {
        self.calendarContainer.classList.remove("open");
      }
      if (self._input !== undefined) {
        self._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self.config !== undefined) triggerEvent("onDestroy");
    for (var i = self._handlers.length; i--;) {
      self._handlers[i].remove();
    }
    self._handlers = [];
    if (self.mobileInput) {
      if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
      self.mobileInput = undefined;
    } else if (self.calendarContainer && self.calendarContainer.parentNode) {
      if (self.config.static && self.calendarContainer.parentNode) {
        var wrapper = self.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild) wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else self.calendarContainer.parentNode.removeChild(self.calendarContainer);
    }
    if (self.altInput) {
      self.input.type = "text";
      if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
      delete self.altInput;
    }
    if (self.input) {
      self.input.type = self.input._type;
      self.input.classList.remove("flatpickr-input");
      self.input.removeAttribute("readonly");
    }
    ["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "monthsDropdownContainer", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
      try {
        delete self[k];
      } catch (_) {}
    });
  }
  function isCalendarElem(elem) {
    return self.calendarContainer.contains(elem);
  }
  function documentClick(e) {
    if (self.isOpen && !self.config.inline) {
      var eventTarget_1 = getEventTarget(e);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput = eventTarget_1 === self.input || eventTarget_1 === self.altInput || self.element.contains(eventTarget_1) || e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));
      var lostFocus = !isInput && !isCalendarElement && !isCalendarElem(e.relatedTarget);
      var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self.config.allowInput) {
          self.setDate(self._input.value, false, self.config.altInput ? self.config.altFormat : self.config.dateFormat);
        }
        if (self.timeContainer !== undefined && self.minuteElement !== undefined && self.hourElement !== undefined && self.input.value !== "" && self.input.value !== undefined) {
          updateTime();
        }
        self.close();
        if (self.config && self.config.mode === "range" && self.selectedDates.length === 1) self.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self.config.minDate && newYear < self.config.minDate.getFullYear() || self.config.maxDate && newYear > self.config.maxDate.getFullYear()) return;
    var newYearNum = newYear,
      isNewYear = self.currentYear !== newYearNum;
    self.currentYear = newYearNum || self.currentYear;
    if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
      self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
    } else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
      self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
    }
    if (isNewYear) {
      self.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self.parseDate(date, undefined, timeless);
    if (self.config.minDate && dateToCheck && compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && dateToCheck && compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;
    if (!self.config.enable && self.config.disable.length === 0) return true;
    if (dateToCheck === undefined) return false;
    var bool = !!self.config.enable,
      array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck)) return bool;else if (d instanceof Date && dateToCheck !== undefined && d.getTime() === dateToCheck.getTime()) return bool;else if (typeof d === "string") {
        var parsed = self.parseDate(d, undefined, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== undefined && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime()) return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self.daysContainer !== undefined) return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e) {
    var isInput = e.target === self._input;
    var valueChanged = self._input.value.trimEnd() !== getDateStr();
    if (isInput && valueChanged && !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
      self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
    }
  }
  function onKeyDown(e) {
    var eventTarget = getEventTarget(e);
    var isInput = self.config.wrap ? element.contains(eventTarget) : eventTarget === self._input;
    var allowInput = self.config.allowInput;
    var allowKeydown = self.isOpen && (!allowInput || !isInput);
    var allowInlineKeydown = self.config.inline && isInput && !allowInput;
    if (e.keyCode === 13 && isInput) {
      if (allowInput) {
        self.setDate(self._input.value, true, eventTarget === self.altInput ? self.config.altFormat : self.config.dateFormat);
        self.close();
        return eventTarget.blur();
      } else {
        self.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self.timeContainer && self.timeContainer.contains(eventTarget);
      switch (e.keyCode) {
        case 13:
          if (isTimeObj) {
            e.preventDefault();
            updateTime();
            focusAndClose();
          } else selectDate(e);
          break;
        case 27:
          e.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput && !self.config.allowInput) {
            e.preventDefault();
            self.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput) {
            e.preventDefault();
            var activeElement = getClosestActiveElement();
            if (self.daysContainer !== undefined && (allowInput === false || activeElement && isInView(activeElement))) {
              var delta_1 = e.keyCode === 39 ? 1 : -1;
              if (!e.ctrlKey) focusOnDay(undefined, delta_1);else {
                e.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self.hourElement) self.hourElement.focus();
          break;
        case 38:
        case 40:
          e.preventDefault();
          var delta = e.keyCode === 40 ? 1 : -1;
          if (self.daysContainer && eventTarget.$i !== undefined || eventTarget === self.input || eventTarget === self.altInput) {
            if (e.ctrlKey) {
              e.stopPropagation();
              changeYear(self.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj) focusOnDay(undefined, delta * 7);
          } else if (eventTarget === self.currentYearElement) {
            changeYear(self.currentYear - delta);
          } else if (self.config.enableTime) {
            if (!isTimeObj && self.hourElement) self.hourElement.focus();
            updateTime(e);
            self._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [self.hourElement, self.minuteElement, self.secondElement, self.amPM].concat(self.pluginElements).filter(function (x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e.shiftKey ? -1 : 1)];
              e.preventDefault();
              (target || self._input).focus();
            }
          } else if (!self.config.noCalendar && self.daysContainer && self.daysContainer.contains(eventTarget) && e.shiftKey) {
            e.preventDefault();
            self._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self.amPM !== undefined && eventTarget === self.amPM) {
      switch (e.key) {
        case self.l10n.amPM[0].charAt(0):
        case self.l10n.amPM[0].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self.l10n.amPM[1].charAt(0):
        case self.l10n.amPM[1].charAt(0).toLowerCase():
          self.amPM.textContent = self.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled"))) return;
    var hoverDate = elem ? elem.dateObj.getTime() : self.days.firstElementChild.dateObj.getTime(),
      initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(),
      rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()),
      rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0,
      maxRange = 0;
    for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
      if (!isEnabled(new Date(t), true)) {
        containsDisabled = containsDisabled || t > rangeStartDate && t < rangeEndDate;
        if (t < initialDate && (!minRange || t > minRange)) minRange = t;else if (t > initialDate && (!maxRange || t < maxRange)) maxRange = t;
      }
    }
    var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function (dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function (c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange) return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
        dayElem.classList.remove(c);
      });
      if (elem !== undefined) {
        elem.classList.add(hoverDate <= self.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate) dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate)) dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
  }
  function open(e, positionElement) {
    if (positionElement === void 0) {
      positionElement = self._positionElement;
    }
    if (self.isMobile === true) {
      if (e) {
        e.preventDefault();
        var eventTarget = getEventTarget(e);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self.mobileInput !== undefined) {
        self.mobileInput.focus();
        self.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self._input.disabled || self.config.inline) {
      return;
    }
    var wasOpen = self.isOpen;
    self.isOpen = true;
    if (!wasOpen) {
      self.calendarContainer.classList.add("open");
      self._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self.config.enableTime === true && self.config.noCalendar === true) {
      if (self.config.allowInput === false && (e === undefined || !self.timeContainer.contains(e.relatedTarget))) {
        setTimeout(function () {
          return self.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function (date) {
      var dateObj = self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat);
      var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== undefined) {
        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self.selectedDates) {
        self.selectedDates = self.selectedDates.filter(function (d) {
          return isEnabled(d);
        });
        if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
        updateValue();
      }
      if (self.daysContainer) {
        redraw();
        if (dateObj !== undefined) self.currentYearElement[type] = dateObj.getFullYear().toString();else self.currentYearElement.removeAttribute(type);
        self.currentYearElement.disabled = !!inverseDateObj && dateObj !== undefined && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = ["wrap", "weekNumbers", "allowInput", "allowInvalidPreload", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];
    var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats = {};
    self.config.parseDate = userConfig.parseDate;
    self.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self.config, "enable", {
      get: function () {
        return self.config._enable;
      },
      set: function (dates) {
        self.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self.config, "disable", {
      get: function () {
        return self.config._disable;
      },
      set: function (dates) {
        self.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self.config, "minDate", {
      get: function () {
        return self.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self.config, "maxDate", {
      get: function () {
        return self.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function (type) {
      return function (val) {
        self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self.config, "minTime", {
      get: function () {
        return self.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self.config, "maxTime", {
      get: function () {
        return self.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self.config.noCalendar = true;
      self.config.enableTime = true;
    }
    Object.assign(self.config, formats, userConfig);
    for (var i = 0; i < boolOpts.length; i++) self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
    HOOKS.filter(function (hook) {
      return self.config[hook] !== undefined;
    }).forEach(function (hook) {
      self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
    });
    self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self.config.plugins.length; i++) {
      var pluginConf = self.config.plugins[i](self) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
        } else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self.config.altInputClass = getInputElem().className + " " + self.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self.config.locale !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
    self.l10n = __assign(__assign({}, flatpickr.l10ns.default), typeof self.config.locale === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] : undefined);
    tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === undefined && flatpickr.defaultConfig.time_24hr === undefined) {
      self.config.time_24hr = self.l10n.time_24hr;
    }
    self.formatDate = createDateFormatter(self);
    self.parseDate = createDateParser({
      config: self.config,
      l10n: self.l10n
    });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self.config.position === "function") {
      return void self.config.position(self, customPositionElement);
    }
    if (self.calendarContainer === undefined) return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, function (acc, child) {
        return acc + child.offsetHeight;
      }, 0),
      calendarWidth = self.calendarContainer.offsetWidth,
      configPos = self.config.position.split(" "),
      configPosVertical = configPos[0],
      configPosHorizontal = configPos.length > 1 ? configPos[1] : null,
      inputBounds = positionElement.getBoundingClientRect(),
      distanceFromBottom = window.innerHeight - inputBounds.bottom,
      showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
    toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
    if (self.config.inline) return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass(self.calendarContainer, "arrowCenter", isCenter);
    toggleClass(self.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass(self.calendarContainer, "rightMost", rightMost);
    if (self.config.static) return;
    self.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self.calendarContainer.style.left = left + "px";
      self.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self.calendarContainer.style.left = "auto";
      self.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === undefined) return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass(self.calendarContainer, "rightMost", false);
      toggleClass(self.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self.calendarContainer.style.left = centerLeft + "px";
      self.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules) continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self.config.noCalendar || self.isMobile) return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== undefined) {
      setTimeout(self.close, 0);
    } else {
      self.close();
    }
  }
  function selectDate(e) {
    e.preventDefault();
    e.stopPropagation();
    var isSelectable = function (day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t = findParent(getEventTarget(e), isSelectable);
    if (t === undefined) return;
    var target = t;
    var selectedDate = self.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth || selectedDate.getMonth() > self.currentMonth + self.config.showMonths - 1) && self.config.mode !== "range";
    self.selectedDateElem = target;
    if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex) self.selectedDates.splice(parseInt(selectedIndex), 1);else self.selectedDates.push(selectedDate);
    } else if (self.config.mode === "range") {
      if (self.selectedDates.length === 2) {
        self.clear(false, false);
      }
      self.latestSelectedDateObj = selectedDate;
      self.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
        return a.getTime() - b.getTime();
      });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self.currentYear !== selectedDate.getFullYear();
      self.currentYear = selectedDate.getFullYear();
      self.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self.config.mode !== "range" && self.config.showMonths === 1) focusOnDayElem(target);else if (self.selectedDateElem !== undefined && self.hourElement === undefined) {
      self.selectedDateElem && self.selectedDateElem.focus();
    }
    if (self.hourElement !== undefined) self.hourElement !== undefined && self.hourElement.focus();
    if (self.config.closeOnSelect) {
      var single = self.config.mode === "single" && !self.config.enableTime;
      var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [function () {
      if (self.config.clickOpens === true) {
        bind(self._input, "focus", self.open);
        bind(self._input, "click", self.open);
      } else {
        self._input.removeEventListener("focus", self.open);
        self._input.removeEventListener("click", self.open);
      }
    }]
  };
  function set(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== undefined) CALLBACKS[key].forEach(function (x) {
          return x();
        });
      }
    } else {
      self.config[option] = value;
      if (CALLBACKS[option] !== undefined) CALLBACKS[option].forEach(function (x) {
        return x();
      });else if (HOOKS.indexOf(option) > -1) self.config[option] = arrayify(value);
    }
    self.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array) dates = inputDate.map(function (d) {
      return self.parseDate(d, format);
    });else if (inputDate instanceof Date || typeof inputDate === "number") dates = [self.parseDate(inputDate, format)];else if (typeof inputDate === "string") {
      switch (self.config.mode) {
        case "single":
        case "time":
          dates = [self.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self.config.conjunction).map(function (date) {
            return self.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
            return self.parseDate(date, format);
          });
          break;
        default:
          break;
      }
    } else self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self.selectedDates = self.config.allowInvalidPreload ? dates : dates.filter(function (d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self.config.mode === "range") self.selectedDates.sort(function (a, b) {
      return a.getTime() - b.getTime();
    });
  }
  function setDate(date, triggerChange, format) {
    if (triggerChange === void 0) {
      triggerChange = false;
    }
    if (format === void 0) {
      format = self.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0) return self.clear(triggerChange);
    setSelectedDate(date, format);
    self.latestSelectedDateObj = self.selectedDates[self.selectedDates.length - 1];
    self.redraw();
    jumpToDate(undefined, triggerChange);
    setHoursFromDate();
    if (self.selectedDates.length === 0) {
      self.clear(false);
    }
    updateValue(triggerChange);
    if (triggerChange) triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function (rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self.parseDate(rule, undefined, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to) return {
        from: self.parseDate(rule.from, undefined),
        to: self.parseDate(rule.to, undefined)
      };
      return rule;
    }).filter(function (x) {
      return x;
    });
  }
  function setupDates() {
    self.selectedDates = [];
    self.now = self.parseDate(self.config.now) || new Date();
    var preloadedDate = self.config.defaultDate || ((self.input.nodeName === "INPUT" || self.input.nodeName === "TEXTAREA") && self.input.placeholder && self.input.value === self.input.placeholder ? null : self.input.value);
    if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);
    self._initialDate = self.selectedDates.length > 0 ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now.getTime() ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now.getTime() ? self.config.maxDate : self.now;
    self.currentYear = self._initialDate.getFullYear();
    self.currentMonth = self._initialDate.getMonth();
    if (self.selectedDates.length > 0) self.latestSelectedDateObj = self.selectedDates[0];
    if (self.config.minTime !== undefined) self.config.minTime = self.parseDate(self.config.minTime, "H:i");
    if (self.config.maxTime !== undefined) self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
    self.minDateHasTime = !!self.config.minDate && (self.config.minDate.getHours() > 0 || self.config.minDate.getMinutes() > 0 || self.config.minDate.getSeconds() > 0);
    self.maxDateHasTime = !!self.config.maxDate && (self.config.maxDate.getHours() > 0 || self.config.maxDate.getMinutes() > 0 || self.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self.input = getInputElem();
    if (!self.input) {
      self.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self.input._type = self.input.type;
    self.input.type = "text";
    self.input.classList.add("flatpickr-input");
    self._input = self.input;
    if (self.config.altInput) {
      self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
      self._input = self.altInput;
      self.altInput.placeholder = self.input.placeholder;
      self.altInput.disabled = self.input.disabled;
      self.altInput.required = self.input.required;
      self.altInput.tabIndex = self.input.tabIndex;
      self.altInput.type = "text";
      self.input.setAttribute("type", "hidden");
      if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
    }
    if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self._positionElement = self.config.positionElement || self._input;
  }
  function setupMobile() {
    var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";
    self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
    self.mobileInput.tabIndex = 1;
    self.mobileInput.type = inputType;
    self.mobileInput.disabled = self.input.disabled;
    self.mobileInput.required = self.input.required;
    self.mobileInput.placeholder = self.input.placeholder;
    self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self.selectedDates.length > 0) {
      self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
    }
    if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
    if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
    if (self.input.getAttribute("step")) self.mobileInput.step = String(self.input.getAttribute("step"));
    self.input.type = "hidden";
    if (self.altInput !== undefined) self.altInput.type = "hidden";
    try {
      if (self.input.parentNode) self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
    } catch (_a) {}
    bind(self.mobileInput, "change", function (e) {
      self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e) {
    if (self.isOpen === true) return self.close();
    self.open(e);
  }
  function triggerEvent(event, data) {
    if (self.config === undefined) return;
    var hooks = self.config[event];
    if (hooks !== undefined && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++) hooks[i](self.selectedDates, self.input.value, self, data);
    }
    if (event === "onChange") {
      self.input.dispatchEvent(createEvent("change"));
      self.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e = document.createEvent("Event");
    e.initEvent(name, true, true);
    return e;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self.selectedDates.length; i++) {
      var selectedDate = self.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0) return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
    return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self.config.noCalendar || self.isMobile || !self.monthNav) return;
    self.yearElements.forEach(function (yearElement, i) {
      var d = new Date(self.currentYear, self.currentMonth, 1);
      d.setMonth(self.currentMonth + i);
      if (self.config.showMonths > 1 || self.config.monthSelectorType === "static") {
        self.monthElements[i].textContent = monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
      } else {
        self.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self._hidePrevMonthArrow = self.config.minDate !== undefined && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());
    self._hideNextMonthArrow = self.config.maxDate !== undefined && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
    return self.selectedDates.map(function (dObj) {
      return self.formatDate(dObj, format);
    }).filter(function (d, i, arr) {
      return self.config.mode !== "range" || self.config.enableTime || arr.indexOf(d) === i;
    }).join(self.config.mode !== "range" ? self.config.conjunction : self.l10n.rangeSeparator);
  }
  function updateValue(triggerChange) {
    if (triggerChange === void 0) {
      triggerChange = true;
    }
    if (self.mobileInput !== undefined && self.mobileFormatStr) {
      self.mobileInput.value = self.latestSelectedDateObj !== undefined ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
    }
    self.input.value = getDateStr(self.config.dateFormat);
    if (self.altInput !== undefined) {
      self.altInput.value = getDateStr(self.config.altFormat);
    }
    if (triggerChange !== false) triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e) {
    var eventTarget = getEventTarget(e);
    var isPrevMonth = self.prevMonthNav.contains(eventTarget);
    var isNextMonth = self.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self.changeYear(self.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self.changeYear(self.currentYear - 1);
    }
  }
  function timeWrapper(e) {
    e.preventDefault();
    var isKeyDown = e.type === "keydown",
      eventTarget = getEventTarget(e),
      input = eventTarget;
    if (self.amPM !== undefined && eventTarget === self.amPM) {
      self.amPM.textContent = self.l10n.amPM[utils_int(self.amPM.textContent === self.l10n.amPM[0])];
    }
    var min = parseFloat(input.getAttribute("min")),
      max = parseFloat(input.getAttribute("max")),
      step = parseFloat(input.getAttribute("step")),
      curValue = parseInt(input.value, 10),
      delta = e.delta || (isKeyDown ? e.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self.hourElement,
        isMinuteElem = input === self.minuteElement;
      if (newValue < min) {
        newValue = max + newValue + utils_int(!isHourElem) + (utils_int(isHourElem) && utils_int(!self.amPM));
        if (isMinuteElem) incrementNumInput(undefined, -1, self.hourElement);
      } else if (newValue > max) {
        newValue = input === self.hourElement ? newValue - max - utils_int(!self.amPM) : min;
        if (isMinuteElem) incrementNumInput(undefined, 1, self.hourElement);
      }
      if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self.amPM.textContent = self.l10n.amPM[utils_int(self.amPM.textContent === self.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function (x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null) continue;
      if (node._flatpickr !== undefined) {
        node._flatpickr.destroy();
        node._flatpickr = undefined;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e) {
      console.error(e);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function (config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function (selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign({}, l10n_default),
  default: __assign({}, l10n_default)
};
flatpickr.localize = function (l10n) {
  flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function (config) {
  flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function (config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function (days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
/* harmony default export */ const esm = (flatpickr);
// EXTERNAL MODULE: ./node_modules/@codemirror/view/dist/index.js + 1 modules
var dist = __webpack_require__(5177);
// EXTERNAL MODULE: ./node_modules/@codemirror/state/dist/index.js + 1 modules
var state_dist = __webpack_require__(1001);
// EXTERNAL MODULE: ./node_modules/@codemirror/language/dist/index.js
var language_dist = __webpack_require__(4658);
// EXTERNAL MODULE: ./node_modules/@lezer/common/dist/index.js
var common_dist = __webpack_require__(413);
;// ./node_modules/@codemirror/commands/dist/index.js
function dist_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = dist_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function dist_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return dist_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? dist_arrayLikeToArray(r, a) : void 0; } }
function dist_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }




const toggleComment = target => {
  let {
      state
    } = target,
    line = state.doc.lineAt(state.selection.main.from),
    config = getConfig(target.state, line.from);
  return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
  return _ref => {
    let {
      state,
      dispatch
    } = _ref;
    if (state.readOnly) return false;
    let tr = f(option, state);
    if (!tr) return false;
    dispatch(state.update(tr));
    return true;
  };
}
const toggleLineComment = command(changeLineComment, 0);
const lineComment = command(changeLineComment, 1);
const lineUncomment = command(changeLineComment, 2);
const toggleBlockComment = command(changeBlockComment, 0);
const blockComment = command(changeBlockComment, 1);
const blockUncomment = command(changeBlockComment, 2);
const toggleBlockCommentByLine = command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0);
function getConfig(state, pos) {
  let data = state.languageDataAt("commentTokens", pos);
  return data.length ? data[0] : {};
}
const SearchMargin = 50;
function findBlockComment(state, _ref2, from, to) {
  let {
    open,
    close
  } = _ref2;
  let textBefore = state.sliceDoc(from - SearchMargin, from);
  let textAfter = state.sliceDoc(to, to + SearchMargin);
  let spaceBefore = /\s*$/.exec(textBefore)[0].length,
    spaceAfter = /^\s*/.exec(textAfter)[0].length;
  let beforeOff = textBefore.length - spaceBefore;
  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
    return {
      open: {
        pos: from - spaceBefore,
        margin: spaceBefore && 1
      },
      close: {
        pos: to + spaceAfter,
        margin: spaceAfter && 1
      }
    };
  }
  let startText, endText;
  if (to - from <= 2 * SearchMargin) {
    startText = endText = state.sliceDoc(from, to);
  } else {
    startText = state.sliceDoc(from, from + SearchMargin);
    endText = state.sliceDoc(to - SearchMargin, to);
  }
  let startSpace = /^\s*/.exec(startText)[0].length,
    endSpace = /\s*$/.exec(endText)[0].length;
  let endOff = endText.length - endSpace - close.length;
  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {
    return {
      open: {
        pos: from + startSpace + open.length,
        margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0
      },
      close: {
        pos: to - endSpace - close.length,
        margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0
      }
    };
  }
  return null;
}
function selectedLineRanges(state) {
  let ranges = [];
  for (var _iterator = dist_createForOfIteratorHelperLoose(state.selection.ranges), _step; !(_step = _iterator()).done;) {
    let r = _step.value;
    let fromLine = state.doc.lineAt(r.from);
    let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
    if (toLine.from > fromLine.from && toLine.from == r.to) toLine = r.to == fromLine.to + 1 ? fromLine : state.doc.lineAt(r.to - 1);
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last].to > fromLine.from) ranges[last].to = toLine.to;else ranges.push({
      from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length,
      to: toLine.to
    });
  }
  return ranges;
}
function changeBlockComment(option, state, ranges) {
  if (ranges === void 0) {
    ranges = state.selection.ranges;
  }
  let tokens = ranges.map(r => getConfig(state, r.from).block);
  if (!tokens.every(c => c)) return null;
  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
  if (option != 2 && !comments.every(c => c)) {
    return {
      changes: state.changes(ranges.map((range, i) => {
        if (comments[i]) return [];
        return [{
          from: range.from,
          insert: tokens[i].open + " "
        }, {
          from: range.to,
          insert: " " + tokens[i].close
        }];
      }))
    };
  } else if (option != 1 && comments.some(c => c)) {
    let changes = [];
    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {
      let token = tokens[i],
        {
          open,
          close
        } = comment;
      changes.push({
        from: open.pos - token.open.length,
        to: open.pos + open.margin
      }, {
        from: close.pos - close.margin,
        to: close.pos + token.close.length
      });
    }
    return {
      changes
    };
  }
  return null;
}
function changeLineComment(option, state, ranges) {
  if (ranges === void 0) {
    ranges = state.selection.ranges;
  }
  let lines = [];
  let prevLine = -1;
  for (var _iterator2 = dist_createForOfIteratorHelperLoose(ranges), _step2; !(_step2 = _iterator2()).done;) {
    let {
      from,
      to
    } = _step2.value;
    let startI = lines.length,
      minIndent = 1e9;
    let token = getConfig(state, from).line;
    if (!token) continue;
    for (let pos = from; pos <= to;) {
      let line = state.doc.lineAt(pos);
      if (line.from > prevLine && (from == to || to > line.from)) {
        prevLine = line.from;
        let indent = /^\s*/.exec(line.text)[0].length;
        let empty = indent == line.length;
        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
        if (indent < line.text.length && indent < minIndent) minIndent = indent;
        lines.push({
          line,
          comment,
          token,
          indent,
          empty,
          single: false
        });
      }
      pos = line.to + 1;
    }
    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;
    if (lines.length == startI + 1) lines[startI].single = true;
  }
  if (option != 2 && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
    let changes = [];
    for (var _iterator3 = dist_createForOfIteratorHelperLoose(lines), _step3; !(_step3 = _iterator3()).done;) {
      let {
        line,
        token,
        indent,
        empty,
        single
      } = _step3.value;
      if (single || !empty) changes.push({
        from: line.from + indent,
        insert: token + " "
      });
    }
    let changeSet = state.changes(changes);
    return {
      changes: changeSet,
      selection: state.selection.map(changeSet, 1)
    };
  } else if (option != 1 && lines.some(l => l.comment >= 0)) {
    let changes = [];
    for (var _iterator4 = dist_createForOfIteratorHelperLoose(lines), _step4; !(_step4 = _iterator4()).done;) {
      let {
        line,
        comment,
        token
      } = _step4.value;
      if (comment >= 0) {
        let from = line.from + comment,
          to = from + token.length;
        if (line.text[to - line.from] == " ") to++;
        changes.push({
          from,
          to
        });
      }
    }
    return {
      changes
    };
  }
  return null;
}
const fromHistory = state_dist/* Annotation */.YH.define();
const isolateHistory = state_dist/* Annotation */.YH.define();
const invertedEffects = state_dist/* Facet */.sj.define();
const historyConfig = state_dist/* Facet */.sj.define({
  combine(configs) {
    return (0,state_dist/* combineConfig */.QR)(configs, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (_t, isAdjacent) => isAdjacent
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
    });
  }
});
const historyField_ = state_dist/* StateField */.sU.define({
  create() {
    return HistoryState.empty;
  },
  update(state, tr) {
    let config = tr.state.facet(historyConfig);
    let fromHist = tr.annotation(fromHistory);
    if (fromHist) {
      let item = HistEvent.fromTransaction(tr, fromHist.selection),
        from = fromHist.side;
      let other = from == 0 ? state.undone : state.done;
      if (item) other = updateBranch(other, other.length, config.minDepth, item);else other = addSelection(other, tr.startState.selection);
      return new HistoryState(from == 0 ? fromHist.rest : other, from == 0 ? other : fromHist.rest);
    }
    let isolate = tr.annotation(isolateHistory);
    if (isolate == "full" || isolate == "before") state = state.isolate();
    if (tr.annotation(state_dist/* Transaction */.ZX.addToHistory) === false) return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
    let event = HistEvent.fromTransaction(tr);
    let time = tr.annotation(state_dist/* Transaction */.ZX.time),
      userEvent = tr.annotation(state_dist/* Transaction */.ZX.userEvent);
    if (event) state = state.addChanges(event, time, userEvent, config, tr);else if (tr.selection) state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
    if (isolate == "full" || isolate == "after") state = state.isolate();
    return state;
  },
  toJSON(value) {
    return {
      done: value.done.map(e => e.toJSON()),
      undone: value.undone.map(e => e.toJSON())
    };
  },
  fromJSON(json) {
    return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
  }
});
function dist_history(config) {
  if (config === void 0) {
    config = {};
  }
  return [historyField_, historyConfig.of(config), dist/* EditorView */.Lz.domEventHandlers({
    beforeinput(e, view) {
      let command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
      if (!command) return false;
      e.preventDefault();
      return command(view);
    }
  })];
}
const historyField = (/* unused pure expression or super */ null && (historyField_));
function cmd(side, selection) {
  return function (_ref3) {
    let {
      state,
      dispatch
    } = _ref3;
    if (!selection && state.readOnly) return false;
    let historyState = state.field(historyField_, false);
    if (!historyState) return false;
    let tr = historyState.pop(side, state, selection);
    if (!tr) return false;
    dispatch(tr);
    return true;
  };
}
const undo = cmd(0, false);
const redo = cmd(1, false);
const undoSelection = cmd(0, true);
const redoSelection = cmd(1, true);
function depth(side) {
  return function (state) {
    let histState = state.field(historyField_, false);
    if (!histState) return 0;
    let branch = side == 0 ? histState.done : histState.undone;
    return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
  };
}
const undoDepth = depth(0);
const redoDepth = depth(1);
class HistEvent {
  constructor(changes, effects, mapped, startSelection, selectionsAfter) {
    this.changes = changes;
    this.effects = effects;
    this.mapped = mapped;
    this.startSelection = startSelection;
    this.selectionsAfter = selectionsAfter;
  }
  setSelAfter(after) {
    return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
  }
  toJSON() {
    var _a, _b, _c;
    return {
      changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
      mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
      startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
      selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
    };
  }
  static fromJSON(json) {
    return new HistEvent(json.changes && state_dist/* ChangeSet */.VR.fromJSON(json.changes), [], json.mapped && state_dist/* ChangeDesc */.Gu.fromJSON(json.mapped), json.startSelection && state_dist/* EditorSelection */.OF.fromJSON(json.startSelection), json.selectionsAfter.map(state_dist/* EditorSelection */.OF.fromJSON));
  }
  static fromTransaction(tr, selection) {
    let effects = none;
    for (var _iterator5 = dist_createForOfIteratorHelperLoose(tr.startState.facet(invertedEffects)), _step5; !(_step5 = _iterator5()).done;) {
      let invert = _step5.value;
      let result = invert(tr);
      if (result.length) effects = effects.concat(result);
    }
    if (!effects.length && tr.changes.empty) return null;
    return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, none);
  }
  static selection(selections) {
    return new HistEvent(undefined, none, undefined, undefined, selections);
  }
}
function updateBranch(branch, to, maxLen, newEvent) {
  let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
  let newBranch = branch.slice(start, to);
  newBranch.push(newEvent);
  return newBranch;
}
function isAdjacent(a, b) {
  let ranges = [],
    isAdjacent = false;
  a.iterChangedRanges((f, t) => ranges.push(f, t));
  b.iterChangedRanges((_f, _t, f, t) => {
    for (let i = 0; i < ranges.length;) {
      let from = ranges[i++],
        to = ranges[i++];
      if (t >= from && f <= to) isAdjacent = true;
    }
  });
  return isAdjacent;
}
function eqSelectionShape(a, b) {
  return a.ranges.length == b.ranges.length && a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
  return !a.length ? b : !b.length ? a : a.concat(b);
}
const none = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
  if (!branch.length) {
    return [HistEvent.selection([selection])];
  } else {
    let lastEvent = branch[branch.length - 1];
    let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
    if (sels.length && sels[sels.length - 1].eq(selection)) return branch;
    sels.push(selection);
    return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
  }
}
function popSelection(branch) {
  let last = branch[branch.length - 1];
  let newBranch = branch.slice();
  newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
  return newBranch;
}
function addMappingToBranch(branch, mapping) {
  if (!branch.length) return branch;
  let length = branch.length,
    selections = none;
  while (length) {
    let event = mapEvent(branch[length - 1], mapping, selections);
    if (event.changes && !event.changes.empty || event.effects.length) {
      let result = branch.slice(0, length);
      result[length - 1] = event;
      return result;
    } else {
      mapping = event.mapped;
      length--;
      selections = event.selectionsAfter;
    }
  }
  return selections.length ? [HistEvent.selection(selections)] : none;
}
function mapEvent(event, mapping, extraSelections) {
  let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : none, extraSelections);
  if (!event.changes) return HistEvent.selection(selections);
  let mappedChanges = event.changes.map(mapping),
    before = mapping.mapDesc(event.changes, true);
  let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
  return new HistEvent(mappedChanges, state_dist/* StateEffect */.Pe.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
  constructor(done, undone, prevTime, prevUserEvent) {
    if (prevTime === void 0) {
      prevTime = 0;
    }
    if (prevUserEvent === void 0) {
      prevUserEvent = undefined;
    }
    this.done = done;
    this.undone = undone;
    this.prevTime = prevTime;
    this.prevUserEvent = prevUserEvent;
  }
  isolate() {
    return this.prevTime ? new HistoryState(this.done, this.undone) : this;
  }
  addChanges(event, time, userEvent, config, tr) {
    let done = this.done,
      lastEvent = done[done.length - 1];
    if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes && (!userEvent || joinableUserEvent.test(userEvent)) && (!lastEvent.selectionsAfter.length && time - this.prevTime < config.newGroupDelay && config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes)) || userEvent == "input.type.compose")) {
      done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(state_dist/* StateEffect */.Pe.mapEffects(event.effects, lastEvent.changes), lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, none));
    } else {
      done = updateBranch(done, done.length, config.minDepth, event);
    }
    return new HistoryState(done, none, time, userEvent);
  }
  addSelection(selection, time, userEvent, newGroupDelay) {
    let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : none;
    if (last.length > 0 && time - this.prevTime < newGroupDelay && userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) && eqSelectionShape(last[last.length - 1], selection)) return this;
    return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
  }
  addMapping(mapping) {
    return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
  }
  pop(side, state, onlySelection) {
    let branch = side == 0 ? this.done : this.undone;
    if (branch.length == 0) return null;
    let event = branch[branch.length - 1],
      selection = event.selectionsAfter[0] || state.selection;
    if (onlySelection && event.selectionsAfter.length) {
      return state.update({
        selection: event.selectionsAfter[event.selectionsAfter.length - 1],
        annotations: fromHistory.of({
          side,
          rest: popSelection(branch),
          selection
        }),
        userEvent: side == 0 ? "select.undo" : "select.redo",
        scrollIntoView: true
      });
    } else if (!event.changes) {
      return null;
    } else {
      let rest = branch.length == 1 ? none : branch.slice(0, branch.length - 1);
      if (event.mapped) rest = addMappingToBranch(rest, event.mapped);
      return state.update({
        changes: event.changes,
        selection: event.startSelection,
        effects: event.effects,
        annotations: fromHistory.of({
          side,
          rest,
          selection
        }),
        filter: false,
        userEvent: side == 0 ? "undo" : "redo",
        scrollIntoView: true
      });
    }
  }
}
HistoryState.empty = new HistoryState(none, none);
const historyKeymap = [{
  key: "Mod-z",
  run: undo,
  preventDefault: true
}, {
  key: "Mod-y",
  mac: "Mod-Shift-z",
  run: redo,
  preventDefault: true
}, {
  linux: "Ctrl-Shift-z",
  run: redo,
  preventDefault: true
}, {
  key: "Mod-u",
  run: undoSelection,
  preventDefault: true
}, {
  key: "Alt-u",
  mac: "Mod-Shift-u",
  run: redoSelection,
  preventDefault: true
}];
function updateSel(sel, by) {
  return state_dist/* EditorSelection */.OF.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
  return state.update({
    selection,
    scrollIntoView: true,
    userEvent: "select"
  });
}
function moveSel(_ref4, how) {
  let {
    state,
    dispatch
  } = _ref4;
  let selection = updateSel(state.selection, how);
  if (selection.eq(state.selection, true)) return false;
  dispatch(setSel(state, selection));
  return true;
}
function rangeEnd(range, forward) {
  return state_dist/* EditorSelection */.OF.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
  return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
  return view.textDirectionAt(view.state.selection.main.head) == dist/* Direction */.OP.LTR;
}
const cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));
const cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));
const cursorCharForward = view => cursorByChar(view, true);
const cursorCharBackward = view => cursorByChar(view, false);
function byCharLogical(state, range, forward) {
  let pos = range.head,
    line = state.doc.lineAt(pos);
  if (pos == (forward ? line.to : line.from)) pos = forward ? Math.min(state.doc.length, line.to + 1) : Math.max(0, line.from - 1);else pos = line.from + findClusterBreak(line.text, pos - line.from, forward);
  return EditorSelection.cursor(pos, forward ? -1 : 1);
}
function moveByCharLogical(target, forward) {
  return moveSel(target, range => range.empty ? byCharLogical(target.state, range, forward) : rangeEnd(range, forward));
}
const cursorCharForwardLogical = target => moveByCharLogical(target, true);
const cursorCharBackwardLogical = target => moveByCharLogical(target, false);
function cursorByGroup(view, forward) {
  return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
const cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));
const cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));
const cursorGroupForward = view => cursorByGroup(view, true);
const cursorGroupBackward = view => cursorByGroup(view, false);
function toGroupStart(view, pos, start) {
  let categorize = view.state.charCategorizer(pos);
  let cat = categorize(start),
    initial = cat != CharCategory.Space;
  return next => {
    let nextCat = categorize(next);
    if (nextCat != CharCategory.Space) return initial && nextCat == cat;
    initial = false;
    return true;
  };
}
const cursorGroupForwardWin = view => {
  return moveSel(view, range => range.empty ? view.moveByChar(range, true, start => toGroupStart(view, range.head, start)) : rangeEnd(range, true));
};
const segmenter = typeof Intl != "undefined" && Intl.Segmenter ? new Intl.Segmenter(undefined, {
  granularity: "word"
}) : null;
function moveBySubword(view, range, forward) {
  let categorize = view.state.charCategorizer(range.from);
  let cat = CharCategory.Space,
    pos = range.from,
    steps = 0;
  let done = false,
    sawUpper = false,
    sawLower = false;
  let step = next => {
    if (done) return false;
    pos += forward ? next.length : -next.length;
    let nextCat = categorize(next),
      ahead;
    if (nextCat == CharCategory.Word && next.charCodeAt(0) < 128 && /[\W_]/.test(next)) nextCat = -1;
    if (cat == CharCategory.Space) cat = nextCat;
    if (cat != nextCat) return false;
    if (cat == CharCategory.Word) {
      if (next.toLowerCase() == next) {
        if (!forward && sawUpper) return false;
        sawLower = true;
      } else if (sawLower) {
        if (forward) return false;
        done = true;
      } else {
        if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word && ahead.toLowerCase() == ahead) return false;
        sawUpper = true;
      }
    }
    steps++;
    return true;
  };
  let end = view.moveByChar(range, forward, start => {
    step(start);
    return step;
  });
  if (segmenter && cat == CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {
    let from = Math.min(range.head, end.head),
      to = Math.max(range.head, end.head);
    let skipped = view.state.sliceDoc(from, to);
    if (skipped.length > 1 && /[\u4E00-\uffff]/.test(skipped)) {
      let segments = Array.from(segmenter.segment(skipped));
      if (segments.length > 1) {
        if (forward) return EditorSelection.cursor(range.head + segments[1].index, -1);
        return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);
      }
    }
  }
  return end;
}
function cursorBySubword(view, forward) {
  return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
}
const cursorSubwordForward = view => cursorBySubword(view, true);
const cursorSubwordBackward = view => cursorBySubword(view, false);
function interestingNode(state, node, bracketProp) {
  if (node.type.prop(bracketProp)) return true;
  let len = node.to - node.from;
  return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
  let pos = (0,language_dist/* syntaxTree */.mv)(state).resolveInner(start.head);
  let bracketProp = forward ? common_dist/* NodeProp */.uY.closedBy : common_dist/* NodeProp */.uY.openedBy;
  for (let at = start.head;;) {
    let next = forward ? pos.childAfter(at) : pos.childBefore(at);
    if (!next) break;
    if (interestingNode(state, next, bracketProp)) pos = next;else at = forward ? next.to : next.from;
  }
  let bracket = pos.type.prop(bracketProp),
    match,
    newPos;
  if (bracket && (match = forward ? (0,language_dist/* matchBrackets */.jU)(state, pos.from, 1) : (0,language_dist/* matchBrackets */.jU)(state, pos.to, -1)) && match.matched) newPos = forward ? match.end.to : match.end.from;else newPos = forward ? pos.to : pos.from;
  return state_dist/* EditorSelection */.OF.cursor(newPos, forward ? -1 : 1);
}
const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
  return moveSel(view, range => {
    if (!range.empty) return rangeEnd(range, forward);
    let moved = view.moveVertically(range, forward);
    return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
  });
}
const cursorLineUp = view => cursorByLine(view, false);
const cursorLineDown = view => cursorByLine(view, true);
function pageInfo(view) {
  let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
  let marginTop = 0,
    marginBottom = 0,
    height;
  if (selfScroll) {
    for (var _iterator6 = dist_createForOfIteratorHelperLoose(view.state.facet(dist/* EditorView */.Lz.scrollMargins)), _step6; !(_step6 = _iterator6()).done;) {
      let source = _step6.value;
      let margins = source(view);
      if (margins === null || margins === void 0 ? void 0 : margins.top) marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
      if (margins === null || margins === void 0 ? void 0 : margins.bottom) marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
    }
    height = view.scrollDOM.clientHeight - marginTop - marginBottom;
  } else {
    height = (view.dom.ownerDocument.defaultView || window).innerHeight;
  }
  return {
    marginTop,
    marginBottom,
    selfScroll,
    height: Math.max(view.defaultLineHeight, height - 5)
  };
}
function cursorByPage(view, forward) {
  let page = pageInfo(view);
  let {
      state
    } = view,
    selection = updateSel(state.selection, range => {
      return range.empty ? view.moveVertically(range, forward, page.height) : rangeEnd(range, forward);
    });
  if (selection.eq(state.selection)) return false;
  let effect;
  if (page.selfScroll) {
    let startPos = view.coordsAtPos(state.selection.main.head);
    let scrollRect = view.scrollDOM.getBoundingClientRect();
    let scrollTop = scrollRect.top + page.marginTop,
      scrollBottom = scrollRect.bottom - page.marginBottom;
    if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom) effect = dist/* EditorView */.Lz.scrollIntoView(selection.main.head, {
      y: "start",
      yMargin: startPos.top - scrollTop
    });
  }
  view.dispatch(setSel(state, selection), {
    effects: effect
  });
  return true;
}
const cursorPageUp = view => cursorByPage(view, false);
const cursorPageDown = view => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
  let line = view.lineBlockAt(start.head),
    moved = view.moveToLineBoundary(start, forward);
  if (moved.head == start.head && moved.head != (forward ? line.to : line.from)) moved = view.moveToLineBoundary(start, forward, false);
  if (!forward && moved.head == line.from && line.length) {
    let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
    if (space && start.head != line.from + space) moved = state_dist/* EditorSelection */.OF.cursor(line.from + space);
  }
  return moved;
}
const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
const cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
const cursorLineStart = view => moveSel(view, range => state_dist/* EditorSelection */.OF.cursor(view.lineBlockAt(range.head).from, 1));
const cursorLineEnd = view => moveSel(view, range => state_dist/* EditorSelection */.OF.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
  let found = false,
    selection = updateSel(state.selection, range => {
      let matching = (0,language_dist/* matchBrackets */.jU)(state, range.head, -1) || (0,language_dist/* matchBrackets */.jU)(state, range.head, 1) || range.head > 0 && (0,language_dist/* matchBrackets */.jU)(state, range.head - 1, 1) || range.head < state.doc.length && (0,language_dist/* matchBrackets */.jU)(state, range.head + 1, -1);
      if (!matching || !matching.end) return range;
      found = true;
      let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
      return extend ? state_dist/* EditorSelection */.OF.range(range.anchor, head) : state_dist/* EditorSelection */.OF.cursor(head);
    });
  if (!found) return false;
  dispatch(setSel(state, selection));
  return true;
}
const cursorMatchingBracket = _ref5 => {
  let {
    state,
    dispatch
  } = _ref5;
  return toMatchingBracket(state, dispatch, false);
};
const selectMatchingBracket = _ref6 => {
  let {
    state,
    dispatch
  } = _ref6;
  return toMatchingBracket(state, dispatch, true);
};
function extendSel(target, how) {
  let selection = updateSel(target.state.selection, range => {
    let head = how(range);
    return state_dist/* EditorSelection */.OF.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);
  });
  if (selection.eq(target.state.selection)) return false;
  target.dispatch(setSel(target.state, selection));
  return true;
}
function selectByChar(view, forward) {
  return extendSel(view, range => view.moveByChar(range, forward));
}
const selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));
const selectCharRight = view => selectByChar(view, ltrAtCursor(view));
const selectCharForward = view => selectByChar(view, true);
const selectCharBackward = view => selectByChar(view, false);
const selectCharForwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, true));
const selectCharBackwardLogical = target => extendSel(target, range => byCharLogical(target.state, range, false));
function selectByGroup(view, forward) {
  return extendSel(view, range => view.moveByGroup(range, forward));
}
const selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));
const selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));
const selectGroupForward = view => selectByGroup(view, true);
const selectGroupBackward = view => selectByGroup(view, false);
const selectGroupForwardWin = view => {
  return extendSel(view, range => view.moveByChar(range, true, start => toGroupStart(view, range.head, start)));
};
function selectBySubword(view, forward) {
  return extendSel(view, range => moveBySubword(view, range, forward));
}
const selectSubwordForward = view => selectBySubword(view, true);
const selectSubwordBackward = view => selectBySubword(view, false);
const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
  return extendSel(view, range => view.moveVertically(range, forward));
}
const selectLineUp = view => selectByLine(view, false);
const selectLineDown = view => selectByLine(view, true);
function selectByPage(view, forward) {
  return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));
}
const selectPageUp = view => selectByPage(view, false);
const selectPageDown = view => selectByPage(view, true);
const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
const selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
const selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
const selectLineStart = view => extendSel(view, range => state_dist/* EditorSelection */.OF.cursor(view.lineBlockAt(range.head).from));
const selectLineEnd = view => extendSel(view, range => state_dist/* EditorSelection */.OF.cursor(view.lineBlockAt(range.head).to));
const cursorDocStart = _ref7 => {
  let {
    state,
    dispatch
  } = _ref7;
  dispatch(setSel(state, {
    anchor: 0
  }));
  return true;
};
const cursorDocEnd = _ref8 => {
  let {
    state,
    dispatch
  } = _ref8;
  dispatch(setSel(state, {
    anchor: state.doc.length
  }));
  return true;
};
const selectDocStart = _ref9 => {
  let {
    state,
    dispatch
  } = _ref9;
  dispatch(setSel(state, {
    anchor: state.selection.main.anchor,
    head: 0
  }));
  return true;
};
const selectDocEnd = _ref10 => {
  let {
    state,
    dispatch
  } = _ref10;
  dispatch(setSel(state, {
    anchor: state.selection.main.anchor,
    head: state.doc.length
  }));
  return true;
};
const selectAll = _ref11 => {
  let {
    state,
    dispatch
  } = _ref11;
  dispatch(state.update({
    selection: {
      anchor: 0,
      head: state.doc.length
    },
    userEvent: "select"
  }));
  return true;
};
const selectLine = _ref12 => {
  let {
    state,
    dispatch
  } = _ref12;
  let ranges = selectedLineBlocks(state).map(_ref13 => {
    let {
      from,
      to
    } = _ref13;
    return state_dist/* EditorSelection */.OF.range(from, Math.min(to + 1, state.doc.length));
  });
  dispatch(state.update({
    selection: state_dist/* EditorSelection */.OF.create(ranges),
    userEvent: "select"
  }));
  return true;
};
const selectParentSyntax = _ref14 => {
  let {
    state,
    dispatch
  } = _ref14;
  let selection = updateSel(state.selection, range => {
    let tree = (0,language_dist/* syntaxTree */.mv)(state),
      stack = tree.resolveStack(range.from, 1);
    if (range.empty) {
      let stackBefore = tree.resolveStack(range.from, -1);
      if (stackBefore.node.from >= stack.node.from && stackBefore.node.to <= stack.node.to) stack = stackBefore;
    }
    for (let cur = stack; cur; cur = cur.next) {
      let {
        node
      } = cur;
      if ((node.from < range.from && node.to >= range.to || node.to > range.to && node.from <= range.from) && cur.next) return state_dist/* EditorSelection */.OF.range(node.to, node.from);
    }
    return range;
  });
  if (selection.eq(state.selection)) return false;
  dispatch(setSel(state, selection));
  return true;
};
const simplifySelection = _ref15 => {
  let {
    state,
    dispatch
  } = _ref15;
  let cur = state.selection,
    selection = null;
  if (cur.ranges.length > 1) selection = state_dist/* EditorSelection */.OF.create([cur.main]);else if (!cur.main.empty) selection = state_dist/* EditorSelection */.OF.create([state_dist/* EditorSelection */.OF.cursor(cur.main.head)]);
  if (!selection) return false;
  dispatch(setSel(state, selection));
  return true;
};
function deleteBy(target, by) {
  if (target.state.readOnly) return false;
  let event = "delete.selection",
    {
      state
    } = target;
  let changes = state.changeByRange(range => {
    let {
      from,
      to
    } = range;
    if (from == to) {
      let towards = by(range);
      if (towards < from) {
        event = "delete.backward";
        towards = skipAtomic(target, towards, false);
      } else if (towards > from) {
        event = "delete.forward";
        towards = skipAtomic(target, towards, true);
      }
      from = Math.min(from, towards);
      to = Math.max(to, towards);
    } else {
      from = skipAtomic(target, from, false);
      to = skipAtomic(target, to, true);
    }
    return from == to ? {
      range
    } : {
      changes: {
        from,
        to
      },
      range: state_dist/* EditorSelection */.OF.cursor(from, from < range.head ? -1 : 1)
    };
  });
  if (changes.changes.empty) return false;
  target.dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: event,
    effects: event == "delete.selection" ? dist/* EditorView */.Lz.announce.of(state.phrase("Selection deleted")) : undefined
  }));
  return true;
}
function skipAtomic(target, pos, forward) {
  if (target instanceof dist/* EditorView */.Lz) {
    for (var _iterator7 = dist_createForOfIteratorHelperLoose(target.state.facet(dist/* EditorView */.Lz.atomicRanges).map(f => f(target))), _step7; !(_step7 = _iterator7()).done;) {
      let ranges = _step7.value;
      ranges.between(pos, pos, (from, to) => {
        if (from < pos && to > pos) pos = forward ? to : from;
      });
    }
  }
  return pos;
}
const deleteByChar = (target, forward, byIndentUnit) => deleteBy(target, range => {
  let pos = range.from,
    {
      state
    } = target,
    line = state.doc.lineAt(pos),
    before,
    targetPos;
  if (byIndentUnit && !forward && pos > line.from && pos < line.from + 200 && !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
    if (before[before.length - 1] == "\t") return pos - 1;
    let col = (0,state_dist/* countColumn */.y$)(before, state.tabSize),
      drop = col % (0,language_dist/* getIndentUnit */.tp)(state) || (0,language_dist/* getIndentUnit */.tp)(state);
    for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++) pos--;
    targetPos = pos;
  } else {
    targetPos = (0,state_dist/* findClusterBreak */.zK)(line.text, pos - line.from, forward, forward) + line.from;
    if (targetPos == pos && line.number != (forward ? state.doc.lines : 1)) targetPos += forward ? 1 : -1;else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from))) targetPos = (0,state_dist/* findClusterBreak */.zK)(line.text, targetPos - line.from, false, false) + line.from;
  }
  return targetPos;
});
const deleteCharBackward = view => deleteByChar(view, false, true);
const deleteCharBackwardStrict = view => deleteByChar(view, false, false);
const deleteCharForward = view => deleteByChar(view, true, false);
const deleteByGroup = (target, forward) => deleteBy(target, range => {
  let pos = range.head,
    {
      state
    } = target,
    line = state.doc.lineAt(pos);
  let categorize = state.charCategorizer(pos);
  for (let cat = null;;) {
    if (pos == (forward ? line.to : line.from)) {
      if (pos == range.head && line.number != (forward ? state.doc.lines : 1)) pos += forward ? 1 : -1;
      break;
    }
    let next = (0,state_dist/* findClusterBreak */.zK)(line.text, pos - line.from, forward) + line.from;
    let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
    let nextCat = categorize(nextChar);
    if (cat != null && nextCat != cat) break;
    if (nextChar != " " || pos != range.head) cat = nextCat;
    pos = next;
  }
  return pos;
});
const deleteGroupBackward = target => deleteByGroup(target, false);
const deleteGroupForward = target => deleteByGroup(target, true);
const deleteToLineEnd = view => deleteBy(view, range => {
  let lineEnd = view.lineBlockAt(range.head).to;
  return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
const deleteToLineStart = view => deleteBy(view, range => {
  let lineStart = view.lineBlockAt(range.head).from;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
const deleteLineBoundaryBackward = view => deleteBy(view, range => {
  let lineStart = view.moveToLineBoundary(range, false).head;
  return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
const deleteLineBoundaryForward = view => deleteBy(view, range => {
  let lineStart = view.moveToLineBoundary(range, true).head;
  return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
const deleteTrailingWhitespace = _ref16 => {
  let {
    state,
    dispatch
  } = _ref16;
  if (state.readOnly) return false;
  let changes = [];
  for (let pos = 0, prev = "", iter = state.doc.iter();;) {
    iter.next();
    if (iter.lineBreak || iter.done) {
      let trailing = prev.search(/\s+$/);
      if (trailing > -1) changes.push({
        from: pos - (prev.length - trailing),
        to: pos
      });
      if (iter.done) break;
      prev = "";
    } else {
      prev = iter.value;
    }
    pos += iter.value.length;
  }
  if (!changes.length) return false;
  dispatch(state.update({
    changes,
    userEvent: "delete"
  }));
  return true;
};
const splitLine = _ref17 => {
  let {
    state,
    dispatch
  } = _ref17;
  if (state.readOnly) return false;
  let changes = state.changeByRange(range => {
    return {
      changes: {
        from: range.from,
        to: range.to,
        insert: state_dist/* Text */.EY.of(["", ""])
      },
      range: state_dist/* EditorSelection */.OF.cursor(range.from)
    };
  });
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};
const transposeChars = _ref18 => {
  let {
    state,
    dispatch
  } = _ref18;
  if (state.readOnly) return false;
  let changes = state.changeByRange(range => {
    if (!range.empty || range.from == 0 || range.from == state.doc.length) return {
      range
    };
    let pos = range.from,
      line = state.doc.lineAt(pos);
    let from = pos == line.from ? pos - 1 : (0,state_dist/* findClusterBreak */.zK)(line.text, pos - line.from, false) + line.from;
    let to = pos == line.to ? pos + 1 : (0,state_dist/* findClusterBreak */.zK)(line.text, pos - line.from, true) + line.from;
    return {
      changes: {
        from,
        to,
        insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos))
      },
      range: state_dist/* EditorSelection */.OF.cursor(to)
    };
  });
  if (changes.changes.empty) return false;
  dispatch(state.update(changes, {
    scrollIntoView: true,
    userEvent: "move.character"
  }));
  return true;
};
function selectedLineBlocks(state) {
  let blocks = [],
    upto = -1;
  for (var _iterator8 = dist_createForOfIteratorHelperLoose(state.selection.ranges), _step8; !(_step8 = _iterator8()).done;) {
    let range = _step8.value;
    let startLine = state.doc.lineAt(range.from),
      endLine = state.doc.lineAt(range.to);
    if (!range.empty && range.to == endLine.from) endLine = state.doc.lineAt(range.to - 1);
    if (upto >= startLine.number) {
      let prev = blocks[blocks.length - 1];
      prev.to = endLine.to;
      prev.ranges.push(range);
    } else {
      blocks.push({
        from: startLine.from,
        to: endLine.to,
        ranges: [range]
      });
    }
    upto = endLine.number + 1;
  }
  return blocks;
}
function moveLine(state, dispatch, forward) {
  if (state.readOnly) return false;
  let changes = [],
    ranges = [];
  for (var _iterator9 = dist_createForOfIteratorHelperLoose(selectedLineBlocks(state)), _step9; !(_step9 = _iterator9()).done;) {
    let block = _step9.value;
    if (forward ? block.to == state.doc.length : block.from == 0) continue;
    let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
    let size = nextLine.length + 1;
    if (forward) {
      changes.push({
        from: block.to,
        to: nextLine.to
      }, {
        from: block.from,
        insert: nextLine.text + state.lineBreak
      });
      for (var _iterator10 = dist_createForOfIteratorHelperLoose(block.ranges), _step10; !(_step10 = _iterator10()).done;) {
        let r = _step10.value;
        ranges.push(state_dist/* EditorSelection */.OF.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
      }
    } else {
      changes.push({
        from: nextLine.from,
        to: block.from
      }, {
        from: block.to,
        insert: state.lineBreak + nextLine.text
      });
      for (var _iterator11 = dist_createForOfIteratorHelperLoose(block.ranges), _step11; !(_step11 = _iterator11()).done;) {
        let r = _step11.value;
        ranges.push(state_dist/* EditorSelection */.OF.range(r.anchor - size, r.head - size));
      }
    }
  }
  if (!changes.length) return false;
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    selection: state_dist/* EditorSelection */.OF.create(ranges, state.selection.mainIndex),
    userEvent: "move.line"
  }));
  return true;
}
const moveLineUp = _ref19 => {
  let {
    state,
    dispatch
  } = _ref19;
  return moveLine(state, dispatch, false);
};
const moveLineDown = _ref20 => {
  let {
    state,
    dispatch
  } = _ref20;
  return moveLine(state, dispatch, true);
};
function copyLine(state, dispatch, forward) {
  if (state.readOnly) return false;
  let changes = [];
  for (var _iterator12 = dist_createForOfIteratorHelperLoose(selectedLineBlocks(state)), _step12; !(_step12 = _iterator12()).done;) {
    let block = _step12.value;
    if (forward) changes.push({
      from: block.from,
      insert: state.doc.slice(block.from, block.to) + state.lineBreak
    });else changes.push({
      from: block.to,
      insert: state.lineBreak + state.doc.slice(block.from, block.to)
    });
  }
  dispatch(state.update({
    changes,
    scrollIntoView: true,
    userEvent: "input.copyline"
  }));
  return true;
}
const copyLineUp = _ref21 => {
  let {
    state,
    dispatch
  } = _ref21;
  return copyLine(state, dispatch, false);
};
const copyLineDown = _ref22 => {
  let {
    state,
    dispatch
  } = _ref22;
  return copyLine(state, dispatch, true);
};
const deleteLine = view => {
  if (view.state.readOnly) return false;
  let {
      state
    } = view,
    changes = state.changes(selectedLineBlocks(state).map(_ref23 => {
      let {
        from,
        to
      } = _ref23;
      if (from > 0) from--;else if (to < state.doc.length) to++;
      return {
        from,
        to
      };
    }));
  let selection = updateSel(state.selection, range => {
    let dist = undefined;
    if (view.lineWrapping) {
      let block = view.lineBlockAt(range.head),
        pos = view.coordsAtPos(range.head, range.assoc || 1);
      if (pos) dist = block.bottom + view.documentTop - pos.bottom + view.defaultLineHeight / 2;
    }
    return view.moveVertically(range, true, dist);
  }).map(changes);
  view.dispatch({
    changes,
    selection,
    scrollIntoView: true,
    userEvent: "delete.line"
  });
  return true;
};
const insertNewline = _ref24 => {
  let {
    state,
    dispatch
  } = _ref24;
  dispatch(state.update(state.replaceSelection(state.lineBreak), {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};
const insertNewlineKeepIndent = _ref25 => {
  let {
    state,
    dispatch
  } = _ref25;
  dispatch(state.update(state.changeByRange(range => {
    let indent = /^\s*/.exec(state.doc.lineAt(range.from).text)[0];
    return {
      changes: {
        from: range.from,
        to: range.to,
        insert: state.lineBreak + indent
      },
      range: EditorSelection.cursor(range.from + indent.length + 1)
    };
  }), {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};
function isBetweenBrackets(state, pos) {
  if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1))) return {
    from: pos,
    to: pos
  };
  let context = (0,language_dist/* syntaxTree */.mv)(state).resolveInner(pos);
  let before = context.childBefore(pos),
    after = context.childAfter(pos),
    closedBy;
  if (before && after && before.to <= pos && after.from >= pos && (closedBy = before.type.prop(common_dist/* NodeProp */.uY.closedBy)) && closedBy.indexOf(after.name) > -1 && state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from && !/\S/.test(state.sliceDoc(before.to, after.from))) return {
    from: before.to,
    to: after.from
  };
  return null;
}
const insertNewlineAndIndent = newlineAndIndent(false);
const insertBlankLine = newlineAndIndent(true);
function newlineAndIndent(atEof) {
  return _ref26 => {
    let {
      state,
      dispatch
    } = _ref26;
    if (state.readOnly) return false;
    let changes = state.changeByRange(range => {
      let {
          from,
          to
        } = range,
        line = state.doc.lineAt(from);
      let explode = !atEof && from == to && isBetweenBrackets(state, from);
      if (atEof) from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
      let cx = new language_dist/* IndentContext */.KB(state, {
        simulateBreak: from,
        simulateDoubleBreak: !!explode
      });
      let indent = (0,language_dist/* getIndentation */._v)(cx, from);
      if (indent == null) indent = (0,state_dist/* countColumn */.y$)(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
      while (to < line.to && /\s/.test(line.text[to - line.from])) to++;
      if (explode) ({
        from,
        to
      } = explode);else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from))) from = line.from;
      let insert = ["", (0,language_dist/* indentString */.EI)(state, indent)];
      if (explode) insert.push((0,language_dist/* indentString */.EI)(state, cx.lineIndent(line.from, -1)));
      return {
        changes: {
          from,
          to,
          insert: state_dist/* Text */.EY.of(insert)
        },
        range: state_dist/* EditorSelection */.OF.cursor(from + 1 + insert[1].length)
      };
    });
    dispatch(state.update(changes, {
      scrollIntoView: true,
      userEvent: "input"
    }));
    return true;
  };
}
function changeBySelectedLine(state, f) {
  let atLine = -1;
  return state.changeByRange(range => {
    let changes = [];
    for (let pos = range.from; pos <= range.to;) {
      let line = state.doc.lineAt(pos);
      if (line.number > atLine && (range.empty || range.to > line.from)) {
        f(line, changes, range);
        atLine = line.number;
      }
      pos = line.to + 1;
    }
    let changeSet = state.changes(changes);
    return {
      changes,
      range: state_dist/* EditorSelection */.OF.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1))
    };
  });
}
const indentSelection = _ref27 => {
  let {
    state,
    dispatch
  } = _ref27;
  if (state.readOnly) return false;
  let updated = Object.create(null);
  let context = new language_dist/* IndentContext */.KB(state, {
    overrideIndentation: start => {
      let found = updated[start];
      return found == null ? -1 : found;
    }
  });
  let changes = changeBySelectedLine(state, (line, changes, range) => {
    let indent = (0,language_dist/* getIndentation */._v)(context, line.from);
    if (indent == null) return;
    if (!/\S/.test(line.text)) indent = 0;
    let cur = /^\s*/.exec(line.text)[0];
    let norm = (0,language_dist/* indentString */.EI)(state, indent);
    if (cur != norm || range.from < line.from + cur.length) {
      updated[line.from] = indent;
      changes.push({
        from: line.from,
        to: line.from + cur.length,
        insert: norm
      });
    }
  });
  if (!changes.changes.empty) dispatch(state.update(changes, {
    userEvent: "indent"
  }));
  return true;
};
const indentMore = _ref28 => {
  let {
    state,
    dispatch
  } = _ref28;
  if (state.readOnly) return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    changes.push({
      from: line.from,
      insert: state.facet(language_dist/* indentUnit */.Xt)
    });
  }), {
    userEvent: "input.indent"
  }));
  return true;
};
const indentLess = _ref29 => {
  let {
    state,
    dispatch
  } = _ref29;
  if (state.readOnly) return false;
  dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
    let space = /^\s*/.exec(line.text)[0];
    if (!space) return;
    let col = (0,state_dist/* countColumn */.y$)(space, state.tabSize),
      keep = 0;
    let insert = (0,language_dist/* indentString */.EI)(state, Math.max(0, col - (0,language_dist/* getIndentUnit */.tp)(state)));
    while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep)) keep++;
    changes.push({
      from: line.from + keep,
      to: line.from + space.length,
      insert: insert.slice(keep)
    });
  }), {
    userEvent: "delete.dedent"
  }));
  return true;
};
const toggleTabFocusMode = view => {
  view.setTabFocusMode();
  return true;
};
const temporarilySetTabFocusMode = view => {
  view.setTabFocusMode(2000);
  return true;
};
const insertTab = _ref30 => {
  let {
    state,
    dispatch
  } = _ref30;
  if (state.selection.ranges.some(r => !r.empty)) return indentMore({
    state,
    dispatch
  });
  dispatch(state.update(state.replaceSelection("\t"), {
    scrollIntoView: true,
    userEvent: "input"
  }));
  return true;
};
const emacsStyleKeymap = [{
  key: "Ctrl-b",
  run: cursorCharLeft,
  shift: selectCharLeft,
  preventDefault: true
}, {
  key: "Ctrl-f",
  run: cursorCharRight,
  shift: selectCharRight
}, {
  key: "Ctrl-p",
  run: cursorLineUp,
  shift: selectLineUp
}, {
  key: "Ctrl-n",
  run: cursorLineDown,
  shift: selectLineDown
}, {
  key: "Ctrl-a",
  run: cursorLineStart,
  shift: selectLineStart
}, {
  key: "Ctrl-e",
  run: cursorLineEnd,
  shift: selectLineEnd
}, {
  key: "Ctrl-d",
  run: deleteCharForward
}, {
  key: "Ctrl-h",
  run: deleteCharBackward
}, {
  key: "Ctrl-k",
  run: deleteToLineEnd
}, {
  key: "Ctrl-Alt-h",
  run: deleteGroupBackward
}, {
  key: "Ctrl-o",
  run: splitLine
}, {
  key: "Ctrl-t",
  run: transposeChars
}, {
  key: "Ctrl-v",
  run: cursorPageDown
}];
const standardKeymap = [{
  key: "ArrowLeft",
  run: cursorCharLeft,
  shift: selectCharLeft,
  preventDefault: true
}, {
  key: "Mod-ArrowLeft",
  mac: "Alt-ArrowLeft",
  run: cursorGroupLeft,
  shift: selectGroupLeft,
  preventDefault: true
}, {
  mac: "Cmd-ArrowLeft",
  run: cursorLineBoundaryLeft,
  shift: selectLineBoundaryLeft,
  preventDefault: true
}, {
  key: "ArrowRight",
  run: cursorCharRight,
  shift: selectCharRight,
  preventDefault: true
}, {
  key: "Mod-ArrowRight",
  mac: "Alt-ArrowRight",
  run: cursorGroupRight,
  shift: selectGroupRight,
  preventDefault: true
}, {
  mac: "Cmd-ArrowRight",
  run: cursorLineBoundaryRight,
  shift: selectLineBoundaryRight,
  preventDefault: true
}, {
  key: "ArrowUp",
  run: cursorLineUp,
  shift: selectLineUp,
  preventDefault: true
}, {
  mac: "Cmd-ArrowUp",
  run: cursorDocStart,
  shift: selectDocStart
}, {
  mac: "Ctrl-ArrowUp",
  run: cursorPageUp,
  shift: selectPageUp
}, {
  key: "ArrowDown",
  run: cursorLineDown,
  shift: selectLineDown,
  preventDefault: true
}, {
  mac: "Cmd-ArrowDown",
  run: cursorDocEnd,
  shift: selectDocEnd
}, {
  mac: "Ctrl-ArrowDown",
  run: cursorPageDown,
  shift: selectPageDown
}, {
  key: "PageUp",
  run: cursorPageUp,
  shift: selectPageUp
}, {
  key: "PageDown",
  run: cursorPageDown,
  shift: selectPageDown
}, {
  key: "Home",
  run: cursorLineBoundaryBackward,
  shift: selectLineBoundaryBackward,
  preventDefault: true
}, {
  key: "Mod-Home",
  run: cursorDocStart,
  shift: selectDocStart
}, {
  key: "End",
  run: cursorLineBoundaryForward,
  shift: selectLineBoundaryForward,
  preventDefault: true
}, {
  key: "Mod-End",
  run: cursorDocEnd,
  shift: selectDocEnd
}, {
  key: "Enter",
  run: insertNewlineAndIndent,
  shift: insertNewlineAndIndent
}, {
  key: "Mod-a",
  run: selectAll
}, {
  key: "Backspace",
  run: deleteCharBackward,
  shift: deleteCharBackward
}, {
  key: "Delete",
  run: deleteCharForward
}, {
  key: "Mod-Backspace",
  mac: "Alt-Backspace",
  run: deleteGroupBackward
}, {
  key: "Mod-Delete",
  mac: "Alt-Delete",
  run: deleteGroupForward
}, {
  mac: "Mod-Backspace",
  run: deleteLineBoundaryBackward
}, {
  mac: "Mod-Delete",
  run: deleteLineBoundaryForward
}].concat(emacsStyleKeymap.map(b => ({
  mac: b.key,
  run: b.run,
  shift: b.shift
})));
const defaultKeymap = [{
  key: "Alt-ArrowLeft",
  mac: "Ctrl-ArrowLeft",
  run: cursorSyntaxLeft,
  shift: selectSyntaxLeft
}, {
  key: "Alt-ArrowRight",
  mac: "Ctrl-ArrowRight",
  run: cursorSyntaxRight,
  shift: selectSyntaxRight
}, {
  key: "Alt-ArrowUp",
  run: moveLineUp
}, {
  key: "Shift-Alt-ArrowUp",
  run: copyLineUp
}, {
  key: "Alt-ArrowDown",
  run: moveLineDown
}, {
  key: "Shift-Alt-ArrowDown",
  run: copyLineDown
}, {
  key: "Escape",
  run: simplifySelection
}, {
  key: "Mod-Enter",
  run: insertBlankLine
}, {
  key: "Alt-l",
  mac: "Ctrl-l",
  run: selectLine
}, {
  key: "Mod-i",
  run: selectParentSyntax,
  preventDefault: true
}, {
  key: "Mod-[",
  run: indentLess
}, {
  key: "Mod-]",
  run: indentMore
}, {
  key: "Mod-Alt-\\",
  run: indentSelection
}, {
  key: "Shift-Mod-k",
  run: deleteLine
}, {
  key: "Shift-Mod-\\",
  run: cursorMatchingBracket
}, {
  key: "Mod-/",
  run: toggleComment
}, {
  key: "Alt-A",
  run: toggleBlockComment
}, {
  key: "Ctrl-m",
  mac: "Shift-Alt-m",
  run: toggleTabFocusMode
}].concat(standardKeymap);
const indentWithTab = {
  key: "Tab",
  run: indentMore,
  shift: indentLess
};

;// ./node_modules/@codemirror/language-data/dist/index.js

function legacy(parser) {
  return new language_dist/* LanguageSupport */.Yy(language_dist/* StreamLanguage */.Tg.define(parser));
}
function sql(dialectName) {
  return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(7859)]).then(__webpack_require__.bind(__webpack_require__, 7859)).then(m => m.sql({
    dialect: m[dialectName]
  }));
}
const languages = [language_dist/* LanguageDescription */.t$.of({
  name: "C",
  extensions: ["c", "h", "ino"],
  load() {
    return __webpack_require__.e(/* import() */ 5178).then(__webpack_require__.bind(__webpack_require__, 5178)).then(m => m.cpp());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "C++",
  alias: ["cpp"],
  extensions: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"],
  load() {
    return __webpack_require__.e(/* import() */ 5178).then(__webpack_require__.bind(__webpack_require__, 5178)).then(m => m.cpp());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "CQL",
  alias: ["cassandra"],
  extensions: ["cql"],
  load() {
    return sql("Cassandra");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "CSS",
  extensions: ["css"],
  load() {
    return __webpack_require__.e(/* import() */ 6025).then(__webpack_require__.bind(__webpack_require__, 6025)).then(m => m.css());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Go",
  extensions: ["go"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(7541)]).then(__webpack_require__.bind(__webpack_require__, 7541)).then(m => m.go());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "HTML",
  alias: ["xhtml"],
  extensions: ["html", "htm", "handlebars", "hbs"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(6025), __webpack_require__.e(4527), __webpack_require__.e(5464)]).then(__webpack_require__.bind(__webpack_require__, 5464)).then(m => m.html());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Java",
  extensions: ["java"],
  load() {
    return __webpack_require__.e(/* import() */ 1972).then(__webpack_require__.bind(__webpack_require__, 1972)).then(m => m.java());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "JavaScript",
  alias: ["ecmascript", "js", "node"],
  extensions: ["js", "mjs", "cjs"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(4527)]).then(__webpack_require__.bind(__webpack_require__, 4527)).then(m => m.javascript());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "JSON",
  alias: ["json5"],
  extensions: ["json", "map"],
  load() {
    return Promise.resolve(/* import() */).then(__webpack_require__.bind(__webpack_require__, 2866)).then(m => m.json());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "JSX",
  extensions: ["jsx"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(4527)]).then(__webpack_require__.bind(__webpack_require__, 4527)).then(m => m.javascript({
      jsx: true
    }));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "LESS",
  extensions: ["less"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(6025), __webpack_require__.e(4128)]).then(__webpack_require__.bind(__webpack_require__, 4128)).then(m => m.less());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Liquid",
  extensions: ["liquid"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(6025), __webpack_require__.e(4527), __webpack_require__.e(5464), __webpack_require__.e(1863)]).then(__webpack_require__.bind(__webpack_require__, 1863)).then(m => m.liquid());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "MariaDB SQL",
  load() {
    return sql("MariaSQL");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Markdown",
  extensions: ["md", "markdown", "mkd"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(6025), __webpack_require__.e(4527), __webpack_require__.e(5464), __webpack_require__.e(4912)]).then(__webpack_require__.bind(__webpack_require__, 4912)).then(m => m.markdown());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "MS SQL",
  load() {
    return sql("MSSQL");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "MySQL",
  load() {
    return sql("MySQL");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "PHP",
  extensions: ["php", "php3", "php4", "php5", "php7", "phtml"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(6025), __webpack_require__.e(4527), __webpack_require__.e(5464), __webpack_require__.e(8783)]).then(__webpack_require__.bind(__webpack_require__, 8783)).then(m => m.php());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "PLSQL",
  extensions: ["pls"],
  load() {
    return sql("PLSQL");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "PostgreSQL",
  load() {
    return sql("PostgreSQL");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Python",
  extensions: ["BUILD", "bzl", "py", "pyw"],
  filename: /^(BUCK|BUILD)$/,
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(5679)]).then(__webpack_require__.bind(__webpack_require__, 5679)).then(m => m.python());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Rust",
  extensions: ["rs"],
  load() {
    return __webpack_require__.e(/* import() */ 390).then(__webpack_require__.bind(__webpack_require__, 390)).then(m => m.rust());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Sass",
  extensions: ["sass"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(6025), __webpack_require__.e(2495)]).then(__webpack_require__.bind(__webpack_require__, 2495)).then(m => m.sass({
      indented: true
    }));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "SCSS",
  extensions: ["scss"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(6025), __webpack_require__.e(2495)]).then(__webpack_require__.bind(__webpack_require__, 2495)).then(m => m.sass());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "SQL",
  extensions: ["sql"],
  load() {
    return sql("StandardSQL");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "SQLite",
  load() {
    return sql("SQLite");
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "TSX",
  extensions: ["tsx"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(4527)]).then(__webpack_require__.bind(__webpack_require__, 4527)).then(m => m.javascript({
      jsx: true,
      typescript: true
    }));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "TypeScript",
  alias: ["ts"],
  extensions: ["ts", "mts", "cts"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(4527)]).then(__webpack_require__.bind(__webpack_require__, 4527)).then(m => m.javascript({
      typescript: true
    }));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "WebAssembly",
  extensions: ["wat", "wast"],
  load() {
    return __webpack_require__.e(/* import() */ 9818).then(__webpack_require__.bind(__webpack_require__, 9818)).then(m => m.wast());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "XML",
  alias: ["rss", "wsdl", "xsd"],
  extensions: ["xml", "xsl", "xsd", "svg"],
  load() {
    return __webpack_require__.e(/* import() */ 6090).then(__webpack_require__.bind(__webpack_require__, 6090)).then(m => m.xml());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "YAML",
  alias: ["yml"],
  extensions: ["yaml", "yml"],
  load() {
    return __webpack_require__.e(/* import() */ 3655).then(__webpack_require__.bind(__webpack_require__, 3655)).then(m => m.yaml());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "APL",
  extensions: ["dyalog", "apl"],
  load() {
    return __webpack_require__.e(/* import() */ 5854).then(__webpack_require__.bind(__webpack_require__, 5854)).then(m => legacy(m.apl));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "PGP",
  alias: ["asciiarmor"],
  extensions: ["asc", "pgp", "sig"],
  load() {
    return __webpack_require__.e(/* import() */ 7175).then(__webpack_require__.bind(__webpack_require__, 7175)).then(m => legacy(m.asciiArmor));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "ASN.1",
  extensions: ["asn", "asn1"],
  load() {
    return __webpack_require__.e(/* import() */ 1336).then(__webpack_require__.bind(__webpack_require__, 1336)).then(m => legacy(m.asn1({})));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Asterisk",
  filename: /^extensions\.conf$/i,
  load() {
    return __webpack_require__.e(/* import() */ 4809).then(__webpack_require__.bind(__webpack_require__, 4809)).then(m => legacy(m.asterisk));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Brainfuck",
  extensions: ["b", "bf"],
  load() {
    return __webpack_require__.e(/* import() */ 1646).then(__webpack_require__.bind(__webpack_require__, 1646)).then(m => legacy(m.brainfuck));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Cobol",
  extensions: ["cob", "cpy"],
  load() {
    return __webpack_require__.e(/* import() */ 8114).then(__webpack_require__.bind(__webpack_require__, 8114)).then(m => legacy(m.cobol));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "C#",
  alias: ["csharp", "cs"],
  extensions: ["cs"],
  load() {
    return __webpack_require__.e(/* import() */ 6095).then(__webpack_require__.bind(__webpack_require__, 6095)).then(m => legacy(m.csharp));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Clojure",
  extensions: ["clj", "cljc", "cljx"],
  load() {
    return __webpack_require__.e(/* import() */ 4613).then(__webpack_require__.bind(__webpack_require__, 4613)).then(m => legacy(m.clojure));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "ClojureScript",
  extensions: ["cljs"],
  load() {
    return __webpack_require__.e(/* import() */ 4613).then(__webpack_require__.bind(__webpack_require__, 4613)).then(m => legacy(m.clojure));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Closure Stylesheets (GSS)",
  extensions: ["gss"],
  load() {
    return __webpack_require__.e(/* import() */ 3506).then(__webpack_require__.bind(__webpack_require__, 3506)).then(m => legacy(m.gss));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "CMake",
  extensions: ["cmake", "cmake.in"],
  filename: /^CMakeLists\.txt$/,
  load() {
    return __webpack_require__.e(/* import() */ 8058).then(__webpack_require__.bind(__webpack_require__, 8058)).then(m => legacy(m.cmake));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "CoffeeScript",
  alias: ["coffee", "coffee-script"],
  extensions: ["coffee"],
  load() {
    return __webpack_require__.e(/* import() */ 2934).then(__webpack_require__.bind(__webpack_require__, 2934)).then(m => legacy(m.coffeeScript));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Common Lisp",
  alias: ["lisp"],
  extensions: ["cl", "lisp", "el"],
  load() {
    return __webpack_require__.e(/* import() */ 5732).then(__webpack_require__.bind(__webpack_require__, 5732)).then(m => legacy(m.commonLisp));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Cypher",
  extensions: ["cyp", "cypher"],
  load() {
    return __webpack_require__.e(/* import() */ 4842).then(__webpack_require__.bind(__webpack_require__, 4842)).then(m => legacy(m.cypher));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Cython",
  extensions: ["pyx", "pxd", "pxi"],
  load() {
    return __webpack_require__.e(/* import() */ 9563).then(__webpack_require__.bind(__webpack_require__, 9563)).then(m => legacy(m.cython));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Crystal",
  extensions: ["cr"],
  load() {
    return __webpack_require__.e(/* import() */ 8243).then(__webpack_require__.bind(__webpack_require__, 8243)).then(m => legacy(m.crystal));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "D",
  extensions: ["d"],
  load() {
    return __webpack_require__.e(/* import() */ 2717).then(__webpack_require__.bind(__webpack_require__, 2717)).then(m => legacy(m.d));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Dart",
  extensions: ["dart"],
  load() {
    return __webpack_require__.e(/* import() */ 6095).then(__webpack_require__.bind(__webpack_require__, 6095)).then(m => legacy(m.dart));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "diff",
  extensions: ["diff", "patch"],
  load() {
    return __webpack_require__.e(/* import() */ 4274).then(__webpack_require__.bind(__webpack_require__, 4274)).then(m => legacy(m.diff));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Dockerfile",
  filename: /^Dockerfile$/,
  load() {
    return __webpack_require__.e(/* import() */ 5671).then(__webpack_require__.bind(__webpack_require__, 5671)).then(m => legacy(m.dockerFile));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "DTD",
  extensions: ["dtd"],
  load() {
    return __webpack_require__.e(/* import() */ 1661).then(__webpack_require__.bind(__webpack_require__, 1661)).then(m => legacy(m.dtd));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Dylan",
  extensions: ["dylan", "dyl", "intr"],
  load() {
    return __webpack_require__.e(/* import() */ 6643).then(__webpack_require__.bind(__webpack_require__, 6643)).then(m => legacy(m.dylan));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "EBNF",
  load() {
    return __webpack_require__.e(/* import() */ 2294).then(__webpack_require__.bind(__webpack_require__, 2294)).then(m => legacy(m.ebnf));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "ECL",
  extensions: ["ecl"],
  load() {
    return __webpack_require__.e(/* import() */ 6589).then(__webpack_require__.bind(__webpack_require__, 6589)).then(m => legacy(m.ecl));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "edn",
  extensions: ["edn"],
  load() {
    return __webpack_require__.e(/* import() */ 4613).then(__webpack_require__.bind(__webpack_require__, 4613)).then(m => legacy(m.clojure));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Eiffel",
  extensions: ["e"],
  load() {
    return __webpack_require__.e(/* import() */ 1874).then(__webpack_require__.bind(__webpack_require__, 1874)).then(m => legacy(m.eiffel));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Elm",
  extensions: ["elm"],
  load() {
    return __webpack_require__.e(/* import() */ 7693).then(__webpack_require__.bind(__webpack_require__, 7693)).then(m => legacy(m.elm));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Erlang",
  extensions: ["erl"],
  load() {
    return __webpack_require__.e(/* import() */ 782).then(__webpack_require__.bind(__webpack_require__, 782)).then(m => legacy(m.erlang));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Esper",
  load() {
    return __webpack_require__.e(/* import() */ 8177).then(__webpack_require__.bind(__webpack_require__, 8177)).then(m => legacy(m.esper));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Factor",
  extensions: ["factor"],
  load() {
    return __webpack_require__.e(/* import() */ 1366).then(__webpack_require__.bind(__webpack_require__, 1366)).then(m => legacy(m.factor));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "FCL",
  load() {
    return __webpack_require__.e(/* import() */ 7064).then(__webpack_require__.bind(__webpack_require__, 7064)).then(m => legacy(m.fcl));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Forth",
  extensions: ["forth", "fth", "4th"],
  load() {
    return __webpack_require__.e(/* import() */ 4926).then(__webpack_require__.bind(__webpack_require__, 4926)).then(m => legacy(m.forth));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Fortran",
  extensions: ["f", "for", "f77", "f90", "f95"],
  load() {
    return __webpack_require__.e(/* import() */ 2219).then(__webpack_require__.bind(__webpack_require__, 2219)).then(m => legacy(m.fortran));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "F#",
  alias: ["fsharp"],
  extensions: ["fs"],
  load() {
    return __webpack_require__.e(/* import() */ 8551).then(__webpack_require__.bind(__webpack_require__, 8551)).then(m => legacy(m.fSharp));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Gas",
  extensions: ["s"],
  load() {
    return __webpack_require__.e(/* import() */ 2472).then(__webpack_require__.bind(__webpack_require__, 2472)).then(m => legacy(m.gas));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Gherkin",
  extensions: ["feature"],
  load() {
    return __webpack_require__.e(/* import() */ 4827).then(__webpack_require__.bind(__webpack_require__, 4827)).then(m => legacy(m.gherkin));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Groovy",
  extensions: ["groovy", "gradle"],
  filename: /^Jenkinsfile$/,
  load() {
    return __webpack_require__.e(/* import() */ 3191).then(__webpack_require__.bind(__webpack_require__, 3191)).then(m => legacy(m.groovy));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Haskell",
  extensions: ["hs"],
  load() {
    return __webpack_require__.e(/* import() */ 4669).then(__webpack_require__.bind(__webpack_require__, 4669)).then(m => legacy(m.haskell));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Haxe",
  extensions: ["hx"],
  load() {
    return __webpack_require__.e(/* import() */ 9929).then(__webpack_require__.bind(__webpack_require__, 9929)).then(m => legacy(m.haxe));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "HXML",
  extensions: ["hxml"],
  load() {
    return __webpack_require__.e(/* import() */ 9929).then(__webpack_require__.bind(__webpack_require__, 9929)).then(m => legacy(m.hxml));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "HTTP",
  load() {
    return __webpack_require__.e(/* import() */ 1877).then(__webpack_require__.bind(__webpack_require__, 1877)).then(m => legacy(m.http));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "IDL",
  extensions: ["pro"],
  load() {
    return __webpack_require__.e(/* import() */ 2325).then(__webpack_require__.bind(__webpack_require__, 4706)).then(m => legacy(m.idl));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "JSON-LD",
  alias: ["jsonld"],
  extensions: ["jsonld"],
  load() {
    return __webpack_require__.e(/* import() */ 8170).then(__webpack_require__.bind(__webpack_require__, 8170)).then(m => legacy(m.jsonld));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Jinja2",
  extensions: ["j2", "jinja", "jinja2"],
  load() {
    return __webpack_require__.e(/* import() */ 4783).then(__webpack_require__.bind(__webpack_require__, 4783)).then(m => legacy(m.jinja2));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Julia",
  extensions: ["jl"],
  load() {
    return __webpack_require__.e(/* import() */ 5440).then(__webpack_require__.bind(__webpack_require__, 5440)).then(m => legacy(m.julia));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Kotlin",
  extensions: ["kt", "kts"],
  load() {
    return __webpack_require__.e(/* import() */ 6095).then(__webpack_require__.bind(__webpack_require__, 6095)).then(m => legacy(m.kotlin));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "LiveScript",
  alias: ["ls"],
  extensions: ["ls"],
  load() {
    return __webpack_require__.e(/* import() */ 6072).then(__webpack_require__.bind(__webpack_require__, 6072)).then(m => legacy(m.liveScript));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Lua",
  extensions: ["lua"],
  load() {
    return __webpack_require__.e(/* import() */ 203).then(__webpack_require__.bind(__webpack_require__, 203)).then(m => legacy(m.lua));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "mIRC",
  extensions: ["mrc"],
  load() {
    return __webpack_require__.e(/* import() */ 5744).then(__webpack_require__.bind(__webpack_require__, 5744)).then(m => legacy(m.mirc));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Mathematica",
  extensions: ["m", "nb", "wl", "wls"],
  load() {
    return __webpack_require__.e(/* import() */ 9413).then(__webpack_require__.bind(__webpack_require__, 9413)).then(m => legacy(m.mathematica));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Modelica",
  extensions: ["mo"],
  load() {
    return __webpack_require__.e(/* import() */ 8545).then(__webpack_require__.bind(__webpack_require__, 8545)).then(m => legacy(m.modelica));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "MUMPS",
  extensions: ["mps"],
  load() {
    return __webpack_require__.e(/* import() */ 5845).then(__webpack_require__.bind(__webpack_require__, 5845)).then(m => legacy(m.mumps));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Mbox",
  extensions: ["mbox"],
  load() {
    return __webpack_require__.e(/* import() */ 3269).then(__webpack_require__.bind(__webpack_require__, 3269)).then(m => legacy(m.mbox));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Nginx",
  filename: /nginx.*\.conf$/i,
  load() {
    return __webpack_require__.e(/* import() */ 1289).then(__webpack_require__.bind(__webpack_require__, 1289)).then(m => legacy(m.nginx));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "NSIS",
  extensions: ["nsh", "nsi"],
  load() {
    return __webpack_require__.e(/* import() */ 5238).then(__webpack_require__.bind(__webpack_require__, 5238)).then(m => legacy(m.nsis));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "NTriples",
  extensions: ["nt", "nq"],
  load() {
    return __webpack_require__.e(/* import() */ 9670).then(__webpack_require__.bind(__webpack_require__, 9670)).then(m => legacy(m.ntriples));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Objective-C",
  alias: ["objective-c", "objc"],
  extensions: ["m"],
  load() {
    return __webpack_require__.e(/* import() */ 6095).then(__webpack_require__.bind(__webpack_require__, 6095)).then(m => legacy(m.objectiveC));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Objective-C++",
  alias: ["objective-c++", "objc++"],
  extensions: ["mm"],
  load() {
    return __webpack_require__.e(/* import() */ 6095).then(__webpack_require__.bind(__webpack_require__, 6095)).then(m => legacy(m.objectiveCpp));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "OCaml",
  extensions: ["ml", "mli", "mll", "mly"],
  load() {
    return __webpack_require__.e(/* import() */ 8551).then(__webpack_require__.bind(__webpack_require__, 8551)).then(m => legacy(m.oCaml));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Octave",
  extensions: ["m"],
  load() {
    return __webpack_require__.e(/* import() */ 6777).then(__webpack_require__.bind(__webpack_require__, 6777)).then(m => legacy(m.octave));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Oz",
  extensions: ["oz"],
  load() {
    return __webpack_require__.e(/* import() */ 4196).then(__webpack_require__.bind(__webpack_require__, 4196)).then(m => legacy(m.oz));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Pascal",
  extensions: ["p", "pas"],
  load() {
    return __webpack_require__.e(/* import() */ 6137).then(__webpack_require__.bind(__webpack_require__, 6137)).then(m => legacy(m.pascal));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Perl",
  extensions: ["pl", "pm"],
  load() {
    return __webpack_require__.e(/* import() */ 6655).then(__webpack_require__.bind(__webpack_require__, 9036)).then(m => legacy(m.perl));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Pig",
  extensions: ["pig"],
  load() {
    return __webpack_require__.e(/* import() */ 161).then(__webpack_require__.bind(__webpack_require__, 161)).then(m => legacy(m.pig));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "PowerShell",
  extensions: ["ps1", "psd1", "psm1"],
  load() {
    return __webpack_require__.e(/* import() */ 1676).then(__webpack_require__.bind(__webpack_require__, 1676)).then(m => legacy(m.powerShell));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Properties files",
  alias: ["ini", "properties"],
  extensions: ["properties", "ini", "in"],
  load() {
    return __webpack_require__.e(/* import() */ 9156).then(__webpack_require__.bind(__webpack_require__, 9156)).then(m => legacy(m.properties));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "ProtoBuf",
  extensions: ["proto"],
  load() {
    return __webpack_require__.e(/* import() */ 7958).then(__webpack_require__.bind(__webpack_require__, 7958)).then(m => legacy(m.protobuf));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Pug",
  alias: ["jade"],
  extensions: ["pug", "jade"],
  load() {
    return __webpack_require__.e(/* import() */ 1197).then(__webpack_require__.bind(__webpack_require__, 1197)).then(m => legacy(m.pug));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Puppet",
  extensions: ["pp"],
  load() {
    return __webpack_require__.e(/* import() */ 4615).then(__webpack_require__.bind(__webpack_require__, 4615)).then(m => legacy(m.puppet));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Q",
  extensions: ["q"],
  load() {
    return __webpack_require__.e(/* import() */ 4706).then(__webpack_require__.bind(__webpack_require__, 2325)).then(m => legacy(m.q));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "R",
  alias: ["rscript"],
  extensions: ["r", "R"],
  load() {
    return __webpack_require__.e(/* import() */ 6959).then(__webpack_require__.bind(__webpack_require__, 6959)).then(m => legacy(m.r));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "RPM Changes",
  load() {
    return __webpack_require__.e(/* import() */ 5564).then(__webpack_require__.bind(__webpack_require__, 5564)).then(m => legacy(m.rpmChanges));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "RPM Spec",
  extensions: ["spec"],
  load() {
    return __webpack_require__.e(/* import() */ 5564).then(__webpack_require__.bind(__webpack_require__, 5564)).then(m => legacy(m.rpmSpec));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Ruby",
  alias: ["jruby", "macruby", "rake", "rb", "rbx"],
  extensions: ["rb"],
  filename: /^(Gemfile|Rakefile)$/,
  load() {
    return __webpack_require__.e(/* import() */ 2557).then(__webpack_require__.bind(__webpack_require__, 2557)).then(m => legacy(m.ruby));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "SAS",
  extensions: ["sas"],
  load() {
    return __webpack_require__.e(/* import() */ 9036).then(__webpack_require__.bind(__webpack_require__, 6655)).then(m => legacy(m.sas));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Scala",
  extensions: ["scala"],
  load() {
    return __webpack_require__.e(/* import() */ 6095).then(__webpack_require__.bind(__webpack_require__, 6095)).then(m => legacy(m.scala));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Scheme",
  extensions: ["scm", "ss"],
  load() {
    return __webpack_require__.e(/* import() */ 938).then(__webpack_require__.bind(__webpack_require__, 938)).then(m => legacy(m.scheme));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Shell",
  alias: ["bash", "sh", "zsh"],
  extensions: ["sh", "ksh", "bash"],
  filename: /^PKGBUILD$/,
  load() {
    return __webpack_require__.e(/* import() */ 4595).then(__webpack_require__.bind(__webpack_require__, 4595)).then(m => legacy(m.shell));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Sieve",
  extensions: ["siv", "sieve"],
  load() {
    return __webpack_require__.e(/* import() */ 7415).then(__webpack_require__.bind(__webpack_require__, 7415)).then(m => legacy(m.sieve));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Smalltalk",
  extensions: ["st"],
  load() {
    return __webpack_require__.e(/* import() */ 2232).then(__webpack_require__.bind(__webpack_require__, 2232)).then(m => legacy(m.smalltalk));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Solr",
  load() {
    return __webpack_require__.e(/* import() */ 1249).then(__webpack_require__.bind(__webpack_require__, 1249)).then(m => legacy(m.solr));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "SML",
  extensions: ["sml", "sig", "fun", "smackspec"],
  load() {
    return __webpack_require__.e(/* import() */ 8551).then(__webpack_require__.bind(__webpack_require__, 8551)).then(m => legacy(m.sml));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "SPARQL",
  alias: ["sparul"],
  extensions: ["rq", "sparql"],
  load() {
    return __webpack_require__.e(/* import() */ 3608).then(__webpack_require__.bind(__webpack_require__, 3608)).then(m => legacy(m.sparql));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Spreadsheet",
  alias: ["excel", "formula"],
  load() {
    return __webpack_require__.e(/* import() */ 9019).then(__webpack_require__.bind(__webpack_require__, 9019)).then(m => legacy(m.spreadsheet));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Squirrel",
  extensions: ["nut"],
  load() {
    return __webpack_require__.e(/* import() */ 6095).then(__webpack_require__.bind(__webpack_require__, 6095)).then(m => legacy(m.squirrel));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Stylus",
  extensions: ["styl"],
  load() {
    return __webpack_require__.e(/* import() */ 6307).then(__webpack_require__.bind(__webpack_require__, 6307)).then(m => legacy(m.stylus));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Swift",
  extensions: ["swift"],
  load() {
    return __webpack_require__.e(/* import() */ 2950).then(__webpack_require__.bind(__webpack_require__, 2950)).then(m => legacy(m.swift));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "sTeX",
  load() {
    return __webpack_require__.e(/* import() */ 9631).then(__webpack_require__.bind(__webpack_require__, 9631)).then(m => legacy(m.stex));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "LaTeX",
  alias: ["tex"],
  extensions: ["text", "ltx", "tex"],
  load() {
    return __webpack_require__.e(/* import() */ 9631).then(__webpack_require__.bind(__webpack_require__, 9631)).then(m => legacy(m.stex));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "SystemVerilog",
  extensions: ["v", "sv", "svh"],
  load() {
    return __webpack_require__.e(/* import() */ 6651).then(__webpack_require__.bind(__webpack_require__, 6651)).then(m => legacy(m.verilog));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Tcl",
  extensions: ["tcl"],
  load() {
    return __webpack_require__.e(/* import() */ 4014).then(__webpack_require__.bind(__webpack_require__, 4014)).then(m => legacy(m.tcl));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Textile",
  extensions: ["textile"],
  load() {
    return __webpack_require__.e(/* import() */ 9792).then(__webpack_require__.bind(__webpack_require__, 9792)).then(m => legacy(m.textile));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "TiddlyWiki",
  load() {
    return __webpack_require__.e(/* import() */ 3881).then(__webpack_require__.bind(__webpack_require__, 3881)).then(m => legacy(m.tiddlyWiki));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Tiki wiki",
  load() {
    return __webpack_require__.e(/* import() */ 9766).then(__webpack_require__.bind(__webpack_require__, 9766)).then(m => legacy(m.tiki));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "TOML",
  extensions: ["toml"],
  load() {
    return __webpack_require__.e(/* import() */ 7273).then(__webpack_require__.bind(__webpack_require__, 7273)).then(m => legacy(m.toml));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Troff",
  extensions: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
  load() {
    return __webpack_require__.e(/* import() */ 5590).then(__webpack_require__.bind(__webpack_require__, 5590)).then(m => legacy(m.troff));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "TTCN",
  extensions: ["ttcn", "ttcn3", "ttcnpp"],
  load() {
    return __webpack_require__.e(/* import() */ 6980).then(__webpack_require__.bind(__webpack_require__, 6980)).then(m => legacy(m.ttcn));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "TTCN_CFG",
  extensions: ["cfg"],
  load() {
    return __webpack_require__.e(/* import() */ 8187).then(__webpack_require__.bind(__webpack_require__, 8187)).then(m => legacy(m.ttcnCfg));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Turtle",
  extensions: ["ttl"],
  load() {
    return __webpack_require__.e(/* import() */ 6391).then(__webpack_require__.bind(__webpack_require__, 6391)).then(m => legacy(m.turtle));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Web IDL",
  extensions: ["webidl"],
  load() {
    return __webpack_require__.e(/* import() */ 7396).then(__webpack_require__.bind(__webpack_require__, 7396)).then(m => legacy(m.webIDL));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "VB.NET",
  extensions: ["vb"],
  load() {
    return __webpack_require__.e(/* import() */ 5949).then(__webpack_require__.bind(__webpack_require__, 5949)).then(m => legacy(m.vb));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "VBScript",
  extensions: ["vbs"],
  load() {
    return __webpack_require__.e(/* import() */ 1026).then(__webpack_require__.bind(__webpack_require__, 1026)).then(m => legacy(m.vbScript));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Velocity",
  extensions: ["vtl"],
  load() {
    return __webpack_require__.e(/* import() */ 6530).then(__webpack_require__.bind(__webpack_require__, 6530)).then(m => legacy(m.velocity));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Verilog",
  extensions: ["v"],
  load() {
    return __webpack_require__.e(/* import() */ 6651).then(__webpack_require__.bind(__webpack_require__, 6651)).then(m => legacy(m.verilog));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "VHDL",
  extensions: ["vhd", "vhdl"],
  load() {
    return __webpack_require__.e(/* import() */ 3859).then(__webpack_require__.bind(__webpack_require__, 3859)).then(m => legacy(m.vhdl));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "XQuery",
  extensions: ["xy", "xquery"],
  load() {
    return __webpack_require__.e(/* import() */ 9421).then(__webpack_require__.bind(__webpack_require__, 9421)).then(m => legacy(m.xQuery));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Yacas",
  extensions: ["ys"],
  load() {
    return __webpack_require__.e(/* import() */ 3050).then(__webpack_require__.bind(__webpack_require__, 3050)).then(m => legacy(m.yacas));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Z80",
  extensions: ["z80"],
  load() {
    return __webpack_require__.e(/* import() */ 2367).then(__webpack_require__.bind(__webpack_require__, 2367)).then(m => legacy(m.z80));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "MscGen",
  extensions: ["mscgen", "mscin", "msc"],
  load() {
    return __webpack_require__.e(/* import() */ 6188).then(__webpack_require__.bind(__webpack_require__, 6188)).then(m => legacy(m.mscgen));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Xù",
  extensions: ["xu"],
  load() {
    return __webpack_require__.e(/* import() */ 6188).then(__webpack_require__.bind(__webpack_require__, 6188)).then(m => legacy(m.xu));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "MsGenny",
  extensions: ["msgenny"],
  load() {
    return __webpack_require__.e(/* import() */ 6188).then(__webpack_require__.bind(__webpack_require__, 6188)).then(m => legacy(m.msgenny));
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Vue",
  extensions: ["vue"],
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(6025), __webpack_require__.e(4527), __webpack_require__.e(5464), __webpack_require__.e(6839)]).then(__webpack_require__.bind(__webpack_require__, 6839)).then(m => m.vue());
  }
}), language_dist/* LanguageDescription */.t$.of({
  name: "Angular Template",
  load() {
    return Promise.all(/* import() */[__webpack_require__.e(9932), __webpack_require__.e(6025), __webpack_require__.e(4527), __webpack_require__.e(5464), __webpack_require__.e(8245)]).then(__webpack_require__.bind(__webpack_require__, 8245)).then(m => m.angular());
  }
})];

// EXTERNAL MODULE: ./node_modules/@codemirror/lang-json/dist/index.js + 1 modules
var lang_json_dist = __webpack_require__(2866);
;// ./src/js/utilities/view.js















function fillBreadcrumb(items) {
  let s;
  if (isArray(items)) {
    s = items.map(item => `<li class="breadcrumb-item">${item.replace(/{{ORIGIN_URL}}/g, js_AMIRouter.getOriginURL).replace(/{{WEBAPP_URL}}/g, js_AMIRouter.getWebAppURL())}</li>`).join('');
  } else if (isString(items)) {
    s = items.replace(/{{ORIGIN_URL}}/g, js_AMIRouter.getOriginURL).replace(/{{WEBAPP_URL}}/g, js_AMIRouter.getWebAppURL());
  } else {
    s = '';
  }
  $('#ami_breadcrumb_content').html(s);
}
const _idRegExp = /[a-zA-Z][a-zA-Z0-9]{7}_[a-zA-Z0-9]{4}_[a-zA-Z0-9]{4}_[a-zA-Z0-9]{4}_[a-zA-Z0-9]{12}/g;
let _datetimeFormat = 'yyyy-MM-dd HH:mm:ss.SSSSSS';
let _dateFormat = 'yyyy-MM-dd';
let _timeHMSFormat = 'HH:mm:ss.SSSSSS';
let _timeHMFormat = 'HH:mm';
function _parseDatetime(s, format) {
  format = moment().toMomentFormatString(format);
  return moment(s, format, true).toDate();
}
function _formatDatetime(date, format) {
  format = moment().toMomentFormatString(format);
  return moment(date).format(format);
}
function _injectCodeMirrorStep1(editors) {
  let nb = editors.length;
  const result = $.Deferred();
  const _injectCodeMirrorStep2 = (div, textarea, dynamicLang) => {
    const readOnly = textarea.attr('data-read-only') || 'false';
    const wordWrap = textarea.attr('data-word-wrap') || 'false';
    const showBorder = textarea.attr('data-show-border') || 'true';
    const showGutter = textarea.attr('data-show-gutter') || 'true';
    const rounded = textarea.attr('data-rounded') || 'true';
    const editorLang = new state_dist/* Compartment */.xx();
    const extensions = [state_dist/* EditorState */.$t.tabSize.of(0x00000000000000004), dist/* EditorView */.Lz.editable.of(readOnly !== 'true'), dist/* highlightSpecialChars */.N$(), dist/* keymap */.w4.of([...defaultKeymap, ...historyKeymap]), dist_history(), editorLang.of(dynamicLang), language_dist/* syntaxHighlighting */.y9(language_dist/* defaultHighlightStyle */.Zt, {
      fallback: true
    }), dist/* EditorView */.Lz.theme({
      '&.cm-editor': {
        'fontSize': '13px'
      },
      '.cm-gutters': {
        'border-top-left-radius': rounded === 'true' ? '0.25rem' : '0',
        'border-bottom-left-radius': rounded === 'true' ? '0.25rem' : '0'
      }
    }), dist/* EditorView */.Lz.updateListener.of(update => {
      if (textarea[0].value !== update.state.doc.toString()) {
        textarea[0].value = update.state.doc.toString();
        textarea.trigger('change');
      }
    })];
    if (showBorder === 'true') {
      div.addClass('border');
    }
    if (rounded === 'true') {
      div.addClass('rounded');
    }
    if (showGutter === 'true') {
      extensions.push(dist/* lineNumbers */.$K());
      extensions.push(language_dist/* foldGutter */.Lv());
    }
    if (wordWrap === 'true') {
      extensions.push(dist/* EditorView */.Lz.lineWrapping);
    }
    const editorState = state_dist/* EditorState */.$t.create({
      extensions: extensions,
      doc: textarea.val()
    });
    const editorView = new dist/* EditorView */.Lz({
      state: editorState,
      parent: div[0]
    });
    textarea.data('editorLang', editorLang);
    textarea.data('editorView', editorView);
  };
  editors.each((_, element) => {
    const textarea = $(element);
    const div = $('<div>', {
      'class': textarea.attr('class').replace(/form-editor[\-a-zA-Z]*/g, 'form-editor-codemirror'),
      'style': textarea.attr('style')
    });
    div.insertAfter(textarea).promise().done(() => {
      const descr = language_dist/* LanguageDescription */.t$.matchLanguageName(languages, textarea.attr('data-lang') || 'json');
      if (descr) {
        descr.load().then(dynamicLang => {
          _injectCodeMirrorStep2(div, textarea, dynamicLang);
          if (--nb === 0) {
            result.resolve();
          }
        });
      } else {
        _injectCodeMirrorStep2(div, textarea, (0,lang_json_dist.json)());
        if (--nb === 0) {
          result.resolve();
        }
      }
    });
  });
  return result;
}
function _xxxHTML(selector, twig, mode, options) {
  const result = $.Deferred();
  const [context, scope, dict, twigs] = setup(['context', 'scope', 'dict', 'twigs'], [result, null, {}, {}], options);
  if (scope) {
    twig = twig.replace(_idRegExp, id => {
      return `${id}_scope${scope}`;
    });
  }
  const html = formatTWIG(twig, dict, twigs);
  let promise;
  let el = $(selector),
    el2;
  switch (mode) {
    case 0:
      promise = el.html(html).promise();
      break;
    case 1:
      promise = el.prepend(html).promise();
      break;
    case 2:
      promise = el.append(html).promise();
      break;
    case 3:
      el2 = $(el.is('[id]') ? html.replace(/^\s*(<[a-zA-Z_-]+)/, `$1 id="${el.attr('id')}"`) : html);
      promise = el.replaceWith(el2).promise();
      el = el2;
      break;
    default:
      throw 'internal error';
  }
  promise.done(() => {
    const _find = mode === 3 ? _selector => el.find(_selector).addBack(_selector) : _selector => el.find(_selector);
    if (js_AMIWebApp.bootstrapVersion < 5) {
      _find('*').each((idx, element) => {
        $(element.attributes).each((idx, attribute) => {
          if (attribute.name.startsWith('data-bs-')) {
            element.setAttribute(`data-${attribute.name.substring(8)}`, attribute.value);
          }
        });
      });
    }
    if (jQuery.fn.tooltip) {
      _find('[data-toggle="tooltip"],[data-bs-toggle="tooltip"]').tooltip({
        html: false,
        delay: {
          show: 500,
          hide: 100
        }
      });
    }
    if (jQuery.fn.popover) {
      _find('[data-toggle="popover"],[data-bs-toggle="popover"]').popover({
        html: true,
        delay: {
          show: 500,
          hide: 100
        }
      });
    }
    _find('input.form-datetime').each((_, element) => {
      esm(element, {
        time_24hr: true,
        enableTime: true,
        enableSeconds: true,
        noCalendar: false,
        dateFormat: _datetimeFormat,
        parseDate: _parseDatetime,
        formatDate: _formatDatetime
      });
    });
    _find('input.form-date').each((_, element) => {
      esm(element, {
        time_24hr: true,
        enableTime: false,
        enableSeconds: false,
        noCalendar: false,
        dateFormat: _dateFormat,
        parseDate: _parseDatetime,
        formatDate: _formatDatetime
      });
    });
    _find('input.form-time').each((_, element) => {
      esm(element, {
        time_24hr: true,
        enableTime: true,
        enableSeconds: true,
        noCalendar: true,
        dateFormat: _timeHMSFormat,
        parseDate: _parseDatetime,
        formatDate: _formatDatetime
      });
    });
    _find('input.form-time-hm').each((_, element) => {
      esm(element, {
        time_24hr: true,
        enableTime: true,
        enableSeconds: false,
        noCalendar: true,
        dateFormat: _timeHMFormat,
        parseDate: _parseDatetime,
        formatDate: _formatDatetime
      });
    });
    const editors = _find('.form-editor:not(.form-editor-done)').addClass('form-editor-done');
    if (editors.length > 0) {
      _injectCodeMirrorStep1(editors).done(() => {
        result.resolveWith(context, [el, html]);
      });
    } else {
      result.resolveWith(context, [el, html]);
    }
  });
  return result.promise();
}
function replaceHTML(selector, twig, options) {
  return _xxxHTML(selector, twig, 0, options);
}
function prependHTML(selector, twig, options) {
  return _xxxHTML(selector, twig, 1, options);
}
function appendHTML(selector, twig, options) {
  return _xxxHTML(selector, twig, 2, options);
}
function parentHTML(selector, twig, options) {
  return _xxxHTML(selector, twig, 3, options);
}
function setDateTimeFormats(datetimePrecision, datetimeFormat, dateFormat, timePrecision, timeHMSFormat, timeHMFormat) {
  _datetimeFormat = datetimeFormat || 'yyyy-MM-dd HH:mm:ss';
  _dateFormat = dateFormat || 'yyyy-MM-dd';
  _timeHMSFormat = timeHMSFormat || 'HH:mm:ss';
  _timeHMFormat = timeHMFormat || 'HH:mm';
  if (datetimePrecision > 0) {
    _datetimeFormat += `.${'S'.repeat(datetimePrecision)}`;
  }
  if (timePrecision > 0) {
    _timeHMSFormat += `.${'S'.repeat(timePrecision)}`;
  }
}
function formatTWIG(twig, dict, twigs) {
  const result = [];
  const render = (twig, dict, twigs) => {
    if (!isMap(dict)) {
      dict = {};
    }
    if (!isMap(twigs)) {
      twigs = {};
    }
    dict['ORIGIN_URL'] = js_AMIRouter.getOriginURL();
    dict['WEBAPP_URL'] = js_AMIRouter.getWebAppURL();
    dict['BOOTSTRAP_VERSION'] = js_AMIWebApp.bootstrapVersion;
    Object.assign(dict, window.ami.awf.globalTwigDict);
    return ami_twig/* default */.A.engine.render(twig, dict, twigs);
  };
  asArray(dict).forEach(DICT => {
    try {
      result.push(render(twig, DICT, twigs));
    } catch (e) {
      error(`TWIG parsing error: ${e.message}`);
    }
  });
  return result.join('');
}
;// ./src/js/utilities/jsdoc.js


function jsdoc_createForOfIteratorHelperLoose(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (t) return (t = t.call(r)).next.bind(t); if (Array.isArray(r) || (t = jsdoc_unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var o = 0; return function () { return o >= r.length ? { done: !0 } : { done: !1, value: r[o++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function jsdoc_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return jsdoc_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? jsdoc_arrayLikeToArray(r, a) : void 0; } }
function jsdoc_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }

class AMIJSDoc {
  static #linkExp = /(?:\[\s*([^\s\]]+)\s*])?{@link\s+([^\s}]+)\s*}/g;
  #menuSelector = null;
  #bodySelector = null;
  #json = null;
  constructor(menuSelector, bodySelector, json) {
    this.#menuSelector = menuSelector;
    this.#bodySelector = bodySelector;
    this.#json = json;
    this.#makeMenu();
  }
  #makeMenu() {
    const s = `
<a class="list-group-item list-group-item-action p-2" href="">
	<i class="bi bi-house"></i> Home
</a>

<div class="list-group-item list-group-item-action p-2">

	${this.#makeSubMenu('Global', 'global')}
	${this.#makeSubMenu('Namespace', 'namespaces')}
	${this.#makeSubMenu('Interface', 'interfaces')}
	${this.#makeSubMenu('Class', 'classes')}

</div>
`;
    $(this.#menuSelector).html(s.trim()).promise().done(_ => {
      $(this.#menuSelector).find('a[data-name][data-cat][data-name]').click(e => {
        const el = $(e.currentTarget);
        e.preventDefault();
        this.#makeContent(el.attr('data-title'), el.attr('data-cat'), el.attr('data-name'));
      });
    });
  }
  #makeSubMenu(title, cat) {
    const result = [];
    let items;
    if (cat === 'global') {
      items = [];
      if (this.#json['variables']) {
        items = items.concat(this.#json['variables']);
      }
      if (this.#json['functions']) {
        items = items.concat(this.#json['functions']);
      }
    } else {
      items = this.#json[cat];
    }
    if (Array.isArray(items) && items.length > 0) {
      result.push('<div>');
      result.push(`<a href="#jsdoc_menu_${title.toLowerCase()}" data-toggle="collapse" data-bs-toggle="collapse"><i class="bi bi-book"></i> ${textToHtml(title)}</a>`);
      result.push(`<ul class="collapse mb-0" id="jsdoc_menu_${title.toLowerCase()}">${items.map(_item => `<li><a href="#" data-title="${textToHtml(title)}" data-cat="${textToHtml(cat)}" data-name="${textToHtml(_item.name)}">${textToHtml(_item.name)}</a></li>`).join('')}</ul>`);
      result.push('</div>');
    }
    return result.join('');
  }
  #makeContent(title, cat, name) {
    const s = [];
    let item;
    if (cat === 'global') {
      item = {
        name: 'variables and functions',
        variables: this.#json['variables'],
        functions: this.#json['functions']
      };
    } else {
      item = this.#json[cat].filter(item => item.name === name)[0];
    }
    s.push('<div class="card">');
    s.push('<div class="card-body bg-light">');
    s.push(`<h1>${textToHtml(title)}: ${textToHtml(item.name)}</h1>`);
    s.push(AMIJSDoc.#makeAlias(item));
    s.push(AMIJSDoc.#makeDesc(item));
    s.push(AMIJSDoc.#makeDetails(item));
    s.push('</div>');
    s.push('</div>');
    if (item.konstructor) {
      s.push('<h4 class="mt-3">Constructor</h4>');
      s.push(AMIJSDoc.#makeFunction(item.konstructor));
    }
    if (Array.isArray(item.variables)) {
      s.push('<h4 class="mt-3">Members</h4>');
      for (var _iterator = jsdoc_createForOfIteratorHelperLoose(item.variables), _step; !(_step = _iterator()).done;) {
        const _variable = _step.value;
        s.push(AMIJSDoc.#makeVariable(_variable));
      }
    }
    if (Array.isArray(item.functions)) {
      s.push('<h4 class="mt-3">Methods</h4>');
      for (var _iterator2 = jsdoc_createForOfIteratorHelperLoose(item.functions), _step2; !(_step2 = _iterator2()).done;) {
        const _function = _step2.value;
        s.push(AMIJSDoc.#makeFunction(_function));
      }
    }
    if (Array.isArray(item.events)) {
      s.push('<h4 class="mt-3">Events</h4>');
      for (var _iterator3 = jsdoc_createForOfIteratorHelperLoose(item.events), _step3; !(_step3 = _iterator3()).done;) {
        const _event = _step3.value;
        s.push(AMIJSDoc.#makeFunction(_event));
      }
    }
    $(this.#bodySelector).html(s.join(''));
  }
  static #makeVariable(variable) {
    const result = [];
    result.push(`<hr id="jsdoc_variable_${variable.name}" />`);
    result.push(AMIJSDoc.#makeVariableSignature(variable));
    result.push(AMIJSDoc.#makeAlias(variable));
    result.push(AMIJSDoc.#makeDesc(variable));
    result.push(AMIJSDoc.#makeDetails(variable));
    return result.join('');
  }
  static #makeVariableSignature(variable) {
    const result = [];
    result.push(`<span class="signature-name">${textToHtml(variable.name)}</span>`);
    result.push(`<span class="signature-attrs">: {${AMIJSDoc.#makeType(variable)}}</span>`);
    return result.join('');
  }
  static #makeFunction(method) {
    const result = [];
    result.push(`<hr id="jsdoc_method_${method.name}" />`);
    result.push(AMIJSDoc.#makeFunctionSignature(method));
    result.push(AMIJSDoc.#makeAlias(method));
    result.push(AMIJSDoc.#makeDesc(method));
    result.push(AMIJSDoc.#makeFunctionParameters(method));
    result.push(AMIJSDoc.#makeDetails(method));
    result.push(AMIJSDoc.#makeFunctionExceptions(method));
    result.push(AMIJSDoc.#makeFunctionReturn(method));
    result.push(AMIJSDoc.#makeExamples(method));
    return result.join('');
  }
  static #makeFunctionSignature(method) {
    const result = [];
    result.push(`<span class="signature-name">${textToHtml(method.name)}</span>`);
    if (method.params) {
      const L = method.params.map(_param => AMIJSDoc.#makeParam(_param));
      result.push(`<span class="signature-params">(${L.join(', ')})</span>`);
    }
    if (method.returns) {
      const L = method.returns.map(_return => AMIJSDoc.#makeType(_return));
      result.push(`<span class="signature-attrs"> &rarr; {${L.join(' or ')}}</span>`);
    }
    return result.join('');
  }
  static #makeFunctionParameters(method) {
    const result = [];
    if (method.params.length > 0) {
      const L1 = [],
        L2 = [],
        L3 = [],
        L4 = [],
        L5 = [],
        L6 = [];
      let cnt1 = 0,
        cnt2 = 0,
        cnt3 = 0,
        cnt4 = 0,
        cnt5 = 0,
        cnt6 = 0;
      for (var _iterator4 = jsdoc_createForOfIteratorHelperLoose(method.params), _step4; !(_step4 = _iterator4()).done;) {
        const _params = _step4.value;
        L1.push(textToHtml(_params['name']));
        L2.push(AMIJSDoc.#makeType(_params));
        L3.push(AMIJSDoc.#makeDesc(_params));
        L4.push(textToHtml(_params['default']));
        L5.push(_params['optional']);
        L6.push(_params['nullable']);
        if (_params['name']) {
          cnt1++;
        }
        if (_params['type']) {
          cnt2++;
        }
        if (_params['desc']) {
          cnt3++;
        }
        if (_params['default']) {
          cnt4++;
        }
        if (_params['optional']) {
          cnt5++;
        }
        if (_params['nullable']) {
          cnt6++;
        }
      }
      result.push('<h5 class="mt-2"><strong>Parameters:</strong></h5>');
      result.push('<table class="table table-sm table-hover table-striped table-bordered" style="width: auto;">');
      result.push('<thead>');
      result.push('<tr>');
      if (cnt1 > 0) {
        result.push('<th>Name</th>');
      }
      if (cnt2 > 0) {
        result.push('<th>Type</th>');
      }
      if (cnt4 > 0) {
        result.push('<th>Default</th>');
      }
      if (cnt5 > 0) {
        result.push('<th>Optional</th>');
      }
      if (cnt6 > 0) {
        result.push('<th>Nullable</th>');
      }
      if (cnt3 > 0) {
        result.push('<th>Description</th>');
      }
      result.push('</tr>');
      result.push('</thead>');
      result.push('<tbody>');
      for (const i in method.params) {
        result.push('<tr>');
        if (cnt1 > 0) {
          result.push(`<td>${L1[i]}</td>`);
        }
        if (cnt2 > 0) {
          result.push(`<td>${L2[i]}</td>`);
        }
        if (cnt4 > 0) {
          result.push(`<td>${L4[i]}</td>`);
        }
        if (cnt5 > 0) {
          result.push(`<td class="text-center">${L5[i] ? '✓' : ''}</td>`);
        }
        if (cnt6 > 0) {
          result.push(`<td class="text-center">${L6[i] ? '✓' : ''}</td>`);
        }
        if (cnt3 > 0) {
          result.push(`<td>${L3[i]}</td>`);
        }
        result.push('</tr>');
      }
      result.push('</tbody>');
      result.push('</table>');
    }
    return result.join('');
  }
  static #makeFunctionExceptions(method) {
    const result = [];
    if (Array.isArray(method.exceptions)) {
      for (var _iterator5 = jsdoc_createForOfIteratorHelperLoose(method.exceptions), _step5; !(_step5 = _iterator5()).done;) {
        const _exception = _step5.value;
        result.push('<h5 class="mt-2"><strong>Throws:</strong></h5>');
        result.push(AMIJSDoc.#makeDesc(_exception));
        result.push(`<div>Type: <span class="signature-attrs">${AMIJSDoc.#makeType(_exception)}</span></div>`);
      }
    }
    return result.join('');
  }
  static #makeFunctionReturn(method) {
    const result = [];
    if (Array.isArray(method.returns)) {
      for (var _iterator6 = jsdoc_createForOfIteratorHelperLoose(method.returns), _step6; !(_step6 = _iterator6()).done;) {
        const _return = _step6.value;
        result.push('<h5 class="mt-2"><strong>Returns:</strong></h5>');
        result.push(AMIJSDoc.#makeDesc(_return));
        result.push(`<div>Type: <span class="signature-attrs">${AMIJSDoc.#makeType(_return)}</span></div>`);
      }
    }
    return result.join('');
  }
  static #makeAlias(x) {
    const result = [];
    if (x.alias) {
      result.push('<div>');
      result.push(`Alias: ${textToHtml(x.alias)}`);
      result.push('</div>');
    }
    return result.join('');
  }
  static #makeDesc(x) {
    const result = [];
    if (x.desc) {
      result.push('<div>');
      result.push(textToHtml(x.desc).replace(AMIJSDoc.#linkExp, (_, x, y) => {
        return `<a href="${y}">${x || y}</a>`;
      }));
      result.push('</div>');
    }
    return result.join('');
  }
  static #makeParam(x) {
    const result = [];
    result.push(textToHtml(x.name));
    if (x.optional) {
      result.push('<sup class="signature-params-attrs">opt.</sup>');
    }
    if (x.nullable) {
      result.push('<sup class="signature-params-attrs">null.</sup>');
    }
    return result.join('');
  }
  static #makeType(x) {
    return x.type.map(y => `<i>${textToHtml(y.replace(/\s*/g, ''))}</i>`).join(' or ');
  }
  static #makeDetails(x) {
    const result = [];
    if (Array.isArray(x.implements) && x.implements.length > 0) {
      result.push(`<div>Implements: ${textToHtml(x.implements.join(', '))}</div>`);
    }
    if (Array.isArray(x.inherits) && x.inherits.length > 0) {
      result.push(`<div>Inherits: ${textToHtml(x.inherits.join(', '))}</div>`);
    }
    const version = [];
    const author = [];
    const see = [];
    if (x.version) {
      version.push(`<dt>Version:</dt><dd>${textToHtml(x.version)}</dd>`);
    }
    if (Array.isArray(x.author)) {
      for (var _iterator7 = jsdoc_createForOfIteratorHelperLoose(x.author), _step7; !(_step7 = _iterator7()).done;) {
        const _author = _step7.value;
        const _AUTHOR = _author.replace(AMIJSDoc.#linkExp, (_, x, y) => {
          return `<a href="${y}">${x || y}</a>`;
        });
        author.push(`<dt>Author:</dt><dd>${_AUTHOR}</dd>`);
      }
    }
    if (Array.isArray(x.see)) {
      for (var _iterator8 = jsdoc_createForOfIteratorHelperLoose(x.see), _step8; !(_step8 = _iterator8()).done;) {
        const _see = _step8.value;
        const _SEE = _see.replace(AMIJSDoc.#linkExp, (_, x, y) => {
          return `<a href="${y}">${x || y}</a>`;
        });
        see.push(`<dt>See:</dt><dd>${_SEE}</dd>`);
      }
    }
    if (author.length > 0 || version.length > 0 || see.length > 0) {
      result.push('<dl class="details">');
      result.push(version.join(''));
      result.push(author.join(''));
      result.push(see.join(''));
      result.push('</dl>');
    }
    return result.join('');
  }
  static #makeExamples(x, mode) {
    const result = [];
    if (Array.isArray(x.examples)) {
      for (var _iterator9 = jsdoc_createForOfIteratorHelperLoose(x.examples), _step9; !(_step9 = _iterator9()).done;) {
        const _example = _step9.value;
        result.push('<h5 class="mt-2"><strong>Example:</strong></h5>');
        result.push(`<textarea class="form-editor" data-mode="${textToHtml(mode)}">${textToHtml(_example)}</textarea>`);
      }
    }
    return result.join('');
  }
}
function renderJSDoc(menuSelector, bodySelector, json) {
  return new AMIJSDoc(menuSelector, bodySelector, json);
}
;// ./src/js/utilities/controls.js








const _controls = {};
function loadControl(control, options) {
  const result = $.Deferred();
  const [context, cache] = setup(['context', 'cache'], [result, false], options);
  if (control.indexOf('ctrl:') === 0) {
    control = control.substring(5);
  }
  const descr = _controls[control.toLowerCase()];
  if (descr) {
    try {
      loadScripts(`${js_AMIRouter.getOriginURL()}/${descr.file}`, {
        cache: cache
      }).then(loaded => {
        const clazz = window[descr.clazz];
        const promise = loaded[0] ? clazz.prototype.onReady.apply(clazz.prototype) : null;
        _internal_then(promise, () => {
          result.resolveWith(context, [clazz]);
        }, message => {
          result.rejectWith(context, [`cannot load control '${control}': ${message}`]);
        });
      }, message => {
        result.rejectWith(context, [`cannot load control '${control}': ${message}`]);
      });
    } catch (message) {
      result.rejectWith(context, [`cannot load control '${control}': ${message}`]);
    }
  } else {
    result.rejectWith(context, [`cannot load control '${control}': not found`]);
  }
  return result.promise();
}
function createControl(parent, owner, control, params, options) {
  const result = $.Deferred();
  const [context, patch] = setup(['context', 'patch'], [result, null], options);
  loadControl(control, options).done(constructor => {
    const instance = new constructor(parent, owner);
    if (typeof patch === 'function') {
      patch(instance, instance._twigDict, window.ami.awf.globalTwigDict);
    }
    _internal_then(constructor.prototype.render.apply(instance, params), function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      result.resolveWith(context, [instance].concat(args));
    }, message => {
      result.rejectWith(context, [message]);
    });
  }).fail(message => {
    result.rejectWith(context, [message]);
  });
  return result.promise();
}
function createControlInBody(parent, owner, control, controlParams, controlOptions, ownerOptions, options) {
  const result = $.Deferred();
  const [context] = setup(['context'], [result], options);
  try {
    const PARAMS = [];
    const OPTIONS = {};
    for (let key in ownerOptions) {
      OPTIONS[key] = ownerOptions[key];
    }
    for (let key in controlOptions) {
      OPTIONS[key] = controlOptions[key];
    }
    Array.prototype.push.apply(PARAMS, controlParams);
    PARAMS.push(OPTIONS);
    createControl(parent, owner, control, PARAMS).done(function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      result.resolveWith(context, args);
    }).fail(message => {
      result.rejectWith(context, [message]);
    });
  } catch (message) {
    result.rejectWith(context, [message]);
  }
  return result.promise();
}
function createControlInContainer(parent, owner, control, controlParams, controlOptions, ownerOptions, icon, title, options) {
  const result = $.Deferred();
  const [context] = setup(['context'], [result], options);
  try {
    parent.appendItem(`<i class="bi bi-${textToHtml(icon)}"></i> ${textToHtml(title)}`).done(selector => {
      const PARAMS = [];
      const OPTIONS = {};
      for (let key in ownerOptions) {
        OPTIONS[key] = ownerOptions[key];
      }
      for (let key in controlOptions) {
        OPTIONS[key] = controlOptions[key];
      }
      PARAMS.push(selector);
      Array.prototype.push.apply(PARAMS, controlParams);
      PARAMS.push(OPTIONS);
      createControl(parent, owner, control, PARAMS).done(function () {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        result.resolveWith(context, args);
      }).fail(message => {
        result.rejectWith(context, [message]);
      });
    });
  } catch (message) {
    result.rejectWith(context, [message]);
  }
  return result.promise();
}
function _parseJSON(s, _default) {
  try {
    return JSON.parse(s);
  } catch (e) {
    return _default;
  }
}
function createControlFromWebLink(parent, owner, el, ownerOptions, options) {
  const dataCtrl = el.hasAttribute('data-ctrl') ? el.getAttribute('data-ctrl') : '';
  const dataCtrlLocation = el.hasAttribute('data-ctrl-location') ? el.getAttribute('data-ctrl-location') : '';
  const dataParams = el.hasAttribute('data-params') ? _parseJSON(el.getAttribute('data-params'), []) : [];
  const dataOptions = el.hasAttribute('data-options') ? _parseJSON(el.getAttribute('data-options'), {}) : el.hasAttribute('data-settings') ? _parseJSON(el.getAttribute('data-settings'), {}) : {};
  const dataIcon = el.hasAttribute('data-icon') ? el.getAttribute('data-icon') : 'question';
  const dataTitle = el.hasAttribute('data-title') ? el.getAttribute('data-title') : 'Unknown';
  lock();
  if (dataCtrlLocation === 'body') {
    return createControlInBody(parent, owner, dataCtrl, dataParams, dataOptions, ownerOptions, options).done(() => {
      unlock();
    }).fail(message => {
      error(message);
    });
  } else {
    return createControlInContainer(parent, owner, dataCtrl, dataParams, dataOptions, ownerOptions, dataIcon, dataTitle, options).done(() => {
      unlock();
    }).fail(message => {
      error(message);
    });
  }
}
;// ./src/js/utilities/resources.js





const _sheets = [];
const _scripts = [];
function _getExtension(url) {
  const idx = url.lastIndexOf('.');
  return idx > 0 ? url.substring(idx) : '';
}
function _getDataType(url, dataType) {
  let result;
  if (dataType === 'auto') {
    if (url.indexOf('ctrl:') === 0) {
      result = 'control';
    } else if (url.indexOf('subapp:') === 0) {
      result = 'subapp';
    } else {
      switch (_getExtension(url).toLowerCase()) {
        case '.css':
          result = 'sheet';
          break;
        case '.js':
          result = 'script';
          break;
        case '.json':
          result = 'json';
          break;
        case '.xml':
          result = 'xml';
          break;
        default:
          result = 'text';
          break;
      }
    }
  } else {
    result = dataType;
  }
  return result;
}
function __loadXXX(deferred, result, urls, dataType, context, cache) {
  if (urls.length === 0) {
    deferred.resolveWith(context, [result]);
    return;
  }
  const url = urls.shift().trim();
  const dataTYPE = _getDataType(url, dataType);
  switch (dataTYPE) {
    case 'control':
      loadControl(url).then(data => {
        result.push(data);
        __loadXXX(deferred, result, urls, dataType, context, cache);
      }, message => {
        deferred.rejectWith(context, [message]);
      });
      break;
    case 'subapp':
      loadSubApp(url).then(data => {
        result.push(data);
        __loadXXX(deferred, result, urls, dataType, context, cache);
      }, message => {
        deferred.rejectWith(context, [message]);
      });
      break;
    case 'sheet':
      if (_sheets.indexOf(url) >= 0) {
        result.push(false);
        __loadXXX(deferred, result, urls, dataType, context, cache);
      } else {
        $.ajax({
          url: url,
          async: false,
          cache: cache,
          crossDomain: true,
          dataType: dataTYPE
        }).then(() => {
          result.push(true);
          _sheets.push(url);
          __loadXXX(deferred, result, urls, dataType, context, cache);
        }, () => {
          deferred.rejectWith(context, [`cannot load '${url}'`]);
        });
      }
      break;
    case 'script':
      if (_scripts.indexOf(url) >= 0) {
        result.push(false);
        __loadXXX(deferred, result, urls, dataType, context, cache);
      } else {
        $.ajax({
          url: url,
          async: false,
          cache: cache,
          crossDomain: true,
          dataType: dataTYPE
        }).then(() => {
          result.push(true);
          _scripts.push(url);
          __loadXXX(deferred, result, urls, dataType, context, cache);
        }, () => {
          deferred.rejectWith(context, [`cannot load '${url}'`]);
        });
      }
      break;
    default:
      $.ajax({
        url: url,
        async: true,
        cache: cache,
        crossDomain: true,
        dataType: dataTYPE
      }).then(data => {
        result.push(data);
        __loadXXX(deferred, result, urls, dataType, context, cache);
      }, () => {
        deferred.rejectWith(context, [`cannot load '${url}'`]);
      });
      break;
  }
}
function _loadXXX(urls, dataType, options) {
  const deferred = $.Deferred();
  const [context, cache] = setup(['context', 'cache'], [deferred, false], options);
  __loadXXX(deferred, [], asArray(urls), dataType, context, cache);
  return deferred.promise();
}
function loadResources(urls, options) {
  return _loadXXX(urls, 'auto', options);
}
function loadSheets(urls, options) {
  return _loadXXX(urls, 'sheet', options);
}
function loadScripts(urls, options) {
  return _loadXXX(urls, 'script', options);
}
function loadJSONs(urls, options) {
  return _loadXXX(urls, 'json', options);
}
function loadXMLs(urls, options) {
  return _loadXXX(urls, 'xml', options);
}
function loadHTMLs(urls, options) {
  return _loadXXX(urls, 'text', options);
}
function loadTWIGs(urls, options) {
  return _loadXXX(urls, 'text', options);
}
function loadTexts(urls, options) {
  return _loadXXX(urls, 'text', options);
}
;// ./src/twigs/day_night_button.twig
const day_night_button_namespaceObject = "<li class=\"nav-item\">\n\t<input class=\"btn-check\" type=\"checkbox\" role=\"switch\" id=\"B3094B72_95CB_0F9F_0364_0ED6B6DCD6EF\" onchange=\"amiWebApp.themeSet(this.checked ? 'dark' : 'light')\" />\n\t<label class=\"btn btn-sm btn-link\" for=\"B3094B72_95CB_0F9F_0364_0ED6B6DCD6EF\">\n\t\t<i class=\"bi\"></i>\n\t</label>\n</li>\n";
;// ./src/twigs/sign_in_button.twig
const sign_in_button_namespaceObject = "<li class=\"nav-item xxxxxxxx\">\n\t{% if ssoAuthenticationAllowed %}\n\t<button class=\"btn btn-outline-secondary\" type=\"button\" onclick=\"amiAuth.sso()\">\n\t\t<i class=\"bi bi-box-arrow-in-right\"></i> {{ awfInfo.ssoLabel|default('Single Sign-On') }}\n\t</button>\n\t{% endif %}\n\t<button class=\"btn btn-primary\" type=\"button\" onclick=\"amiAuth.signIn()\"><i class=\"bi bi-box-arrow-in-right\"></i> Sign In</button>\n</li>\n";
;// ./src/twigs/sign_out_button.twig
const sign_out_button_namespaceObject = "<li class=\"nav-item xxxxxxxx\">\n\t{{ icon }}\n</li>\n{% if bookmarksAllowed %}\n<li class=\"nav-item dropdown\">\n\t<a class=\"nav-link dropdown-toggle\" href=\"#\" data-bs-toggle=\"dropdown\">\n\t\t<i class=\"bi bi-star-fill\"></i>\n\t</a>\n\t<div class=\"dropdown-menu\" id=\"ami_bookmark_menu_content\">\n\t\t<a class=\"dropdown-item xxxxxxxx\" href=\"{{WEBAPP_URL}}?subapp=BookmarkEditor&userdata=bookmarks\" target=\"_blank\">Edit bookmarks</a>\n\t\t<div class=\"dropdown-divider\"></div>\n\t\t{% for hash, bookmark in bookmarkInfo %}\n\t\t<a class=\"dropdown-item\" href=\"{{WEBAPP_URL}}?v={{ hash|e }}\" target=\"_blank\">{{ bookmark.name|e }}</a>\n\t\t{% else %}\n\t\t<div class=\"dropdown-item text-muted\">-- empty --</div>\n\t\t{% endfor %}\n\t</div>\n</li>\n{% endif %}\n{% if dashboardsAllowed %}\n\t<li class=\"nav-item dropdown\">\n\t\t<a class=\"nav-link dropdown-toggle\" href=\"#\" data-bs-toggle=\"dropdown\">\n\t\t\t<i class=\"bi bi-speedometer\"></i>\n\t\t</a>\n\t\t<div class=\"dropdown-menu\" id=\"ami_dashboard_menu_content\">\n\t\t\t<a class=\"dropdown-item xxxxxxxx\" href=\"{{WEBAPP_URL}}?subapp=BookmarkEditor&userdata=dashboards\" target=\"_blank\">Edit dashboards</a>\n\t\t\t<div class=\"dropdown-divider\"></div>\n\t\t\t{% for hash, dashboard in dashboardInfo %}\n\t\t\t<a class=\"dropdown-item\" href=\"{{WEBAPP_URL}}?u={{ hash|e }}\" target=\"_blank\">{{ dashboard.name|e }}</a>\n\t\t\t{% else %}\n\t\t\t<div class=\"dropdown-item text-muted\">-- empty --</div>\n\t\t\t{% endfor %}\n\t\t</div>\n\t</li>\n{% endif %}\n<li class=\"nav-item dropdown\">\n\t<a class=\"nav-link dropdown-toggle\" href=\"#\" data-bs-toggle=\"dropdown\">\n\t\t<i class=\"bi bi-person-circle\"></i> {{ userInfo.AMIUser|e }}\n\t</a>\n\t<div class=\"dropdown-menu\">\n\t\t{% if changeInfoAllowed %}\n\t\t<a class=\"dropdown-item\" href=\"javascript:window.amiAuth.changeInfo();\">Change Information</a>\n\t\t{% endif %}\n\t\t{% if changePasswordAllowed %}\n\t\t<a class=\"dropdown-item\" href=\"javascript:window.amiAuth.changePass();\">Change Password</a>\n\t\t{% endif %}\n\t\t{% if changeCertificateAllowed %}\n\t\t<a class=\"dropdown-item\" href=\"javascript:window.amiAuth.changeCertificate();\">Change Certificate</a>\n\t\t{% endif %}\n\t\t<a class=\"dropdown-item\" href=\"javascript:window.amiAuth.accountStatus();\">Account Status</a>\n\t\t<div id=\"ami_user_menu_content\"></div>\n\t</div>\n</li>\n{% if signOutAllowed %}\n<li class=\"nav-item xxxxxxxx\">\n\t<button class=\"btn btn-outline-primary mt-1 mt-lg-0 ms-0 ms-lg-1\" type=\"button\" onclick=\"window.amiAuth.signOut();\">\n\t\t<i class=\"bi bi-box-arrow-right\"></i> Sign Out\n\t</button>\n</li>\n{% endif %}\n";
;// ./src/twigs/Modals/sign_in_modal.twig
const sign_in_modal_namespaceObject = "<div class=\"modal fade\" tabindex=\"-1\" id=\"D2B5FADE_97A3_4B8C_8561_7A9AEACDBE5B\">\n\t<div class=\"modal-dialog modal-dialog-centered modal-{% if signInImageURL %}xl{% else %}lg{% endif %}\">\n\t\t<div class=\"modal-content\">\n\t\t\t<div class=\"modal-body row m-0 p-0\">\n\n\t\t\t\t{% if signInImageURL %}\n\t\t\t\t<div class=\"col-lg-6 m-0 p-0\"\n\t\t\t\t\tstyle=\"background: url('{{ signInImageURL|e }}') center center; background-size: auto 100%;\">\n\t\t\t\t</div>\n\n\t\t\t\t<div class=\"col-lg-6 m-0 p-0\">\n\t\t\t\t{% else %}\n\t\t\t\t<div class=\"col-lg-12 m-0 p-0\">\n\t\t\t\t{% endif %}\n\n\t\t\t\t\t<nav class=\"p-3\">\n\t\t\t\t\t\t<div class=\"nav nav-tabs\" role=\"tablist\">\n\t\t\t\t\t\t\t<button class=\"nav-link active\" data-bs-toggle=\"tab\" data-bs-target=\"#B7894CC1_1DAA_4A7E_B7D1_DBDF6F06AC73\" type=\"button\" role=\"tab\"><i class=\"bi bi-box-arrow-in-right\"></i> Sign In</button>\n\t\t\t\t\t\t\t{% if createAccountAllowed %}\n\t\t\t\t\t\t\t<button class=\"nav-link xxxxxx\" data-bs-toggle=\"tab\" data-bs-target=\"#EE055CD4_E58F_4834_8020_986AE3F8D67D\" type=\"button\" role=\"tab\"><i class=\"bi bi-person-plus\"></i> Sign Up</button>\n\t\t\t\t\t\t\t{% endif %}\n\t\t\t\t\t\t\t{% if changePasswordAllowed %}\n\t\t\t\t\t\t\t<button class=\"nav-link xxxxxx\" data-bs-toggle=\"tab\" data-bs-target=\"#DA2047A2_9E5D_420D_B6E7_FA261D2EF10F\" type=\"button\" role=\"tab\"><i class=\"bi bi-bandaid\"></i> Reset Password</button>\n\t\t\t\t\t\t\t{% endif %}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</nav>\n\n\t\t\t\t\t<div class=\"tab-content px-3 pb-3\" style=\"height: 390px; overflow-y: scroll;\">\n\n\t\t\t\t\t\t<!-- *************************************************************************************** -->\n\n\t\t\t\t\t\t<form class=\"tab-pane fade show active\" role=\"tabpanel\" id=\"B7894CC1_1DAA_4A7E_B7D1_DBDF6F06AC73\">\n\n\t\t\t\t\t\t\t<h1 class=\"fw-bold\">{{ signInText|e }}</h1>\n\n\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t<label for=\"E64F24B2_33E6_4DED_9B24_28BE04219613\">Username<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"text\" name=\"username\" id=\"E64F24B2_33E6_4DED_9B24_28BE04219613\" required=\"required\" autocomplete=\"off\" autocapitalize=\"off\" spellcheck=\"false\" placeholder=\"Type your username...\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t<label for=\"A4DFD039_034F_4D10_9668_385AEF4FBBB9\">Password<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"password\" name=\"password\" id=\"A4DFD039_034F_4D10_9668_385AEF4FBBB9\" required=\"required\" autocomplete=\"off\" autocapitalize=\"off\" spellcheck=\"false\" placeholder=\"Type your password...\" />\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t{% if passwordAuthenticationAllowed %}\n\t\t\t\t\t\t\t<button class=\"btn btn-primary shadow w-100 mt-3\" type=\"submit\">\n\t\t\t\t\t\t\t\tSign In by Username\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t{% endif %}\n\n\t\t\t\t\t\t\t{% if certificateAuthenticationAllowed %}\n\t\t\t\t\t\t\t<button class=\"btn btn-primary shadow w-100 mt-3\" type=\"button\" onclick=\"amiAuth.form_login2();\">\n\t\t\t\t\t\t\t\tSign In by Certificate\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t{% endif %}\n\n\t\t\t\t\t\t\t{% if ssoAuthenticationAllowed %}\n\t\t\t\t\t\t\t<button class=\"btn btn-light shadow w-100 mt-3\" type=\"button\" onclick=\"amiAuth.sso();\">\n\t\t\t\t\t\t\t\tSingle Sign-On\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t{% endif %}\n\n\t\t\t\t\t\t</form>\n\n\t\t\t\t\t\t<!-- *************************************************************************************** -->\n\n\t\t\t\t\t\t{% if createAccountAllowed %}\n\t\t\t\t\t\t<form class=\"tab-pane fade xxxx xxxxxx\" role=\"tabpanel\" id=\"EE055CD4_E58F_4834_8020_986AE3F8D67D\">\n\n\t\t\t\t\t\t\t<h1 class=\"fw-bold\">Sign Up</h1>\n\n\t\t\t\t\t\t\t{% if captchaAllowed %}\n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"captcha_hash\" id=\"FD95B3FA_C808_0E08_2D1E_0FE0E3871101\" />\n\t\t\t\t\t\t\t{% endif %}\n\n\t\t\t\t\t\t\t<div class=\"bg-light2 p-2 mb-3\">\n\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"D752CE80_49C3_4BDC_8B1A_8ED6BD57C538\">First name<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"text\" name=\"first_name\" id=\"D752CE80_49C3_4BDC_8B1A_8ED6BD57C538\" tabindex=\"1\" required=\"required\" placeholder=\"Type your first name...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"A9A08864_6A32_45A4_8898_C167564DB8BB\">Username<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"text\" name=\"username\" id=\"A9A08864_6A32_45A4_8898_C167564DB8BB\" tabindex=\"3\" required=\"required\" placeholder=\"Choose a username...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"E6E30EEC_15EE_4FCF_9809_2B8EC2FEF388\">Password<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"password\" name=\"password\" id=\"E6E30EEC_15EE_4FCF_9809_2B8EC2FEF388\" tabindex=\"5\" required=\"required\" placeholder=\"Choose a password...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{% if captchaAllowed %}\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label>Captcha</label>\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"form-control form-control-sm\" id=\"AC9836E6_2A20_8711_39D5_0E8340561078\" style=\"background-size: 100% 100%;\"></div>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{% endif %}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"B3E6D18C_ABA3_402C_88A2_55FA99555A7A\">Last name<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"text\" name=\"last_name\" id=\"B3E6D18C_ABA3_402C_88A2_55FA99555A7A\" tabindex=\"2\" required=\"required\" placeholder=\"Type your last name...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"D1007165_B40F_4DAE_BA50_853F2C9DA32D\">Email<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input type=\"email\" class=\"form-control form-control-sm\" name=\"email\" id=\"D1007165_B40F_4DAE_BA50_853F2C9DA32D\" tabindex=\"4\" required=\"required\" placeholder=\"Type your email...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"CCD8E6F1_6DF8_4BDD_A0EC_C3C380830187\">Password<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"password\" name=\"xxxx\" id=\"CCD8E6F1_6DF8_4BDD_A0EC_C3C380830187\" tabindex=\"6\" required=\"required\" placeholder=\"Confirm the password...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{% if captchaAllowed %}\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"F36FED50_1ACC_CD15_ABEC_6E06247BE2DD\">Captcha<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"text\" name=\"captcha_text\" id=\"F36FED50_1ACC_CD15_ABEC_6E06247BE2DD\" tabindex=\"7\" required=\"required\" placeholder=\"Confirm the captcha...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{% endif %}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t\t<div class=\"mb-1 text-start\">\n\t\t\t\t\t\t\t\t\t<div class=\"custom-control custom-checkbox\">\n\t\t\t\t\t\t\t\t\t\t<input type=\"checkbox\" class=\"custom-control-input\" name=\"attachCert\" id=\"A09AE316_7068_4BC1_96A9_6B87D28863FE\" tabindex=\"8\" checked=\"checked\" />\n\t\t\t\t\t\t\t\t\t\t<label class=\"custom-control-label\" for=\"A09AE316_7068_4BC1_96A9_6B87D28863FE\">Attach the current certificate</label>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<iframe class=\"form-control form-control-sm mb-3\" id=\"C3E94F6D_48E0_86C0_3534_691728E492F4\" style=\"padding: 1px; height: 220px; width: 100%;\"></iframe>\n\n\t\t\t\t\t\t\t<div class=\"text-end mb-3\">\n\t\t\t\t\t\t\t\t<div class=\"custom-control custom-checkbox\">\n\t\t\t\t\t\t\t\t\t<input type=\"checkbox\" class=\"custom-control-input\" name=\"agree\" id=\"C443738D_16BD_469F_1430_84EC13924118\" tabindex=\"9\" xxxxxxx=\"xxxxxxx\" />\n\t\t\t\t\t\t\t\t\t<label class=\"custom-control-label\" for=\"C443738D_16BD_469F_1430_84EC13924118\">I agree with the privacy policy</label>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div class=\"text-end mb-0\">\n\t\t\t\t\t\t\t\t<button class=\"btn btn-outline-secondary\" type=\"button\" data-bs-dismiss=\"modal\">Close</button>\n\t\t\t\t\t\t\t\t<button class=\"btn btn-primary shadowed\" type=\"submit\">Create</button>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t</form>\n\t\t\t\t\t\t{% endif %}\n\n\t\t\t\t\t\t<!-- *************************************************************************************** -->\n\n\t\t\t\t\t\t{% if changePasswordAllowed %}\n\t\t\t\t\t\t<form class=\"tab-pane fade xxxx xxxxxx\" role=\"tabpanel\" id=\"DA2047A2_9E5D_420D_B6E7_FA261D2EF10F\">\n\n\t\t\t\t\t\t\t<h1 class=\"fw-bold\">Reset Password</h1>\n\n\t\t\t\t\t\t\t{% if captchaAllowed %}\n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"captcha_hash\" id=\"A63C0110_E591_6FCE_6D7A_02EEBC094199\" />\n\t\t\t\t\t\t\t{% endif %}\n\n\t\t\t\t\t\t\t<div class=\"bg-light2 p-2 mb-3\">\n\n\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t<div class=\"col-md-12\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"mb-{% if captchaAllowed %}3{% else %}1{% endif %}\">\n\t\t\t\t\t\t\t\t\t\t\t<label for=\"F0B93AF7_6049_4271_B1C9_C494A012D6D0\">Username<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"text\" name=\"username\" id=\"F0B93AF7_6049_4271_B1C9_C494A012D6D0\" required=\"required\" placeholder=\"Type your username...\" />\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{% if captchaAllowed %}\n\t\t\t\t\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"mb-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<label for=\"EA79605C_6EFF_4C77_9D70_88254B00FD52\">Captcha<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"form-control form-control-sm\" id=\"EA79605C_6EFF_4C77_9D70_88254B00FD52\" style=\"background-size: 100% 100%;\"></div>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"col-md-6\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"mb-1\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<label for=\"ECCBE7F1_1D33_169C_313E_C462B19DCDA0\">Captcha<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<input class=\"form-control form-control-sm\" type=\"text\" name=\"captcha_text\" id=\"ECCBE7F1_1D33_169C_313E_C462B19DCDA0\" tabindex=\"7\" required=\"required\" placeholder=\"Confirm the captcha...\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t{% endif %}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t\t<div class=\"text-end\">\n\t\t\t\t\t\t\t\t<button class=\"btn btn-outline-secondary\" type=\"button\" data-bs-dismiss=\"modal\">Close</button>\n\t\t\t\t\t\t\t\t<button class=\"btn btn-primary shadowed\" type=\"submit\">Reset</button>\n\t\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t</form>\n\t\t\t\t\t\t{% endif %}\n\n\t\t\t\t\t\t<!-- *************************************************************************************** -->\n\n\t\t\t\t\t</div>\n\n\t\t\t\t</div>\n\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n";
;// ./src/twigs/Modals/change_info_modal.twig
const change_info_modal_namespaceObject = "<form class=\"modal fade\" role=\"dialog\" id=\"D9EAF998_ED8E_44D2_A0BE_8C5CF5E438BD\">\n\t<div class=\"modal-dialog modal-lg\" role=\"document\">\n\t\t<div class=\"modal-content\">\n\t\t\t<div class=\"modal-header\">\n\t\t\t\t<h4 class=\"modal-title\">Change Information</h4>\n\t\t\t\t{% if BOOTSTRAP_VERSION > 4 %}\n\t\t\t\t<button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n\t\t\t\t{% else %}\n\t\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\"><i class=\"bi bi-x-lg\"></i></button>\n\t\t\t\t{% endif %}\n\t\t\t</div>\n\t\t\t<div class=\"modal-body\">\n\t\t\t\t<div class=\"row\">\n\t\t\t\t\t<div class=\"col-md-2 text-center\">\n\t\t\t\t\t\t<img src=\"{{ORIGIN_URL}}/js/assets/images/padlock.png\" alt=\"\" height=\"90\" width=\"90\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"col-md-10\">\n\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t<label for=\"E513F27D_5521_4B08_BF61_52AFB81356F7\">First name<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" name=\"first_name\" id=\"E513F27D_5521_4B08_BF61_52AFB81356F7\" required=\"required\" placeholder=\"Type your first name...\" disabled readonly />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t<label for=\"AFF0B5C0_BEEC_4842_916D_DCBA7F589195\">Last name<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" name=\"last_name\" id=\"AFF0B5C0_BEEC_4842_916D_DCBA7F589195\" required=\"required\" placeholder=\"Type your last name...\" disabled readonly />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t<label for=\"C587486B_62C0_4B6E_9288_D8F9F89D157B\">Email<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t<input type=\"email\" class=\"form-control\" name=\"email\" id=\"C587486B_62C0_4B6E_9288_D8F9F89D157B\" required=\"required\" placeholder=\"Type your email...\" disabled readonly />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"modal-footer\">\n\t\t\t\t<button class=\"btn btn-outline-secondary\" type=\"button\" data-bs-dismiss=\"modal\">Close</button>\n\t\t\t\t<button class=\"btn btn-primary\" type=\"submit\">Submit</button>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</form>\n";
;// ./src/twigs/Modals/change_pass_modal.twig
const change_pass_modal_namespaceObject = "<form class=\"modal fade\" role=\"dialog\" id=\"E92A1097_983B_4857_875F_07E4659B41B0\">\n\t<div class=\"modal-dialog modal-lg\" role=\"document\">\n\t\t<div class=\"modal-content\">\n\t\t\t<div class=\"modal-header\">\n\t\t\t\t<h4 class=\"modal-title\">Change Password</h4>\n\t\t\t\t{% if BOOTSTRAP_VERSION > 4 %}\n\t\t\t\t<button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n\t\t\t\t{% else %}\n\t\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\"><i class=\"bi bi-x-lg\"></i></button>\n\t\t\t\t{% endif %}\n\t\t\t</div>\n\t\t\t<div class=\"modal-body\">\n\t\t\t\t<div class=\"row\">\n\t\t\t\t\t<div class=\"col-md-2 text-center\">\n\t\t\t\t\t\t<img src=\"{{ORIGIN_URL}}/js/assets/images/padlock.png\" alt=\"\" height=\"90\" width=\"90\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"col-md-10\">\n\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t<label for=\"F238E6EE_44BD_486A_B85D_C927A4D045D3\">Old password<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t<input class=\"form-control\" type=\"password\" name=\"old_password\" id=\"F238E6EE_44BD_486A_B85D_C927A4D045D3\" required=\"required\" placeholder=\"Type your old password...\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t<label for=\"D487FE72_8D95_4048_BEA3_252274862AF4\">New password<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t<input class=\"form-control\" type=\"password\" name=\"new_password\" id=\"D487FE72_8D95_4048_BEA3_252274862AF4\" required=\"required\" placeholder=\"Choose a new password...\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3\">\n\t\t\t\t\t\t\t<label for=\"EE1DA58C_3761_4734_A9C2_E808CDD7EE77\">New password<span class=\"text-danger\">*</span></label>\n\t\t\t\t\t\t\t<input class=\"form-control\" type=\"password\" name=\"xxx_password\" id=\"EE1DA58C_3761_4734_A9C2_E808CDD7EE77\" required=\"required\" placeholder=\"Type your new password again...\" />\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div class=\"modal-footer\">\n\t\t\t\t<button class=\"btn btn-outline-secondary\" type=\"button\" data-bs-dismiss=\"modal\">Close</button>\n\t\t\t\t<button class=\"btn btn-primary\" type=\"submit\">Submit</button>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</form>\n";
;// ./src/twigs/Modals/change_cert_modal.twig
const change_cert_modal_namespaceObject = "<div class=\"modal fade\" role=\"dialog\" id=\"ECB92A89_A706_7C76_E248_E57D14C8B205\">\n\t<div class=\"modal-dialog modal-dialog-centered modal-lg\" role=\"document\">\n\t\t<div class=\"modal-content\">\n\t\t\t<div class=\"modal-header\">\n\t\t\t\t<h4 class=\"modal-title\">Change Certificate</h4>\n\t\t\t\t{% if BOOTSTRAP_VERSION > 4 %}\n\t\t\t\t<button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n\t\t\t\t{% else %}\n\t\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\"><i class=\"bi bi-x-lg\"></i></button>\n\t\t\t\t{% endif %}\n\t\t\t</div>\n\t\t\t<div class=\"modal-body\">\n\n\t\t\t\t<!-- *********************************************************************************************** -->\n\n\t\t\t\t<div class=\"card mb-2\">\n\t\t\t\t\t<div class=\"card-body\">\n\t\t\t\t\t\t<h5 class=\"card-title d-flex justify-content-between\">\n\t\t\t\t\t\t\t<span>Certificate in session</span>\n\t\t\t\t\t\t\t<button class=\"btn btn-sm btn-primary\" onclick=\"amiAuth.form_attachCert();\" id=\"DB0223B3_D721_7EEB_50B8_032A04C7D218\">\n\t\t\t\t\t\t\t\tAttach this certificate\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</h5>\n\t\t\t\t\t\t<input class=\"form-control form-control-sm border-0 mb-1\" type=\"text\" readonly=\"readonly\" id=\"C8B8F968_CCAA_26DF_8665_2B518189E3DE\" />\n\t\t\t\t\t\t<input class=\"form-control form-control-sm border-0 mb-0\" type=\"text\" readonly=\"readonly\" id=\"A962ED59_DB71_C10C_6173_3615C6F48028\" />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<!-- *********************************************************************************************** -->\n\n\t\t\t\t<div class=\"card mb-0\">\n\t\t\t\t\t<div class=\"card-body\">\n\t\t\t\t\t\t<h5 class=\"card-title d-flex justify-content-between\">\n\t\t\t\t\t\t\t<span>Certificate in AMI</span>\n\t\t\t\t\t\t\t<button class=\"btn btn-sm btn-danger\" onclick=\"amiAuth.form_detachCert();\" id=\"B39BA3DE_4BA7_CE2F_BB80_BB6F4A5CB2A2\">\n\t\t\t\t\t\t\t\tDetach this certificate\n\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t</h5>\n\t\t\t\t\t\t<input class=\"form-control form-control-sm border-0 mb-1\" type=\"text\" readonly=\"readonly\" id=\"C9297C00_920D_4AE6_8A20_B0DDB383CC6A\" />\n\t\t\t\t\t\t<input class=\"form-control form-control-sm border-0 mb-0\" type=\"text\" readonly=\"readonly\" id=\"D4B29AC0_4867_815B_8657_5A1D623C29CF\" />\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\n\t\t\t\t<!-- *********************************************************************************************** -->\n\n\t\t\t</div>\n\t\t\t<div class=\"modal-footer\">\n\t\t\t\t<button class=\"btn btn-outline-secondary\" type=\"button\" data-bs-dismiss=\"modal\">Close</button>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n";
;// ./src/twigs/Modals/account_modal.twig
const account_modal_namespaceObject = "<div class=\"modal fade\" role=\"dialog\" id=\"AB1CB183_96EB_4116_8A9E_4409BE058F34\">\n\t<div class=\"modal-dialog modal-lg\" role=\"document\">\n\t\t<div class=\"modal-content\">\n\t\t\t<div class=\"modal-header\">\n\t\t\t\t<h4 class=\"modal-title\">Account</h4>\n\t\t\t\t{% if BOOTSTRAP_VERSION > 4 %}\n\t\t\t\t<button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\"></button>\n\t\t\t\t{% else %}\n\t\t\t\t<button type=\"button\" class=\"close\" data-dismiss=\"modal\"><i class=\"bi bi-x-lg\"></i></button>\n\t\t\t\t{% endif %}\n\t\t\t</div>\n\t\t\t<div class=\"modal-body\">\n\t\t\t\t<h5 id=\"D944B01D_2E8D_4EE9_9DCC_2691438BBA16\"></h5>\n\n\t\t\t\t<nav class=\"mb-2\">\n\t\t\t\t\t<div class=\"nav nav-tabs\" role=\"tablist\">\n\t\t\t\t\t\t<button class=\"nav-link active\" data-bs-toggle=\"tab\" data-bs-target=\"#B89A9E2D_8969_41F4_B266_230B782FA17D\" type=\"button\" role=\"tab\">Account status</button>\n\t\t\t\t\t\t<button class=\"nav-link xxxxxx\" data-bs-toggle=\"tab\" data-bs-target=\"#F22A8AD8_08EB_434C_B6F8_DC92FC0F69AC\" type=\"button\" role=\"tab\">User information</button>\n\t\t\t\t\t\t<button class=\"nav-link xxxxxx\" data-bs-toggle=\"tab\" data-bs-target=\"#D827345F_6762_32F6_1D2D_DB40676804AE\" type=\"button\" role=\"tab\">User roles</button>\n\t\t\t\t\t</div>\n\t\t\t\t</nav>\n\n\t\t\t\t<div class=\"tab-content\">\n\n\t\t\t\t\t<!-- ******************************************************************************************* -->\n\n\t\t\t\t\t<div class=\"tab-pane active\" role=\"tabpanel\" id=\"B89A9E2D_8969_41F4_B266_230B782FA17D\">\n\t\t\t\t\t\t<div class=\"text-center rounded mx-auto px-5 py-2 mb-2\">\n\t\t\t\t\t\t\t<div class=\"row\">\n\t\t\t\t\t\t\t\t<div class=\"col-xl-3 d-flex flex-column align-items-center justify-content-between\">\n<!--\t\t\t\t\t\t\t\t<canvas id=\"EC948084_8C0A_CEBF_58C9_086046AB2456\" height=\"175\" width=\"175\"></canvas>\n-->\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"col-xl-6 d-flex flex-column align-items-center justify-content-between\">\n\t\t\t\t\t\t\t\t\t<div style=\"font-family: 'Open Sans Light'; font-size: 34pt;\" id=\"D579A431_DBE4_6B30_1CF6_5E23761B4E1A\">your account is</div>\n\t\t\t\t\t\t\t\t\t<div style=\"font-family: 'Open Sans Light'; font-size: 34pt;\" id=\"F3FF9F43_DE72_40BB_B1BA_B7B3C9002671\">???????????????</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"col-xl-3 d-flex flex-column align-items-center justify-content-between\">\n\t\t\t\t\t\t\t\t\t<canvas id=\"EC948084_8C0A_CEBF_58C9_086046AB2456\" height=\"175\" width=\"175\"></canvas>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"text-center\">\n\t\t\t\t\t\t\t<a href=\"#E50FF8BD_B0F5_CD72_F9DC_FC2BFA5DBA27\" data-bs-toggle=\"collapse\">privacy policy</a>\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<iframe class=\"form-control collapse\" id=\"E50FF8BD_B0F5_CD72_F9DC_FC2BFA5DBA27\" style=\"padding: 1px; min-height: 350px; width: 100%;\"></iframe>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<!-- ******************************************************************************************* -->\n\n\t\t\t\t\t<div class=\"tab-pane xxxxxx\" role=\"tabpanel\" id=\"F22A8AD8_08EB_434C_B6F8_DC92FC0F69AC\">\n\t\t\t\t\t\t<div class=\"mb-3 row\">\n\t\t\t\t\t\t\t<label class=\"col-sm-3 col-form-label col-form-label-sm\" for=\"ABEB0291_40B0_414A_A42B_E7EABB9B487E\" style=\"font-weight: normal;\">First name</label>\n\t\t\t\t\t\t\t<div class=\"col-sm-9\">\n\t\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" id=\"ABEB0291_40B0_414A_A42B_E7EABB9B487E\" readonly=\"readonly\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3 row\">\n\t\t\t\t\t\t\t<label class=\"col-sm-3 col-form-label col-form-label-sm\" for=\"A5AFDB62_1034_4F66_A3E6_9341B31FA290\" style=\"font-weight: normal;\">Last name</label>\n\t\t\t\t\t\t\t<div class=\"col-sm-9\">\n\t\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" id=\"A5AFDB62_1034_4F66_A3E6_9341B31FA290\" readonly=\"readonly\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3 row\">\n\t\t\t\t\t\t\t<label class=\"col-sm-3 col-form-label col-form-label-sm\" for=\"D730A774_05EA_47AB_A0C8_D92753802E3E\" style=\"font-weight: normal;\">Email</label>\n\t\t\t\t\t\t\t<div class=\"col-sm-9\">\n\t\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" id=\"D730A774_05EA_47AB_A0C8_D92753802E3E\" readonly=\"readonly\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3 row\">\n\t\t\t\t\t\t\t<label class=\"col-sm-3 col-form-label col-form-label-sm\" for=\"FE2F6232_C256_4B80_939C_EBEC90320308\" style=\"font-weight: normal;\">Issuer cert. DN in session</label>\n\t\t\t\t\t\t\t<div class=\"col-sm-9\">\n\t\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" id=\"FE2F6232_C256_4B80_939C_EBEC90320308\" readonly=\"readonly\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3 row\">\n\t\t\t\t\t\t\t<label class=\"col-sm-3 col-form-label col-form-label-sm\" for=\"F42FAF6B_2C8D_4142_8BD9_E5BCDCAA05AA\" style=\"font-weight: normal;\">Issuer cert. DN in account</label>\n\t\t\t\t\t\t\t<div class=\"col-sm-9\">\n\t\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" id=\"F42FAF6B_2C8D_4142_8BD9_E5BCDCAA05AA\" readonly=\"readonly\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-1 row\">\n\t\t\t\t\t\t\t<label class=\"col-sm-3 col-form-label col-form-label-sm\" for=\"C76805D7_1E86_4231_9071_1D04783423BB\" style=\"font-weight: normal;\">Client cert. DN in session</label>\n\t\t\t\t\t\t\t<div class=\"col-sm-9\">\n\t\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" id=\"C76805D7_1E86_4231_9071_1D04783423BB\" readonly=\"readonly\" />\n\t\t\t\t\t\t\t\t<div class=\"text-end\" style=\"margin-top: -0.65rem;\">\n\t\t\t\t\t\t\t\t\t<small class=\"badge rounded-pill text-white bg-dark\" id=\"E91280F6_E7C6_3E53_A457_646995C99317\">&nbsp;</small>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class=\"mb-3 row\">\n\t\t\t\t\t\t\t<label class=\"col-sm-3 col-form-label col-form-label-sm\" for=\"D1BEE3BF_9161_41DC_BC53_C44FFE4D2522\" style=\"font-weight: normal;\">Client cert. DN in account</label>\n\t\t\t\t\t\t\t<div class=\"col-sm-9\">\n\t\t\t\t\t\t\t\t<input class=\"form-control\" type=\"text\" id=\"D1BEE3BF_9161_41DC_BC53_C44FFE4D2522\" readonly=\"readonly\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<button class=\"btn btn-sm btn-outline-success\" type=\"button\" id=\"A3C9E9DE_B73C_2DE2_8BB2_A93982940E77\" data-clipboard-action=\"copy\" data-clipboard-text=\"\">\n\t\t\t\t\t\t\t<i class=\"bi bi-clipboard\"></i> Copy MQTT token\n\t\t\t\t\t\t</button>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<!-- ******************************************************************************************* -->\n\n\t\t\t\t\t<div class=\"tab-pane xxxxxx\" role=\"tabpanel\" id=\"D827345F_6762_32F6_1D2D_DB40676804AE\">\n\t\t\t\t\t\t<table class=\"table table-sm table-striped\">\n\t\t\t\t\t\t\t<thead>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<th>Name</th>\n\t\t\t\t\t\t\t\t<th>Description</th>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t</thead>\n\t\t\t\t\t\t\t<tbody id=\"BB07676B_EACA_9B42_ED51_477DB2976041\"></tbody>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</div>\n\n\t\t\t\t\t<!-- ******************************************************************************************* -->\n\n\t\t\t\t</div>\n\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n";
;// ./src/images/certificate-green.png
const certificate_green_namespaceObject = __webpack_require__.p + "assets/images/certificate-green.png";
;// ./src/images/certificate-pink.png
const certificate_pink_namespaceObject = __webpack_require__.p + "assets/images/certificate-pink.png";
// EXTERNAL MODULE: ./node_modules/qrcode/lib/browser.js
var browser = __webpack_require__(6877);
// EXTERNAL MODULE: ./node_modules/clipboard/dist/clipboard.js
var clipboard = __webpack_require__(5530);
var clipboard_default = /*#__PURE__*/__webpack_require__.n(clipboard);
;// ./src/js/AMIAuth.js





















class AMIAuth {
  #flags = {};
  #userInfo = {};
  #roleInfo = {};
  #bookmarkInfo = {};
  #dashboardInfo = {};
  #awfInfo = {};
  static #setupAWF(awfInfo) {
    try {
      const result = JSON.parse(base64Decode(awfInfo.config));
      setDateTimeFormats(result['datetimePrecision'], result['datetimeFormat'], result['dateFormat'], result['timePrecision'], result['timeHMSFormat'], result['timeHMFormat']);
      return result;
    } catch (e) {
      return {};
    }
  }
  init(signInImageURL, signInText, ssoAutoAuthentication, ssoAuthenticationAllowed, passwordAuthenticationAllowed, certificateAuthenticationAllowed, signOutAllowed, createAccountAllowed, changeInfoAllowed, changePasswordAllowed, changeCertificateAllowed, captchaAllowed, dayNightAllowed, bookmarksAllowed, dashboardsAllowed) {
    const result = $.Deferred();
    this.#flags = {
      signInImageURL: signInImageURL,
      signInText: signInText,
      ssoAutoAuthentication: ssoAutoAuthentication,
      ssoAuthenticationAllowed: ssoAuthenticationAllowed,
      passwordAuthenticationAllowed: passwordAuthenticationAllowed,
      certificateAuthenticationAllowed: certificateAuthenticationAllowed,
      signOutAllowed: signOutAllowed,
      createAccountAllowed: createAccountAllowed,
      changeInfoAllowed: changeInfoAllowed,
      changePasswordAllowed: changePasswordAllowed,
      changeCertificateAllowed: changeCertificateAllowed,
      captchaAllowed: captchaAllowed,
      dayNightAllowed: dayNightAllowed,
      bookmarksAllowed: bookmarksAllowed,
      dashboardsAllowed: dashboardsAllowed
    };
    js_AMIWebApp.appendHTML('body', sign_in_modal_namespaceObject + change_info_modal_namespaceObject + change_pass_modal_namespaceObject + change_cert_modal_namespaceObject + account_modal_namespaceObject, {
      dict: this.#flags
    }).done(() => {
      $('#B7894CC1_1DAA_4A7E_B7D1_DBDF6F06AC73').submit(e => {
        this.form_login(e);
      });
      $('#EE055CD4_E58F_4834_8020_986AE3F8D67D').submit(e => {
        this.form_addUser(e);
      });
      $('#DA2047A2_9E5D_420D_B6E7_FA261D2EF10F').submit(e => {
        this.form_remindPass(e);
      });
      $('#D9EAF998_ED8E_44D2_A0BE_8C5CF5E438BD').submit(e => {
        this.form_changeInfo(e);
      });
      $('#E92A1097_983B_4857_875F_07E4659B41B0').submit(e => {
        this.form_changePass(e);
      });
      $('#E6E30EEC_15EE_4FCF_9809_2B8EC2FEF388,#CCD8E6F1_6DF8_4BDD_A0EC_C3C380830187').change(() => {
        const el1 = $('#E6E30EEC_15EE_4FCF_9809_2B8EC2FEF388');
        const el2 = $('#CCD8E6F1_6DF8_4BDD_A0EC_C3C380830187');
        const pass1 = el1.val();
        const pass2 = el2.val();
        el2.get(0).setCustomValidity(pass1.length > 0 && pass2.length > 0 && pass1 !== pass2 ? 'Passwords don\'t match.' : '');
      });
      $('#D487FE72_8D95_4048_BEA3_252274862AF4,#EE1DA58C_3761_4734_A9C2_E808CDD7EE77').change(() => {
        const el1 = $('#D487FE72_8D95_4048_BEA3_252274862AF4');
        const el2 = $('#EE1DA58C_3761_4734_A9C2_E808CDD7EE77');
        const pass1 = el1.val();
        const pass2 = el2.val();
        el2.get(0).setCustomValidity(pass1.length > 0 && pass2.length > 0 && pass1 !== pass2 ? 'Passwords don\'t match.' : '');
      });
      new (clipboard_default())('#A3C9E9DE_B73C_2DE2_8BB2_A93982940E77', {
        container: document.getElementById('AB1CB183_96EB_4116_8A9E_4409BE058F34')
      });
    });
    window.onmessage = e => {
      if (js_AMIRouter.getOriginURL().startsWith(e.origin)) {
        let promise;
        if ('oidc_code' in e.data) {
          js_AMIWebApp.lock();
          promise = js_AMICommand.signInByCode(e.data.oidc_code);
        } else if ('oidc_token' in e.data) {
          js_AMIWebApp.lock();
          promise = js_AMICommand.signInByToken(e.data.oidc_token);
        } else {
          return;
        }
        promise.fail((data, message, userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo) => {
          this.#update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo).always(() => {
            js_AMIWebApp.error(message, true);
          });
        }).done((data, message, userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo) => {
          this.#update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo).fail(message => {
            js_AMIWebApp.error(message, true);
          }).done(() => {
            if ((userInfo.AMIUser || 'guest') === (userInfo.guestUser || 'guest')) {
              js_AMIWebApp.error('Authentification failed', true);
            } else {
              $('#D2B5FADE_97A3_4B8C_8561_7A9AEACDBE5B').modal('hide');
              AMIAuth.#clean();
              js_AMIWebApp.unlock();
            }
          });
        });
      }
    };
    const userdata = js_AMIRouter.getWebAppArgs()['userdata'] || '';
    js_AMICommand.signInByCertificate().fail((data, message, userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo) => {
      this.#update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo).always(() => {
        result.reject(message);
      });
    }).done((data, message, userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo) => {
      _internal_then(js_AMIWebApp.onReady(userdata), () => {
        js_AMIWebApp._isReady = true;
        this.#update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo).then(message => {
          result.resolve(message);
        }, message => {
          result.reject(message);
        });
      }, message => {
        js_AMIWebApp._isReady = true;
        this.#update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo).then(() => {
          result.reject(message);
        }, () => {
          result.reject(message);
        });
      });
    });
    return result;
  }
  static #clean() {
    $('#B7894CC1_1DAA_4A7E_B7D1_DBDF6F06AC73').trigger('reset');
    $('#EE055CD4_E58F_4834_8020_986AE3F8D67D').trigger('reset');
    $('#DA2047A2_9E5D_420D_B6E7_FA261D2EF10F').trigger('reset');
    $('#E92A1097_983B_4857_875F_07E4659B41B0').trigger('reset');
  }
  #update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo) {
    const result = $.Deferred();
    awfInfo = AMIAuth.#setupAWF(awfInfo);
    $('#A09AE316_7068_4BC1_96A9_6B87D28863FE').prop('disabled', !userInfo.clientDNInSession || !userInfo.issuerDNInSession);
    $('#C3E94F6D_48E0_86C0_3534_691728E492F4').attr('src', awfInfo.privacyPolicyURL || `${js_AMIWebApp.originURL}/docs/privacy_policy.html`);
    $('#E50FF8BD_B0F5_CD72_F9DC_FC2BFA5DBA27').attr('src', awfInfo.privacyPolicyURL || `${js_AMIWebApp.originURL}/docs/privacy_policy.html`);
    const dict = {
      ...this.#flags,
      userInfo: this.#userInfo = userInfo,
      roleInfo: this.#roleInfo = roleInfo,
      bookmarkInfo: this.#bookmarkInfo = bookmarkInfo,
      dashboardInfo: this.#dashboardInfo = dashboardInfo,
      awfInfo: this.#awfInfo = awfInfo
    };
    const user = userInfo.AMIUser || 'guest';
    const guest = userInfo.guestUser || 'guest';
    if (user !== guest) {
      const firstName = userInfo.firstName || '';
      const lastName = userInfo.lastName || '';
      const email = userInfo.email || '';
      const clientDNInSession = userInfo.clientDNInSession || '';
      const issuerDNInSession = userInfo.issuerDNInSession || '';
      const clientDNInAMI = userInfo.clientDNInAMI || '';
      const issuerDNInAMI = userInfo.issuerDNInAMI || '';
      const notBefore = userInfo.notBefore || '';
      const notAfter = userInfo.notAfter || '';
      const jwtToken = userInfo.mqttToken || '';
      const valid = userInfo.valid || 'false';
      $('#E513F27D_5521_4B08_BF61_52AFB81356F7').val(firstName);
      $('#AFF0B5C0_BEEC_4842_916D_DCBA7F589195').val(lastName);
      $('#C587486B_62C0_4B6E_9288_D8F9F89D157B').val(email);
      $('#ABEB0291_40B0_414A_A42B_E7EABB9B487E').val(firstName);
      $('#A5AFDB62_1034_4F66_A3E6_9341B31FA290').val(lastName);
      $('#D730A774_05EA_47AB_A0C8_D92753802E3E').val(email);
      $('#FE2F6232_C256_4B80_939C_EBEC90320308').val(issuerDNInSession);
      $('#F42FAF6B_2C8D_4142_8BD9_E5BCDCAA05AA').val(issuerDNInAMI);
      $('#C76805D7_1E86_4231_9071_1D04783423BB').val(clientDNInSession);
      $('#D1BEE3BF_9161_41DC_BC53_C44FFE4D2522').val(clientDNInAMI);
      const tokenButton = $('#A3C9E9DE_B73C_2DE2_8BB2_A93982940E77').attr('data-clipboard-text', jwtToken);
      if (this.hasRole('AMI_ADMIN')) {
        tokenButton.show();
      } else {
        tokenButton.hide();
      }
      if (issuerDNInSession && clientDNInSession) {
        $('#C8B8F968_CCAA_26DF_8665_2B518189E3DE').val(issuerDNInSession);
        $('#A962ED59_DB71_C10C_6173_3615C6F48028').val(clientDNInSession);
        $('#DB0223B3_D721_7EEB_50B8_032A04C7D218').prop('disabled', issuerDNInSession === issuerDNInAMI && clientDNInSession === clientDNInAMI);
      } else {
        $('#C9297C00_920D_4AE6_8A20_B0DDB383CC6A').val('N/A');
        $('#D4B29AC0_4867_815B_8657_5A1D623C29CF').val('N/A');
        $('#DB0223B3_D721_7EEB_50B8_032A04C7D218').prop('disabled', true);
      }
      if (issuerDNInAMI && clientDNInAMI) {
        $('#C9297C00_920D_4AE6_8A20_B0DDB383CC6A').val(issuerDNInAMI);
        $('#D4B29AC0_4867_815B_8657_5A1D623C29CF').val(clientDNInAMI);
        $('#B39BA3DE_4BA7_CE2F_BB80_BB6F4A5CB2A2').prop('disabled', false);
      } else {
        $('#C9297C00_920D_4AE6_8A20_B0DDB383CC6A').val('N/A');
        $('#D4B29AC0_4867_815B_8657_5A1D623C29CF').val('N/A');
        $('#B39BA3DE_4BA7_CE2F_BB80_BB6F4A5CB2A2').prop('disabled', true);
      }
      const table = [];
      for (const role in roleInfo) {
        table.push('<tr>');
        table.push(`<td>${js_AMIWebApp.textToHtml(roleInfo[role].name || 'N/A')}</td>`);
        table.push(`<td>${js_AMIWebApp.textToHtml(roleInfo[role].description || 'N/A')}</td>`);
        table.push('</tr>');
      }
      $('#BB07676B_EACA_9B42_ED51_477DB2976041').html(table.join(''));
      if (this.#flags.dayNightAllowed) {
        $('#ami_theme_menu_content').html(day_night_button_namespaceObject);
        js_AMIWebApp.themeSet(localStorage.getItem('theme') || 'light');
      }
      let icon = '';
      let message = '';
      let bgColor;
      let fgColor;
      if (valid !== 'false') {
        if (!this.#flags.ssoAutoAuthentication) {
          if (clientDNInSession && clientDNInAMI && issuerDNInSession && issuerDNInAMI && (clientDNInSession !== clientDNInAMI || issuerDNInSession !== issuerDNInAMI)) {
            message = 'The X.509 certificate in the session differs from the one in AMI.';
          }
        }
        if (message) {
          $('#D944B01D_2E8D_4EE9_9DCC_2691438BBA16').html(`<i class="bi bi-info-circle text-warning"></i> ${message}`);
          icon = `
<a class="nav-link text-warning" href="javascript:amiLogin.accountStatus();">
	<i class="bi bi-info-circle"></i>
</a>`;
        }
        $('#F3FF9F43_DE72_40BB_B1BA_B7B3C9002671').css('color', '#006400').html('<i class="bi bi-asterisk"></i> valid <i class="bi bi-asterisk"></i>').closest('.rounded').css('background', `#B8D49B url("${certificate_green_namespaceObject}") no-repeat center center`).css('background-size', 'cover');
        $('#E91280F6_E7C6_3E53_A457_646995C99317').text(`valid from ${notBefore || 'N/A'} to ${notAfter || 'N/A'}`);
        bgColor = '#B8D49B';
        fgColor = '#006400';
      } else {
        if (!this.#flags.ssoAutoAuthentication) {
          message = 'Check your membership.';
        }
        if (message) {
          $('#D944B01D_2E8D_4EE9_9DCC_2691438BBA16').html(`<i class="bi bi-info-circle text-danger"></i> ${message}`);
          icon = `
<a class="nav-link text-danger" href="javascript:amiAuth.accountStatus();">
	<i class="bi bi-info-circle"></i>
</a>`;
        }
        $('#F3FF9F43_DE72_40BB_B1BA_B7B3C9002671').css('color', '#DC3545').html('<i class="bi bi-asterisk"></i> invalid <i class="bi bi-asterisk"></i>').closest('.rounded').css('background', `#E8C8CF url("${certificate_pink_namespaceObject}") no-repeat center center`).css('background-size', 'cover');
        $('#E91280F6_E7C6_3E53_A457_646995C99317').text(`valid from ${notBefore || 'N/A'} to ${notAfter || 'N/A'}`);
        bgColor = '#E8C8CF';
        fgColor = '#DC3545';
      }
      browser.toCanvas(document.getElementById('EC948084_8C0A_CEBF_58C9_086046AB2456'), `${user}|${firstName} ${lastName}|${email}|${clientDNInAMI}|${issuerDNInAMI}`, {
        color: {
          dark: fgColor,
          light: bgColor
        },
        margin: 0,
        width: 150
      });
      dict['user'] = user;
      dict['icon'] = icon;
      js_AMIWebApp.replaceHTML('#ami_login_menu_content', sign_out_button_namespaceObject, {
        dict: dict
      }).done(() => {
        triggerLogin().then(() => {
          result.resolve();
        }, message => {
          result.reject(message);
        });
      });
    } else {
      js_AMIWebApp.replaceHTML('#ami_login_menu_content', sign_in_button_namespaceObject, {
        dict: dict
      }).done(() => {
        triggerLogout().then(() => {
          result.resolve();
        }, message => {
          result.reject(message);
        });
      });
    }
    return result.promise();
  }
  getJWTToken() {
    return this.#userInfo.mqttToken || '';
  }
  getMQTTBrokerEndpoint() {
    return this.#awfInfo.mqttBrokerEndpoint || '';
  }
  getAMIPipelineEndpoint() {
    return this.#awfInfo.amiPipelineEndpoint || '';
  }
  getUserInfo() {
    return this.#userInfo;
  }
  getRoleInfo() {
    return this.#roleInfo;
  }
  getBookmarkInfo() {
    return this.#bookmarkInfo;
  }
  getDashboardInfo() {
    return this.#dashboardInfo;
  }
  getAWFInfo() {
    return this.#awfInfo;
  }
  getUser() {
    return this.#userInfo.AMIUser || 'guest';
  }
  getGuest() {
    return this.#userInfo.guestUser || 'guest';
  }
  getNotBeforeDate() {
    return this.#userInfo.notBefore || '';
  }
  getNotAfterDate() {
    return this.#userInfo.notAfter || '';
  }
  getClientDN() {
    return this.#userInfo.clientDNInSession || '';
  }
  getIssuerDN() {
    return this.#userInfo.issuerDNInSession || '';
  }
  isValid() {
    return (this.#userInfo.valid || 'false') !== 'false';
  }
  isAuthenticated() {
    return this.getUser() !== this.getGuest();
  }
  hasRole(roleName) {
    return roleName in this.#roleInfo;
  }
  update() {
    js_AMIWebApp.lock();
    return js_AMICommand.signInByCertificate().done((data, message, userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo) => {
      this.#update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo).always(() => {
        js_AMIWebApp.unlock();
      });
    });
  }
  sso() {
    AMIAuth.#clean();
    window.open(this.#awfInfo.ssoAuthURL ? `${this.#awfInfo.ssoAuthURL}?response_type=code&scope=openid&client_id=${encodeURIComponent(this.#awfInfo.ssoClientId || '')}&redirect_uri=${encodeURIComponent(js_AMIRouter.getOriginURL())}/docs/sso.html` : `${js_AMIRouter.getOriginURL()}/docs/sso_not_configured.html`, this.#awfInfo.ssoLabel || 'Single Sign-On', 'location=no, menubar=no, status=no, scrollbars=no, width=800, height=525');
  }
  signIn() {
    AMIAuth.#clean();
    if (this.#flags.captchaAllowed) {
      js_AMICommand.execute('GenerateCaptcha').then(data => {
        const image = js_AMIWebApp.jspath('..field{.@name==="image"}.$', data)[0] || '';
        const hash = js_AMIWebApp.jspath('..field{.@name==="hash"}.$', data)[0] || '';
        $('#AC9836E6_2A20_8711_39D5_0E8340561078').css('background-image', `url('${image}')`);
        $('#EA79605C_6EFF_4C77_9D70_88254B00FD52').css('background-image', `url('${image}')`);
        $('#FD95B3FA_C808_0E08_2D1E_0FE0E3871101').val(hash);
        $('#A63C0110_E591_6FCE_6D7A_02EEBC094199').val(hash);
        $('#D2B5FADE_97A3_4B8C_8561_7A9AEACDBE5B').modal('show');
      }, (data, message) => {
        js_AMIWebApp.error(message);
      });
    } else {
      $('#D2B5FADE_97A3_4B8C_8561_7A9AEACDBE5B').modal('show');
    }
  }
  signOut() {
    js_AMIWebApp.lock();
    return js_AMICommand.signOut().always((data, message, userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo) => {
      this.#update(userInfo, roleInfo, bookmarkInfo, dashboardInfo, awfInfo).then(() => {
        js_AMIWebApp.unlock();
      }, message => {
        js_AMIWebApp.error(message, true);
      });
    });
  }
  changeInfo() {
    AMIAuth.#clean();
    $('#D9EAF998_ED8E_44D2_A0BE_8C5CF5E438BD').modal('show');
  }
  changePass() {
    AMIAuth.#clean();
    $('#E92A1097_983B_4857_875F_07E4659B41B0').modal('show');
  }
  changeCertificate() {
    AMIAuth.#clean();
    $('#ECB92A89_A706_7C76_E248_E57D14C8B205').modal('show');
  }
  accountStatus() {
    AMIAuth.#clean();
    $('#AB1CB183_96EB_4116_8A9E_4409BE058F34').modal('show');
  }
  form_login(e) {
    e.preventDefault();
    const values = $(e.target).serializeObject();
    return this.form_login2(values['username'], values['password']);
  }
  form_login2(username, password) {
    const promise = username && password ? js_AMICommand.signInByPassword(username.trim(), password.trim()) : js_AMICommand.signInByCertificate();
    js_AMIWebApp.lock();
    promise.then((data, message, userInfo, roleInfo, bookmarkInfo, udpInfo, ssoInfo) => {
      this.#update(userInfo, roleInfo, bookmarkInfo, udpInfo, ssoInfo).then(() => {
        if ((userInfo.AMIUser || 'guest') !== (userInfo.guestUser || 'guest')) {
          $('#D2B5FADE_97A3_4B8C_8561_7A9AEACDBE5B').modal('hide');
          AMIAuth.#clean();
          js_AMIWebApp.unlock();
        }
      }, message => {
        if ((userInfo.AMIUser || 'guest') !== (userInfo.guestUser || 'guest')) {
          $('#D2B5FADE_97A3_4B8C_8561_7A9AEACDBE5B').modal('hide');
          js_AMIWebApp.error(message, true);
        }
      });
      if ((userInfo.AMIUser || 'guest') === (userInfo.guestUser || 'guest')) {
        let message = 'Authentication failed.';
        if (userInfo.clientDNInSession || userInfo.issuerDNInSession) {
          message += `Client DN in session: ${js_AMIWebApp.textToHtml(userInfo.clientDNInSession)}.` + `Issuer DN in session: ${js_AMIWebApp.textToHtml(userInfo.issuerDNInSession)}.`;
        }
        js_AMIWebApp.error(message, true);
      }
    }, (data, message, userInfo, roleInfo, bookmarkInfo, udpInfo, ssoInfo) => {
      this.#update(userInfo, roleInfo, bookmarkInfo, udpInfo, ssoInfo).always(() => {
        js_AMIWebApp.error(message, true);
      });
    });
    return promise;
  }
  form_addUser(e) {
    e.preventDefault();
    const values = $(e.target).serializeObject();
    js_AMIWebApp.lock();
    js_AMICommand.addUser(values['username'], values['password'], values['first_name'], values['last_name'], values['email'], values['captcha_hash'], values['captcha_text'], 'attachCert' in values, 'agree' in values).then((data, message) => {
      js_AMIWebApp.success(message, true);
    }, (data, message) => {
      js_AMIWebApp.error(message, true);
    });
  }
  form_remindPass(e) {
    e.preventDefault();
    const values = $(e.target).serializeObject();
    js_AMIWebApp.lock();
    js_AMICommand.resetPassword(values['username'], values['captcha_hash'], values['captcha_text']).then((data, message) => {
      js_AMIWebApp.success(message, true);
    }, (data, message) => {
      js_AMIWebApp.error(message, true);
    });
  }
  form_changeInfo(e) {
    e.preventDefault();
    const values = $(e.target).serializeObject();
    js_AMIWebApp.lock();
    js_AMICommand.changeInfo(values['first_name'], values['last_name'], values['email']).then((data, message) => {
      js_AMIWebApp.success(message, true);
    }, (data, message) => {
      js_AMIWebApp.error(message, true);
    });
  }
  form_changePass(e) {
    e.preventDefault();
    const values = $(e.target).serializeObject();
    js_AMIWebApp.lock();
    js_AMICommand.changePassword(this.#userInfo.AMIUser || 'guest', values['old_password'], values['new_password']).then((data, message) => {
      js_AMIWebApp.success(message, true);
    }, (data, message) => {
      js_AMIWebApp.error(message, true);
    });
  }
  form_attachCert() {
    js_AMIWebApp.lock();
    return js_AMICommand.attachCertificate().then((data, message) => {
      $('#C9297C00_920D_4AE6_8A20_B0DDB383CC6A').val(this.#userInfo.issuerDNInAMI = this.#userInfo.issuerDNInSession);
      $('#D4B29AC0_4867_815B_8657_5A1D623C29CF').val(this.#userInfo.clientDNInAMI = this.#userInfo.clientDNInSession);
      $('#DB0223B3_D721_7EEB_50B8_032A04C7D218').prop('disabled', true);
      $('#B39BA3DE_4BA7_CE2F_BB80_BB6F4A5CB2A2').prop('disabled', false);
      this.#update(this.#userInfo, this.#roleInfo, this.#bookmarkInfo, this.#dashboardInfo, this.#awfInfo).then(() => {
        js_AMIWebApp.success(message, true);
      }, message => {
        js_AMIWebApp.error(message, true);
      });
    }, (data, message) => {
      js_AMIWebApp.error(message, true);
    });
  }
  form_detachCert() {
    js_AMIWebApp.lock();
    return js_AMICommand.detachCertificate().then((data, message) => {
      $('#C9297C00_920D_4AE6_8A20_B0DDB383CC6A').val(this.#userInfo.issuerDNInAMI = '');
      $('#D4B29AC0_4867_815B_8657_5A1D623C29CF').val(this.#userInfo.clientDNInAMI = '');
      $('#DB0223B3_D721_7EEB_50B8_032A04C7D218').prop('disabled', !this.#userInfo.clientDNInSession || !this.#userInfo.issuerDNInSession);
      $('#B39BA3DE_4BA7_CE2F_BB80_BB6F4A5CB2A2').prop('disabled', true);
      this.#update(this.#userInfo, this.#roleInfo, this.#bookmarkInfo, this.#dashboardInfo, this.#awfInfo).then(() => {
        js_AMIWebApp.success(message, true);
      }, message => {
        js_AMIWebApp.error(message, true);
      });
    }, (data, message) => {
      js_AMIWebApp.error(message, true);
    });
  }
}
/* harmony default export */ const js_AMIAuth = (new AMIAuth());
;// ./src/js/utilities/subapps.js












const _subapps = {};
let _currentSubappInstance = new function () {
  this.onReady = function () {};
  this.onExit = function () {};
  this.onLogin = function () {};
  this.onLogout = function () {};
}();
let _currentUserdata = null;
function triggerLogin() {
  const result = $.Deferred();
  if (js_AMIWebApp._isReady) {
    _internal_then(_currentSubappInstance.onLogin(_currentUserdata), message => {
      _internal_always(js_AMIWebApp.onRefresh(true), () => {
        result.resolve(message);
      });
    }, message => {
      _internal_always(js_AMIWebApp.onRefresh(true), () => {
        result.reject(message);
      });
    });
  } else {
    result.resolve();
  }
  return result.promise();
}
function triggerLogout() {
  const result = $.Deferred();
  if (js_AMIWebApp._isReady) {
    _internal_then(_currentSubappInstance.onLogout(_currentUserdata), message => {
      _internal_always(js_AMIWebApp.onRefresh(false), () => {
        result.resolve(message);
      });
    }, message => {
      _internal_always(js_AMIWebApp.onRefresh(false), () => {
        result.reject(message);
      });
    });
  } else {
    result.resolve();
  }
  return result.promise();
}
function loadSubApp(subapp, userdata, options) {
  const result = $.Deferred();
  const [context, hash, cache] = setup(['context', 'hash', 'cache'], [result, null, false], options);
  result.always(() => {
    unlock();
  });
  lock();
  if (subapp.indexOf('subapp:') === 0) {
    subapp = subapp.substring(7);
  }
  const descr = _subapps[subapp.toLowerCase()];
  if (descr) {
    try {
      loadScripts(`${js_AMIRouter.getOriginURL()}/${descr.file}`, {
        cache: cache
      }).then(() => {
        _internal_always(_currentSubappInstance.onExit(userdata), () => {
          _currentSubappInstance = window[descr.instance];
          _currentUserdata = userdata;
          js_AMIWebApp.args['subapp'] = subapp;
          js_AMIWebApp.args['userdata'] = userdata;
          _internal_then(_currentSubappInstance.onReady(userdata), () => {
            const promise = js_AMIAuth.isAuthenticated() ? triggerLogin() : triggerLogout();
            promise.then(() => {
              js_AMIRouter.appendHistoryEntry({
                searchParams: {
                  'subapp': subapp,
                  'userdata': userdata
                },
                hash: hash
              });
              fillBreadcrumb(descr.breadcrumb);
              result.resolveWith(context, [_currentSubappInstance]);
            }, message => {
              result.rejectWith(context, [`cannot load subapp '${subapp}': ${message}`]);
            });
          }, message => {
            result.rejectWith(context, [`cannot load subapp '${subapp}': ${message}`]);
          });
        });
      }, message => {
        result.rejectWith(context, [`cannot load subapp '${subapp}': ${message}`]);
      });
    } catch (message) {
      result.rejectWith(context, [`cannot load subapp '${subapp}': ${message}`]);
    }
  } else {
    result.rejectWith(context, [`cannot load subapp '${subapp}': not found`]);
  }
  return result.promise();
}
function loadSubAppAlt(subapp, userdata, options) {
  loadSubApp(subapp, userdata, options).fail(message => {
    error(message);
  });
}
function loadSubAppByURL(defaultSubApp, defaultUserData) {
  const result = $.Deferred();
  const args = js_AMIRouter.getWebAppArgs();
  if (args['v']) {
    js_AMICommand.execute('GetHashInfo -hash=?', {
      params: [args['v']]
    }).fail((data, message) => {
      result.reject(message);
    }).done(data => {
      let json;
      try {
        json = JSON.parse(jspath_default().apply('..field{.@name==="json"}.$', data)[0] || '{}');
      } catch (message) {
        json = {};
      }
      const subapp = json['subapp'] || defaultSubApp;
      const userdata = json['userdata'] || defaultUserData;
      loadSubApp(subapp, userdata).then(() => {
        result.resolve();
      }, message => {
        result.reject(message);
      });
    });
  } else if (args['u']) {
    loadSubApp('UserDashboard', args['u']).then(() => {
      result.resolve();
    }, message => {
      result.reject(message);
    });
  } else {
    if (!js_AMIRouter.check()) {
      const subapp = args['subapp'] || defaultSubApp;
      const userdata = args['userdata'] || defaultUserData;
      loadSubApp(subapp, userdata).then(() => {
        result.resolve();
      }, message => {
        result.reject(message);
      });
    }
  }
  return result.promise();
}
;// ./src/js/AMIExtension.js






/* harmony default export */ function AMIExtension() {
  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (s) {
      const base = 0x00000000000000000000;
      return this.indexOf(s, base) === base;
    };
  }
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (s) {
      const base = this.length - s.length;
      return this.indexOf(s, base) === base;
    };
  }
  if (!String.prototype.hashCode) {
    String.prototype.hashCode = function () {
      let hash = 0;
      for (let i = 0; i < this.length; i++) {
        hash = (hash << 5) - hash + this.charCodeAt(i);
        hash |= 0;
      }
      return hash < 0 ? -hash : +hash;
    };
  }
  const _ami_internal_jQueryAjax = jQuery.ajax;
  jQuery.ajax = function (options) {
    if (typeof options === 'object' && options.dataType === 'sheet') {
      const result = $.Deferred();
      const [context, media, url] = setup(['context', 'media', 'url'], [result, 'screen', ''], options);
      if (url) {
        $(document.createElement('link')).attr({
          rel: 'stylesheet',
          type: 'text/css',
          media: media,
          href: url
        }).on('load', () => {
          result.resolveWith(context);
        }).on('error', () => {
          result.rejectWith(context);
        }).appendTo('head');
      } else {
        result.rejectWith(context);
      }
      return result.promise();
    } else {
      return _ami_internal_jQueryAjax.apply(this, arguments);
    }
  };
  const _ami_internal_jQueryVal = jQuery.fn.val;
  const _ami_internal_jQueryRemove = jQuery.fn.remove;
  const _ami_internal_jQueryRemoveEvent = new jQuery.Event('remove');
  jQuery.fn.extend({
    serializeObject: function () {
      const result = {};
      this.serializeArray().forEach(item => {
        if (item.name in result) {
          if (Object.prototype.toString.call(result[item.name]) === '[object String]') {
            result[item.name] = [result[item.name]];
          }
          result[item.name].push(item.value || '');
        } else {
          result[item.name] = item.value || '';
        }
      });
      return result;
    },
    val: function () {
      if (arguments.length === 1 && this.hasClass('form-editor-done')) {
          const editorLang = this.data('editorLang');
          const editorView = this.data('editorView');
          if (editorLang && editorView) {
            const descr = language_dist/* LanguageDescription */.t$.matchLanguageName(languages, this.attr('data-lang') || 'json');
            if (descr) {
              descr.load().then(dynamicLang => {
                editorView.dispatch(editorView.state.update({
                  effects: editorLang.reconfigure(dynamicLang),
                  changes: {
                    from: 0,
                    to: editorView.state.doc.length,
                    insert: arguments[0]
                  }
                }));
              });
            } else {
              editorView.dispatch(editorView.state.update({
                effects: editorLang.reconfigure((0,lang_json_dist.json)()),
                changes: {
                  from: 0,
                  to: editorView.state.doc.length,
                  insert: arguments[0]
                }
              }));
            }
          }
          return this;
        }
      return _ami_internal_jQueryVal.apply(this, arguments);
    },
    remove: function () {
      $(this).trigger(_ami_internal_jQueryRemoveEvent);
      return _ami_internal_jQueryRemove.apply(this, arguments);
    }
  });
}
;// ./src/js/AMIInterface.js







function _setupCtx(ctxImmutables, ctxDefaults, ctxOptions, ctx, immutables, defaults, options) {
  if (options) {
    for (var _i = 0, _Object$entries = Object.entries(options); _i < _Object$entries.length; _i++) {
      let [key, val] = _Object$entries[_i];
      ctxOptions[key] = val;
      ctx[key] = val;
    }
  }
  if (defaults) {
    for (var _i2 = 0, _Object$entries2 = Object.entries(defaults); _i2 < _Object$entries2.length; _i2++) {
      let [key, val] = _Object$entries2[_i2];
      if (!(key in ctx)) {
        if (key !== 'context') {
          ctxDefaults[key] = val;
          ctxOptions[key] = val;
        }
        ctx[key] = val;
      }
    }
  }
  if (immutables) {
    for (var _i3 = 0, _Object$entries3 = Object.entries(immutables); _i3 < _Object$entries3.length; _i3++) {
      let [key, val] = _Object$entries3[_i3];
      ctxImmutables[key] = val;
      ctx[key] = val;
    }
  }
  ctx.httpEndpoint = js_AMICommand.getHttpEndpoint();
  ctx.mqttEndpoint = js_AMICommand.getMqttEndpoint();
  return ctx;
}
/* harmony default export */ function AMIInterface() {
  $AMIInterface('ami.IControl', {
    onReady: function () {},
    onRemove: function () {},
    patchId: function (id) {},
    replaceHTML: function (selector, twig, options) {},
    prependHTML: function (selector, twig, options) {},
    appendHTML: function (selector, twig, options) {}
  });
  $AMIInterface('ami.IContainer', {
    render: function (selector, options) {},
    prependItem: function (title, options) {},
    appendItem: function (title, options) {},
    removeItem: function (itemId) {},
    removeAllItems: function () {},
    isEmpty: function () {}
  });
  $AMIClass('ami.Control', {
    $implements: [ami.IControl],
    $: function () {
      ami.Control._instanceScopeCnt = 1;
    },
    $init: function (parent, owner) {
      this.ctxImmutables = {};
      this.ctxDefaults = {};
      this.ctxOptions = {};
      this.ctx = {};
      this._parent = parent || this;
      this._owner = owner || this;
      this._twigDict = {};
      this._instanceScope = ami.Control._instanceScopeCnt++;
    },
    onReady: function () {},
    onRemove: function () {},
    setParent: function (parent) {
      return this._parent = parent || this;
    },
    getParent: function () {
      return this._parent;
    },
    setOwner: function (owner) {
      return this._owner = owner || this;
    },
    getOwner: function () {
      return this._owner;
    },
    setSelector: function (selector) {
      if (selector) {
        $(selector).off('remove').on('remove', () => {
          this.onRemove();
        });
      }
      return this._selector = selector || '';
    },
    getSelector: function () {
      return this._selector;
    },
    setupCtx: function (immutables, defaults, options) {
      return _setupCtx(this.ctxImmutables, this.ctxDefaults, this.ctxOptions, this.ctx, immutables, defaults, options);
    },
    patchId: function (id) {
      return `${id}_scope${this._instanceScope}`;
    },
    replaceHTML: function (selector, twig, options) {
      if (!isMap(options)) {
        options = {};
      }
      if (!isMap(options['dict'])) {
        options['dict'] = {};
      }
      Object.assign(options['dict'], this._twigDict);
      options.scope = this._instanceScope;
      return replaceHTML(selector, twig, options);
    },
    prependHTML: function (selector, twig, options) {
      if (!isMap(options)) {
        options = {};
      }
      if (!isMap(options['dict'])) {
        options['dict'] = {};
      }
      Object.assign(options['dict'], this._twigDict);
      options.scope = this._instanceScope;
      return prependHTML(selector, twig, options);
    },
    appendHTML: function (selector, twig, options) {
      if (!isMap(options)) {
        options = {};
      }
      if (!isMap(options['dict'])) {
        options['dict'] = {};
      }
      Object.assign(options['dict'], this._twigDict);
      options.scope = this._instanceScope;
      return appendHTML(selector, twig, options);
    },
    createControl: function (parent, control, params, options) {
      return createControl(parent, this, control, params, options);
    },
    createControlInBody: function (parent, control, controlParams, controlOptions, options) {
      return createControlInBody(parent, this, control, controlParams, controlOptions, this.ctx, options);
    },
    createControlInContainer: function (parent, control, controlParams, controlOptions, icon, title, options) {
      return createControlInContainer(parent, this, control, controlParams, controlOptions, this.ctx, icon, title, options);
    },
    createControlFromWebLink: function (parent, el, options) {
      return createControlFromWebLink(parent, this, el, this.ctx, options);
    }
  });
  $AMIInterface('ami.ISubApp', {
    onReady: function (userdata) {},
    onExit: function (userdata) {},
    onLogin: function (userdata) {},
    onLogout: function (userdata) {}
  });
  $AMIClass('ami.SubApp', {
    $implements: [ami.ISubApp],
    $init: function () {
      this.ctxImmutables = {};
      this.ctxDefaults = {};
      this.ctxOptions = {};
      this.ctx = {};
    },
    onReady: function () {},
    onExit: function () {},
    onLogin: function () {},
    onLogout: function () {},
    setupCtx: function (immutables, defaults, options) {
      return _setupCtx(this.ctxImmutables, this.ctxDefaults, this.ctxOptions, this.ctx, immutables, defaults, options);
    },
    createControl: function (parent, control, params, options) {
      return createControl(parent, this, control, params, options);
    },
    createControlInBody: function (parent, control, controlParams, controlOptions, options) {
      return createControlInBody(parent, this, control, controlParams, controlOptions, this.ctx, options);
    },
    createControlInContainer: function (parent, control, controlParams, controlOptions, icon, title, options) {
      return createControlInContainer(parent, this, control, controlParams, controlOptions, this.ctx, icon, title, options);
    },
    createControlFromWebLink: function (parent, el, options) {
      return createControlFromWebLink(parent, this, el, this.ctx, options);
    }
  });
}
;// ./src/images/lpsc.png
const lpsc_namespaceObject = __webpack_require__.p + "assets/images/lpsc.png";
;// ./src/images/cloud.png
const cloud_namespaceObject = __webpack_require__.p + "assets/images/cloud.png";
;// ./src/images/glass.png
const glass_namespaceObject = __webpack_require__.p + "assets/images/glass.png";
;// ./src/images/padlock.png
const padlock_namespaceObject = __webpack_require__.p + "assets/images/padlock.png";
;// ./src/images/logo.png
const logo_namespaceObject = __webpack_require__.p + "assets/images/logo.png";
;// ./src/images/background-light.jpg
const background_light_namespaceObject = __webpack_require__.p + "assets/images/background-light.jpg";
;// ./src/images/background-dark.jpg
const background_dark_namespaceObject = __webpack_require__.p + "assets/images/background-dark.jpg";
;// ./src/images/sign_in_image.jpg
const sign_in_image_namespaceObject = __webpack_require__.p + "assets/images/sign_in_image.jpg";
;// ./src/js/AMIWebApp.js


























class AMIWebApp {
  #embedded = false;
  #noBootstrap = false;
  #noMoment = false;
  #noSelect2 = false;
  #globalDeferred = (() => $.Deferred())();
  _isReady = false;
  webAppURL = '';
  scriptURL = '';
  originURL = '';
  args = {};
  hash = '';
  bootstrapVersion = 4;
  constructor() {
    $AMINamespace('ami', {
      awf: {
        buildVersion: '2.0.0',
        commitIdAbbrev: '{{AMI_COMMIT_ID}}',
        globalTwigDict: {
          'BUILD_VERSION': '2.0.0',
          'COMMIT_ID_ABBREV': '{{AMI_COMMIT_ID}}'
        },
        command: js_AMICommand,
        router: js_AMIRouter,
        webapp: this,
        auth: js_AMIAuth
      },
      vue: {
        version: 'N/A'
      }
    });
    AMIExtension();
    AMIInterface();
    const scriptArgs = js_AMIRouter.getScriptArgs();
    this.#embedded = 'embedded' in scriptArgs;
    this.#noBootstrap = 'nobootstrap' in scriptArgs;
    this.#noSelect2 = 'noselect2' in scriptArgs;
    this.#noMoment = 'nomoment' in scriptArgs;
    this.webAppURL = js_AMIRouter.getWebAppURL();
    this.scriptURL = js_AMIRouter.getScriptURL();
    this.originURL = js_AMIRouter.getOriginURL();
    this.args = js_AMIRouter.getWebAppArgs();
    this.hash = js_AMIRouter.getWebAppHash();
    this.bootstrapVersion = parseInt(scriptArgs.bootstrap);
    if (Number.isNaN(this.bootstrapVersion)) {
      this.bootstrapVersion = 4;
    }
    const resourcesCSS = [];
    const resourcesJS = [];
    if (!this.#noBootstrap && typeof jQuery.fn.modal !== 'function') {
      if (this.bootstrapVersion === 4) {
        resourcesJS.push(`${this.originURL}/js/assets/css/bootstrap4.min.css`);
        resourcesJS.push(`${this.originURL}/js/assets/js/bootstrap4.bundle.min.js`);
      } else {
        resourcesJS.push(`${this.originURL}/js/assets/css/bootstrap5.min.css`);
        resourcesJS.push(`${this.originURL}/js/assets/js/bootstrap5.bundle.min.js`);
      }
    }
    if (!this.#noSelect2 && typeof jQuery.fn.select2 !== 'function') {
      resourcesCSS.push(`${this.originURL}/js/assets/css/select2.min.css`);
      resourcesJS.push(`${this.originURL}/js/assets/js/select2.min.js`);
    }
    if (!this.#noMoment && typeof window.moment !== 'function') {
      resourcesJS.push(`${this.originURL}/js/assets/js/moment.min.js`);
    }
    loadResources([...resourcesCSS, ...resourcesJS], {
      cache: true
    }).done(resources => {
      window.JSPath = (jspath_default());
      __webpack_require__(850);
      __webpack_require__(6693)(window.moment);
      this.#globalDeferred.resolve(resources);
    }).fail(message => {
      this.#globalDeferred.reject(message);
    });
  }
  isEmbedded() {
    return this.#embedded;
  }
  _internal_then = (() => _internal_then)();
  _internal_always = (() => _internal_always)();
  typeOf = (() => typeOf)();
  asArray = (() => asArray)();
  isString = (() => isString)();
  isArray = (() => isArray)();
  isObject = (() => isObject)();
  isSet = (() => isSet)();
  isMap = (() => isMap)();
  setupParams = (() => setupParams)();
  setup = (() => setup)();
  getStack = (() => getStack)();
  lock = (() => lock)();
  unlock = (() => unlock)();
  modalEnter = (() => modalEnter)();
  modalLeave = (() => modalLeave)();
  canLeave = (() => canLeave)();
  error = (() => error)();
  info = (() => info)();
  success = (() => success)();
  warning = (() => warning)();
  flush = (() => flush)();
  base64Encode = (() => base64Encode)();
  base64Decode = (() => base64Decode)();
  textToHtml = (() => textToHtml)();
  htmlToText = (() => htmlToText)();
  textToString = (() => textToString)();
  stringToText = (() => stringToText)();
  htmlToString = (() => htmlToString)();
  stringToHtml = (() => stringToHtml)();
  textToSQL = (() => textToSQL)();
  sqlToText = (() => sqlToText)();
  fillBreadcrumb = (() => fillBreadcrumb)();
  replaceHTML = (() => replaceHTML)();
  prependHTML = (() => prependHTML)();
  appendHTML = (() => appendHTML)();
  parentHTML = (() => parentHTML)();
  formatTWIG = (() => formatTWIG)();
  renderJSDoc = (() => renderJSDoc)();
  jspath = (() => (jspath_default()).apply)();
  loadResources = (() => loadResources)();
  loadSheets = (() => loadSheets)();
  loadScripts = (() => loadScripts)();
  loadJSONs = (() => loadJSONs)();
  loadXMLs = (() => loadXMLs)();
  loadHTMLs = (() => loadHTMLs)();
  loadTWIGs = (() => loadTWIGs)();
  loadTexts = (() => loadTexts)();
  _subapps = (() => _subapps)();
  loadSubApp = (() => loadSubApp)();
  loadSubAppAlt = (() => loadSubAppAlt)();
  loadSubAppByURL = (() => loadSubAppByURL)();
  _controls = (() => _controls)();
  loadControl = (() => loadControl)();
  createControl = (() => createControl)();
  createControlInBody = (() => createControlInBody)();
  createControlInContainer = (() => createControlInContainer)();
  createControlFromWebLink = (() => createControlFromWebLink)();
  onReady(userdata) {
    if (!this.#embedded) {
      alert('error: \'amiWebApp.onReady()\' must be overloaded!');
    }
    return null;
  }
  onRefresh(isAuth) {
    if (!this.#embedded) {
      alert('error: \'amiWebApp.onRefresh()\' must be overloaded!');
    }
    return null;
  }
  start(options) {
    amiWebApp.themeSet(localStorage.getItem('theme') || 'light');
    this.#globalDeferred.done(() => {
      const [logoURL, backgroundLightURL, backgroundDarkURL, signInImageURL, homeURL, contactEmail, aboutURL, defaultThemeURL, dashboardThemeURL, lockerURL, endpointURL, signInText, ssoAutoAuthentication, ssoAuthenticationAllowed, passwordAuthenticationAllowed, certificateAuthenticationAllowed, signOutAllowed, createAccountAllowed, changeInfoAllowed, changePasswordAllowed, changeCertificateAllowed, captchaAllowed, dayNightAllowed, bookmarksAllowed, dashboardsAllowed] = setup(['logo_url', 'background_light_url', 'background_dark_url', 'sign_in_image_url', 'home_url', 'contact_email', 'about_url', 'default_theme_url', 'dashboard_theme_url', 'locker_url', 'endpoint_url', 'sign_in_text', 'sso_auto_authentication', 'sso_authentication_allowed', 'password_authentication_allowed', 'certificate_authentication_allowed', 'sign_out_allowed', 'create_account_allowed', 'change_info_allowed', 'change_password_allowed', 'change_certificate_allowed', 'captcha_allowed', 'day_night_allowed', 'bookmarks_allowed', 'dashboards_allowed'], [logo_namespaceObject, background_light_namespaceObject, background_dark_namespaceObject, sign_in_image_namespaceObject, this.webAppURL, 'ami@lpsc.in2p3.fr', 'https://cern.ch/ami/', `${this.originURL}/twig/v${this.bootstrapVersion}/Themes/blue.twig`, `${this.originURL}/twig/v${this.bootstrapVersion}/Themes/cloud.twig`, `${this.originURL}/twig/v${this.bootstrapVersion}/Lockers/default.twig`, `${this.originURL}/AMI/FrontEnd`, 'Welcome in AMI!', false, false, true, true, true, true, true, true, true, true, true, true, true], options);
      js_AMICommand.initHttpClient(endpointURL);
      window.onbeforeunload = e => {
        if (!_canLeave) {
          const f = e || window.event;
          if (f) {
            f.returnValue = 'Confirm that you want to leave this page?';
          }
          return 'Confirm that you want to leave this page?';
        }
      };
      const controlsURL = `${this.originURL}/controls/CONTROLS.json`;
      const subappsURL = `${this.originURL}/subapps/SUBAPPS.json`;
      $.ajax({
        url: controlsURL,
        cache: false,
        crossDomain: true,
        dataType: 'json'
      }).then(data1 => {
        $.ajax({
          url: subappsURL,
          cache: false,
          crossDomain: true,
          dataType: 'json'
        }).then(data2 => {
          for (const name in data1) {
            _controls[name.toLowerCase()] = data1[name];
          }
          for (const name in data2) {
            _subapps[name.toLowerCase()] = data2[name];
          }
          if (!this.#embedded) {
            const dict = {
              LOGO_URL: logoURL,
              BACKGROUND_LIGHT_URL: backgroundLightURL,
              BACKGROUND_DARK_URL: backgroundDarkURL,
              HOME_URL: homeURL,
              CONTACT_EMAIL: contactEmail,
              ABOUT_URL: aboutURL
            };
            const themeURL = (js_AMIRouter.getWebAppArgs()['subapp'] || '').toLowerCase() === 'userdashboard' || js_AMIRouter.getWebAppArgs()['u'] ? dashboardThemeURL : defaultThemeURL;
            $.ajax({
              url: themeURL,
              cache: true,
              crossDomain: true,
              dataType: 'text'
            }).then(data3 => {
              $.ajax({
                url: lockerURL,
                cache: true,
                crossDomain: true,
                dataType: 'text'
              }).then(data4 => {
                $('body').append(formatTWIG(data3, dict) + data4).promise().done(() => {
                  lock();
                  js_AMIAuth.init(signInImageURL, signInText, ssoAutoAuthentication, ssoAuthenticationAllowed, passwordAuthenticationAllowed, certificateAuthenticationAllowed, signOutAllowed, createAccountAllowed, changeInfoAllowed, changePasswordAllowed, changeCertificateAllowed, captchaAllowed, dayNightAllowed, bookmarksAllowed, dashboardsAllowed).done(() => {
                    unlock();
                  }).fail(message => {
                    error(message);
                  });
                });
              }, () => {
                alert(`could not open '${lockerURL}', please reload the page...`);
              });
            }, () => {
              alert(`could not open '${themeURL}', please reload the page...`);
            });
          } else {
            let data3 = '';
            if ($('#ami_alert_content').length === 0) {
              data3 += '<div id="ami_alert_content"></div>';
            }
            if ($('#ami_login_menu_content').length === 0) {
              data3 += '<ul id="ami_login_menu_content"></ul>';
            }
            $.ajax({
              url: lockerURL,
              cache: true,
              crossDomain: true,
              dataType: 'text'
            }).done(data4 => {
              $('body').prepend(data3 + data4).promise().done(() => {
                lock();
                js_AMIAuth.init(signInImageURL, signInText, ssoAutoAuthentication, ssoAuthenticationAllowed, passwordAuthenticationAllowed, certificateAuthenticationAllowed, signOutAllowed, createAccountAllowed, changeInfoAllowed, changePasswordAllowed, changeCertificateAllowed, captchaAllowed, dayNightAllowed, false, false).done(() => {
                  unlock();
                }).fail(message => {
                  error(message);
                });
              });
            });
          }
        }, () => {
          alert(`cannot open '${subappsURL}', please reload the page...`);
        });
      }, () => {
        alert(`cannot open '${controlsURL}', please reload the page...`);
      });
    }).fail(message => {
      alert(message);
    });
    return this;
  }
  themeSet(theme) {
    document.documentElement.setAttribute('data-bs-theme', theme);
    const el1 = $('#B3094B72_95CB_0F9F_0364_0ED6B6DCD6EF');
    const el2 = $('label[for="B3094B72_95CB_0F9F_0364_0ED6B6DCD6EF"] i');
    if (theme === 'dark') {
      el1.prop('checked', true);
      el2.addClass('bi-moon-stars-fill').removeClass('bi-sun-fill').addClass('text-primary').removeClass('text-warning');
    } else {
      el1.prop('checked', false);
      el2.removeClass('bi-moon-stars-fill').addClass('bi-sun-fill').removeClass('text-primary').addClass('text-warning');
    }
    localStorage.setItem('theme', theme);
  }
}
/* harmony default export */ const js_AMIWebApp = (new AMIWebApp());
;// ./src/js/AMIDoc.js

/* harmony default export */ const AMIDoc = ({
  "namespaces": [{
    "name": "amiAuth",
    "alias": "amiLogin",
    "desc": "The AMI authentication subsystem",
    "implements": [],
    "inherits": [],
    "functions": [{
      "name": "getJWTToken",
      "alias": "",
      "desc": "Gets the current JWT token",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current JWT token"
      }]
    }, {
      "name": "getMQTTBrokerEndpoint",
      "alias": "",
      "desc": "Gets the current MQTT broker endpoint",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current MQTT broker endpoint"
      }]
    }, {
      "name": "getAMIPipelineEndpoint",
      "alias": "",
      "desc": "Gets the current AMI Pipeline endpoint",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current AMI Pipeline endpoint"
      }]
    }, {
      "name": "getUserInfo",
      "alias": "",
      "desc": "Gets the current user information",
      "params": [],
      "returns": [{
        "type": ["Object.<string, *>"],
        "desc": "The current user information"
      }]
    }, {
      "name": "getRoleInfo",
      "alias": "",
      "desc": "Gets the current role information",
      "params": [],
      "returns": [{
        "type": ["Object.<string, *>"],
        "desc": "The current role information"
      }]
    }, {
      "name": "getBookmarkInfo",
      "alias": "",
      "desc": "Gets the current bookmark information",
      "params": [],
      "returns": [{
        "type": ["Object.<string, *>"],
        "desc": "The current bookmark information"
      }]
    }, {
      "name": "getDashboardInfo",
      "alias": "",
      "desc": "Gets the current dashboard information",
      "params": [],
      "returns": [{
        "type": ["Object.<string, *>"],
        "desc": "The current dashboard information"
      }]
    }, {
      "name": "getAWFInfo",
      "alias": "",
      "desc": "Gets the current AMI Web Framework information",
      "params": [],
      "returns": [{
        "type": ["Object.<string, *>"],
        "desc": "The current AMI Web Framework information"
      }]
    }, {
      "name": "getUser",
      "alias": "",
      "desc": "Gets the current user",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current user"
      }]
    }, {
      "name": "getGuest",
      "alias": "",
      "desc": "Gets the current guest user",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current guest user"
      }]
    }, {
      "name": "getNotBeforeDate",
      "alias": "",
      "desc": "Gets the current user `not before` date",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current user `not before` date"
      }]
    }, {
      "name": "getNotAfterDate",
      "alias": "",
      "desc": "Gets the current user `not after` date",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current user `not after` date"
      }]
    }, {
      "name": "getClientDN",
      "alias": "",
      "desc": "Gets the current client DN",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current client DN"
      }]
    }, {
      "name": "getIssuerDN",
      "alias": "",
      "desc": "Gets the current issuer DN",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The current issuer DN"
      }]
    }, {
      "name": "isValid",
      "alias": "",
      "desc": "Checks whether the user is valid or not",
      "params": [],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "isAuthenticated",
      "alias": "",
      "desc": "Checks whether the user is authenticated or not",
      "params": [],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "hasRole",
      "alias": "",
      "desc": "Checks whether the user has the given role or not",
      "params": [{
        "name": "roleName",
        "type": ["string"],
        "desc": "the role",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "update",
      "alias": "",
      "desc": "Update the user information",
      "params": [],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "sso",
      "alias": "",
      "desc": "Opens the SSO popup window",
      "params": []
    }, {
      "name": "signIn",
      "alias": "",
      "desc": "Signs in",
      "params": []
    }, {
      "name": "signOut",
      "alias": "",
      "desc": "Signs out",
      "params": []
    }, {
      "name": "changeInfo",
      "alias": "",
      "desc": "Opens the 'Change Info' modal window",
      "params": []
    }, {
      "name": "changePass",
      "alias": "",
      "desc": "Opens the 'Change Password' modal window",
      "params": []
    }, {
      "name": "changeCertificate",
      "alias": "",
      "desc": "Opens the 'Change Certificate' modal window",
      "params": []
    }, {
      "name": "accountStatus",
      "alias": "",
      "desc": "Opens the 'Account Status' modal window",
      "params": []
    }]
  }, {
    "name": "amiCommand",
    "alias": "",
    "desc": "The AMI command subsystem",
    "implements": [],
    "inherits": [],
    "functions": [{
      "name": "initHttpClient",
      "alias": "",
      "desc": "Initializes the HTTP client",
      "params": [{
        "name": "endpoint",
        "type": ["string"],
        "desc": "the HTTP endpoint",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }, {
      "name": "initMqttClient",
      "alias": "",
      "desc": "Initializes the MQTT client",
      "params": [{
        "name": "endpoint",
        "type": ["string"],
        "desc": "the MQTT endpoint",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }, {
      "name": "getHttpEndpoint",
      "alias": "",
      "desc": "Gets the HTTP endpoint",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": ""
      }]
    }, {
      "name": "getMqttEndpoint",
      "alias": "",
      "desc": "Gets the MQTT endpoint",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": ""
      }]
    }, {
      "name": "execute",
      "alias": "",
      "desc": "Executes an AMI command",
      "params": [{
        "name": "command",
        "type": ["string"],
        "desc": "the command",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (mqtt, endpoint, serverName, converter, extras, params, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "mqttSignInByToken",
      "alias": "",
      "desc": "Signs in by JWT token (MQTT client)",
      "params": [{
        "name": "token",
        "type": ["string"],
        "desc": "the password",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "serverName",
        "type": ["string"],
        "desc": "the server name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "mqttSignOut",
      "alias": "",
      "desc": "Signs out (MQTT client)",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "signInByCode",
      "alias": "",
      "desc": "Signs in by code (HTTP client)",
      "params": [{
        "name": "code",
        "type": ["string"],
        "desc": "the code",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "signInByToken",
      "alias": "",
      "desc": "Signs in by token (HTTP client)",
      "params": [{
        "name": "token",
        "type": ["string"],
        "desc": "the token",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "signInByPassword",
      "alias": "",
      "desc": "Signs in by login/password (HTTP client)",
      "params": [{
        "name": "username",
        "type": ["string"],
        "desc": "the username",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "password",
        "type": ["string"],
        "desc": "the password",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "signInByCertificate",
      "alias": "",
      "desc": "Signs in by certificate (HTTP client)",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "signOut",
      "alias": "",
      "desc": "Signs out (HTTP client)",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "attachCertificate",
      "alias": "",
      "desc": "Attaches a certificate",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, converter, extras, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "detachCertificate",
      "alias": "",
      "desc": "Detaches a certificate",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, converter, extras, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "addUser",
      "alias": "",
      "desc": "Adds a new username",
      "params": [{
        "name": "username",
        "type": ["string"],
        "desc": "the username",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "password",
        "type": ["string"],
        "desc": "the password",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "firstName",
        "type": ["string"],
        "desc": "the first name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "lastName",
        "type": ["string"],
        "desc": "the last name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "email",
        "type": ["string"],
        "desc": "the email",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "captchaHash",
        "type": ["string"],
        "desc": "the captcha hash generated by AMI",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "captchaText",
        "type": ["string"],
        "desc": "the captcha text entered by the username",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "attachCert",
        "type": ["boolean"],
        "desc": "attach the current certificate",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "agree",
        "type": ["boolean"],
        "desc": "agree with the terms and conditions",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, converter, extras, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "changeInfo",
      "alias": "",
      "desc": "Changes the account information",
      "params": [{
        "name": "firstName",
        "type": ["string"],
        "desc": "the first name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "lastName",
        "type": ["string"],
        "desc": "the last name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "email",
        "type": ["string"],
        "desc": "the email",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, converter, extras, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "changePassword",
      "alias": "",
      "desc": "Changes the account password",
      "params": [{
        "name": "username",
        "type": ["string"],
        "desc": "the username",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "oldPassword",
        "type": ["string"],
        "desc": "the old password",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "newPassword",
        "type": ["string"],
        "desc": "the new password",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, converter, extras, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "resetPassword",
      "alias": "",
      "desc": "Resets the account password",
      "params": [{
        "name": "username",
        "type": ["string"],
        "desc": "the username",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "captchaHash",
        "type": ["string"],
        "desc": "the captcha hash generated by AMI",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "captchaText",
        "type": ["string"],
        "desc": "the captcha text entered by the username",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (endpoint, converter, extras, timeout)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }]
  }, {
    "name": "amiRouter",
    "alias": "",
    "desc": "The AMI url routing subsystem",
    "implements": [],
    "inherits": [],
    "functions": [{
      "name": "getWebAppURL",
      "alias": "",
      "desc": "Gets the webapp URL",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The webapp URL"
      }]
    }, {
      "name": "getWebAppArgs",
      "alias": "",
      "desc": "Gets the arguments of the webapp URL",
      "params": [],
      "returns": [{
        "type": ["Object.<string, string>"],
        "desc": "The arguments of the webapp URL"
      }]
    }, {
      "name": "getWebAppHash",
      "alias": "",
      "desc": "Gets the anchor part of the webapp URL",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The anchor part of the webapp URL"
      }]
    }, {
      "name": "getScriptURL",
      "alias": "",
      "desc": "Gets the script URL",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The script URL"
      }]
    }, {
      "name": "getScriptArgs",
      "alias": "",
      "desc": "Gets the arguments of the script URL",
      "params": [],
      "returns": [{
        "type": ["Object.<string, string>"],
        "desc": "The arguments of the the script URL"
      }]
    }, {
      "name": "getWebappHash",
      "alias": "",
      "desc": "Gets anchor part of the script URL",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The anchor part of the script URL"
      }]
    }, {
      "name": "getOriginURL",
      "alias": "",
      "desc": "Gets the origin URL",
      "params": [],
      "returns": [{
        "type": ["string"],
        "desc": "The origin URL"
      }]
    }, {
      "name": "append",
      "alias": "",
      "desc": "Appends a routing rule",
      "params": [{
        "name": "regExp",
        "type": ["string"],
        "desc": "the regExp",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "callback",
        "type": ["function"],
        "desc": "the callback",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["AMIRouter"],
        "desc": "The amiRouter singleton"
      }]
    }, {
      "name": "remove",
      "alias": "",
      "desc": "Removes a routing rule",
      "params": [{
        "name": "regExp",
        "type": ["string"],
        "desc": "the regExp",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["AMIRouter"],
        "desc": "The amiRouter singleton"
      }]
    }, {
      "name": "check",
      "alias": "",
      "desc": "Checks whether the URL matches with a routing rule",
      "params": [],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "appendHistoryEntry",
      "alias": "",
      "desc": "Appends a new history entry",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, searchParams, hash)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "replaceHistoryEntry",
      "alias": "",
      "desc": "Replaces the current history entry",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, searchParams, hash)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }]
  }, {
    "name": "amiWebApp",
    "alias": "",
    "desc": "The AMI webapp subsystem",
    "implements": [],
    "inherits": [],
    "variables": [{
      "name": "webAppURL",
      "alias": "",
      "type": ["string"],
      "desc": "The webapp URL"
    }, {
      "name": "scriptURL",
      "alias": "",
      "type": ["string"],
      "desc": "The script URL"
    }, {
      "name": "originURL",
      "alias": "",
      "type": ["string"],
      "desc": "The origin URL"
    }, {
      "name": "args",
      "alias": "",
      "type": ["Object.<string, string>"],
      "desc": "The arguments of the webapp URL"
    }, {
      "name": "hash",
      "alias": "",
      "type": ["string"],
      "desc": "The anchor part of the webapp URL"
    }, {
      "name": "bootstrapVersion",
      "alias": "",
      "type": ["number"],
      "desc": "The Twitter Bootstrap's version (default, 4)"
    }],
    "events": [{
      "name": "onReady",
      "alias": "",
      "desc": "This method must be overloaded and is called when the Web application starts",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }]
    }, {
      "name": "onRefresh",
      "alias": "",
      "desc": "This method must be overloaded and is called when the toolbar needs to be updated",
      "params": [{
        "name": "isAuth",
        "type": ["boolean"],
        "desc": "is the user authenticated",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }],
    "functions": [{
      "name": "start",
      "alias": "",
      "desc": "Starts the Web application",
      "params": [{
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (logo_url, background_light_url, background_dark_url, sign_in_image_url, home_url, contact_email, about_url, default_theme_url, dashboard_theme_url, locker_url, endpoint_url, sso_auto_authentication, sso_authentication_allowed, password_authentication_allowed, certificate_authentication_allowed, sign_out_allowed, create_account_allowed, change_info_allowed, change_password_allowed, change_certificate_allowed, captcha_allowed, day_night_allowed, bookmarks_allowed, dashboards_allowed)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["AMIWebApp"],
        "desc": ""
      }]
    }, {
      "name": "_internal_then",
      "alias": "",
      "desc": "",
      "params": [{
        "name": "deferred",
        "type": ["$.Deferred"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "doneCallback",
        "type": ["function"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "failCallback",
        "type": ["function"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }, {
      "name": "_internal_always",
      "alias": "",
      "desc": "",
      "params": [{
        "name": "deferred",
        "type": ["$.Deferred"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "alwaysCallback",
        "type": ["function"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }, {
      "name": "typeOf",
      "alias": "",
      "desc": "Gets the type name of the given object",
      "params": [{
        "name": "x",
        "type": ["*"],
        "desc": "the object",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The type name of the given object"
      }]
    }, {
      "name": "asArray",
      "alias": "",
      "desc": "Turns the given object into an array if it is not already the case",
      "params": [{
        "name": "x",
        "type": ["*"],
        "desc": "the object",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["Array.<*>"],
        "desc": "The resulting array"
      }]
    }, {
      "name": "isString",
      "alias": "",
      "desc": "Checks whether the given object is a string",
      "params": [{
        "name": "x",
        "type": ["*"],
        "desc": "the object",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "isArray",
      "alias": "",
      "desc": "Checks whether the given object is an array",
      "params": [{
        "name": "x",
        "type": ["*"],
        "desc": "the object",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "isObject",
      "alias": "",
      "desc": "Checks whether the given object is an object",
      "params": [{
        "name": "x",
        "type": ["*"],
        "desc": "the object",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "isSet",
      "alias": "",
      "desc": "Checks whether the given object is a set",
      "params": [{
        "name": "x",
        "type": ["*"],
        "desc": "the object",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "isMap",
      "alias": "",
      "desc": "Checks whether the given object is a map",
      "params": [{
        "name": "x",
        "type": ["*"],
        "desc": "the object",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }, {
      "name": "setup",
      "alias": "",
      "desc": "",
      "params": [{
        "name": "optionNames",
        "type": ["Array.<string>"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "optionDefaults",
        "type": ["Array.<*>"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["Array.<*>"],
        "desc": ""
      }]
    }, {
      "name": "lock",
      "alias": "",
      "desc": "Locks the Web application",
      "params": []
    }, {
      "name": "unlock",
      "alias": "",
      "desc": "Unlocks the Web application",
      "params": []
    }, {
      "name": "modalEnter",
      "alias": "",
      "desc": "Enter the modal window",
      "params": []
    }, {
      "name": "modalLeave",
      "alias": "",
      "desc": "Leave the modal window",
      "params": []
    }, {
      "name": "canLeave",
      "alias": "",
      "desc": "Specifies whether leaving the current page must be confirmed or not",
      "params": [{
        "name": "canLeave",
        "type": [],
        "desc": "",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }, {
      "name": "error",
      "alias": "",
      "desc": "Shows an 'error' message",
      "params": [{
        "name": "message",
        "type": ["string", "Array.<string>"],
        "desc": "the message",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "fadeOut",
        "type": ["boolean"],
        "desc": "if True, the message disappears after 60s",
        "default": false,
        "optional": true,
        "nullable": ""
      }]
    }, {
      "name": "info",
      "alias": "",
      "desc": "Shows an 'info' message",
      "params": [{
        "name": "message",
        "type": ["string", "Array.<string>"],
        "desc": "the message",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "fadeOut",
        "type": ["boolean"],
        "desc": "if True, the message disappears after 60s",
        "default": false,
        "optional": true,
        "nullable": ""
      }]
    }, {
      "name": "success",
      "alias": "",
      "desc": "Shows a 'success' message",
      "params": [{
        "name": "message",
        "type": ["string", "Array.<string>"],
        "desc": "the message",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "fadeOut",
        "type": ["boolean"],
        "desc": "if True, the message disappears after 60s",
        "default": false,
        "optional": true,
        "nullable": ""
      }]
    }, {
      "name": "warning",
      "alias": "",
      "desc": "Shows a 'warning' message",
      "params": [{
        "name": "message",
        "type": ["string", "Array.<string>"],
        "desc": "the message",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "fadeOut",
        "type": ["boolean"],
        "desc": "if True, the message disappears after 60s",
        "default": false,
        "optional": true,
        "nullable": ""
      }]
    }, {
      "name": "flush",
      "alias": "",
      "desc": "Flushes messages",
      "params": []
    }, {
      "name": "base64Encode",
      "alias": "",
      "desc": "Encodes the given string to base64",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the decoded string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The encoded string"
      }]
    }, {
      "name": "base64Decode",
      "alias": "",
      "desc": "Decodes the given string from base64",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the encoded string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The decoded string"
      }]
    }, {
      "name": "textToHtml",
      "alias": "",
      "desc": "Escapes the given string from text to HTML",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the unescaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The escaped string"
      }]
    }, {
      "name": "htmlToText",
      "alias": "",
      "desc": "Unescapes the given string from HTML to text",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the escaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The unescaped string"
      }]
    }, {
      "name": "textToString",
      "alias": "",
      "desc": "Escapes the given string from text to JavaScript string",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the unescaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The escaped string"
      }]
    }, {
      "name": "stringToText",
      "alias": "",
      "desc": "Unescapes the given string from JavaScript string to text",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the escaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The unescaped string"
      }]
    }, {
      "name": "htmlToString",
      "alias": "",
      "desc": "Escapes the given string from HTML to JavaScript string",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the unescaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The escaped string"
      }]
    }, {
      "name": "stringToHtml",
      "alias": "",
      "desc": "Unescapes the given string from JavaScript string to HTML",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the escaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The unescaped string"
      }]
    }, {
      "name": "textToSQL",
      "alias": "",
      "desc": "Escapes the given string from text to SQL",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the unescaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The escaped string"
      }]
    }, {
      "name": "sqlToText",
      "alias": "",
      "desc": "Unescapes the given string from SQL to text",
      "params": [{
        "name": "s",
        "type": ["string"],
        "desc": "the escaped string",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The unescaped string"
      }]
    }, {
      "name": "fillBreadcrumb",
      "alias": "",
      "desc": "Fills the main breadcrumb",
      "params": [{
        "name": "items",
        "type": ["Array.<string>", "string"],
        "desc": "the array of HTML formatted items",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }, {
      "name": "replaceHTML",
      "alias": "",
      "desc": "Puts a HTML or TWIG fragment to the given target",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, scope, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "see": ["method [formatTWIG]{@link #jsdoc_method_formatTWIG}"],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "prependHTML",
      "alias": "",
      "desc": "Prepends a HTML or TWIG fragment to the given target",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, scope, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "see": ["method [formatTWIG]{@link #jsdoc_method_formatTWIG}"],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "appendHTML",
      "alias": "",
      "desc": "Appends a HTML or TWIG fragment to the given target",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, scope, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "see": ["method [formatTWIG]{@link #jsdoc_method_formatTWIG}"],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "parentHTML",
      "alias": "",
      "desc": "Puts a HTML or TWIG fragment to the given target",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, scope, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "see": ["method [formatTWIG]{@link #jsdoc_method_formatTWIG}"],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "formatTWIG",
      "alias": "",
      "desc": "Interprets the given TWIG string",
      "params": [{
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG string",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "dict",
        "type": ["Object.<string, *>", "Array.<Object.<string, *>>"],
        "desc": "the dictionary",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "twigs",
        "type": ["Object.<string, string>"],
        "desc": "dictionary of fragments",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "see": ["{@link https://twig.symfony.com/doc/}"],
      "returns": [{
        "type": ["string"],
        "desc": "The Interpreted TWIG string"
      }]
    }, {
      "name": "renderJSDoc",
      "alias": "",
      "desc": "Renders a AMI JSDoc documentation",
      "params": [{
        "name": "menuSelector",
        "type": ["string"],
        "desc": "selector of the menu div",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "bodySelector",
        "type": ["string"],
        "desc": "selector of the body div",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "json",
        "type": ["object"],
        "desc": "the JSON documentation",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["AMIJSDoc"],
        "desc": ""
      }]
    }, {
      "name": "loadResources",
      "alias": "",
      "desc": "Asynchronously loads resources by file extension",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadSheets",
      "alias": "",
      "desc": "Asynchronously loads CSS sheets",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadScripts",
      "alias": "",
      "desc": "Asynchronously loads JS scripts",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadJSONs",
      "alias": "",
      "desc": "Asynchronously loads JSON files",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadXMLs",
      "alias": "",
      "desc": "Asynchronously loads XML files",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadHTMLs",
      "alias": "",
      "desc": "Asynchronously loads HTML files",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadTWIGs",
      "alias": "",
      "desc": "Asynchronously loads TWIG files",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadTexts",
      "alias": "",
      "desc": "Asynchronously loads text files",
      "params": [{
        "name": "urls",
        "type": ["Array.<string>", "string"],
        "desc": "the array of urls",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadSubApp",
      "alias": "",
      "desc": "Asynchronously loads a subapp",
      "params": [{
        "name": "subapp",
        "type": ["string"],
        "desc": "the subapp name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": true,
        "nullable": true
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, hash, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadSubAppAlt",
      "alias": "",
      "desc": "Asynchronously loads a subapp",
      "params": [{
        "name": "subapp",
        "type": ["string"],
        "desc": "the subapp name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": true,
        "nullable": true
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, hash, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["undefined"],
        "desc": "Nothing"
      }]
    }, {
      "name": "loadSubAppByURL",
      "alias": "",
      "desc": "Asynchronously loads a subapp by URL",
      "params": [{
        "name": "defaultSubApp",
        "type": ["string"],
        "desc": "if 'amiRouter.getArgs()[\"subapp\"]' is null, the default subapp name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "defaultUserData",
        "type": ["*"],
        "desc": "if 'amiRouter.getArgs()[\"userdata\"]' is null, the default user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "loadControl",
      "alias": "",
      "desc": "Asynchronously loads a control",
      "params": [{
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControl",
      "alias": "",
      "desc": "Asynchronously creates a control",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "owner",
        "type": ["*"],
        "desc": "the owner entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "params",
        "type": ["Array.<*>"],
        "desc": "the control's parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, patch, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlInBody",
      "alias": "",
      "desc": "Asynchronously creates a control in the body",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "owner",
        "type": ["*"],
        "desc": "the owner entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlParams",
        "type": ["Array.<*>"],
        "desc": "the control's render method mandatory parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlOptions",
        "type": ["Object.<string, *>"],
        "desc": "the control's render method optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "ownerOptions",
        "type": ["Object.<string, *>"],
        "desc": "the owner's optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, patch, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlInContainer",
      "alias": "",
      "desc": "Asynchronously creates a control in a container",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "owner",
        "type": ["*"],
        "desc": "the owner entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlParams",
        "type": ["Array.<*>"],
        "desc": "the control's render method mandatory parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlOptions",
        "type": ["Object.<string, *>"],
        "desc": "the control's render method optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "ownerOptions",
        "type": ["Object.<string, *>"],
        "desc": "the owner's optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "icon",
        "type": ["string"],
        "desc": "the icon",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "title",
        "type": ["string"],
        "desc": "the title",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, patch, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlFromWebLink",
      "alias": "",
      "desc": "Asynchronously creates a control in a container from a WEB link",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "owner",
        "type": ["*"],
        "desc": "the owner entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "el",
        "type": ["Element"],
        "desc": "the HTML element",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "ownerOptions",
        "type": ["Object.<string, *>"],
        "desc": "the owner's optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, patch, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }]
  }],
  "interfaces": [{
    "name": "ami.IControl",
    "alias": "",
    "desc": "The AMI control interface",
    "implements": [],
    "inherits": [],
    "functions": [{
      "name": "onReady",
      "alias": "",
      "desc": "Called when the control is ready to run",
      "params": [],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onRemove",
      "alias": "",
      "desc": "Called when the control is removed",
      "params": [],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "patchId",
      "alias": "",
      "desc": "Patches an HTML identifier",
      "params": [{
        "name": "id",
        "type": ["string"],
        "desc": "the not patched HTML identifier",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The patched HTML identifier"
      }]
    }, {
      "name": "replaceHTML",
      "alias": "",
      "desc": "Puts an HTML or TWIG fragment to the given target, see method [formatTWIG]{@link #jsdoc_method_formatTWIG}",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "prependHTML",
      "alias": "",
      "desc": "Prepends an HTML or TWIG fragment to the given target, see method [formatTWIG]{@link #jsdoc_method_formatTWIG}",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "appendHTML",
      "alias": "",
      "desc": "Appends an HTML or TWIG fragment to the given target, see method [formatTWIG]{@link #jsdoc_method_formatTWIG}",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }]
  }, {
    "name": "ami.IContainer",
    "alias": "",
    "desc": "The AMI container interface",
    "implements": [],
    "inherits": [],
    "functions": [{
      "name": "render",
      "alias": "",
      "desc": "",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (...)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "prependItem",
      "alias": "",
      "desc": "Prepends an item",
      "params": [{
        "name": "title",
        "type": ["string"],
        "desc": "the title",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (...)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object returning the new item's identifier"
      }]
    }, {
      "name": "appendItem",
      "alias": "",
      "desc": "Appends an item",
      "params": [{
        "name": "title",
        "type": ["string"],
        "desc": "the title",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (...)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object returning the new item's identifier"
      }]
    }, {
      "name": "removeItem",
      "alias": "",
      "desc": "Removes an item",
      "params": [{
        "name": "itemId",
        "type": ["string"],
        "desc": "the item identifier",
        "default": "",
        "optional": "",
        "nullable": ""
      }]
    }, {
      "name": "removeAllItems",
      "alias": "",
      "desc": "Removes all items",
      "params": []
    }, {
      "name": "isEmpty",
      "alias": "",
      "desc": "Checks whether the container is empty or not",
      "params": [],
      "returns": [{
        "type": ["boolean"],
        "desc": ""
      }]
    }]
  }, {
    "name": "ami.ISubApp",
    "alias": "",
    "desc": "The AMI sub-application interface",
    "implements": [],
    "inherits": [],
    "functions": [{
      "name": "onReady",
      "alias": "",
      "desc": "Called when the sub-application is ready to run",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onExit",
      "alias": "",
      "desc": "Called when the sub-application is about to exit",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onLogin",
      "alias": "",
      "desc": "Called when logging in",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onLogout",
      "alias": "",
      "desc": "Called when logging out",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }]
  }],
  "classes": [{
    "name": "ami.Control",
    "alias": "",
    "desc": "The basic AMI control",
    "implements": ["ami.IControl"],
    "inherits": [],
    "konstructor": {
      "name": "Control",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "optional": "",
        "nullable": true
      }, {
        "name": "owner",
        "type": ["*"],
        "desc": "the owner entity",
        "optional": "",
        "nullable": true
      }]
    },
    "functions": [{
      "name": "onReady",
      "alias": "",
      "desc": "Called when the control is ready to run",
      "params": [],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onRemove",
      "alias": "",
      "desc": "Called when the control is removed",
      "params": [],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "patchId",
      "alias": "",
      "desc": "Patches an HTML identifier",
      "params": [{
        "name": "id",
        "type": ["string"],
        "desc": "the not patched HTML identifier",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["string"],
        "desc": "The patched HTML identifier"
      }]
    }, {
      "name": "replaceHTML",
      "alias": "",
      "desc": "Puts an HTML or TWIG fragment to the given target, see method [formatTWIG]{@link #jsdoc_method_formatTWIG}",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "prependHTML",
      "alias": "",
      "desc": "Prepends an HTML or TWIG fragment to the given target, see method [formatTWIG]{@link #jsdoc_method_formatTWIG}",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "appendHTML",
      "alias": "",
      "desc": "Appends an HTML or TWIG fragment to the given target, see method [formatTWIG]{@link #jsdoc_method_formatTWIG}",
      "params": [{
        "name": "selector",
        "type": ["string"],
        "desc": "the target selector",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "twig",
        "type": ["string"],
        "desc": "the TWIG fragment",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, dict, twigs)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "setupCtx",
      "alias": "",
      "desc": "Sets up the control's context",
      "params": [{
        "name": "immutables",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of immutable parameters in the control's context",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "defaults",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of default values for optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of values for optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["Object.<string, *>"],
        "desc": "The resulting control's context"
      }]
    }, {
      "name": "createControl",
      "alias": "",
      "desc": "Asynchronously creates a control",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "params",
        "type": ["Array.<*>"],
        "desc": "the control's parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlInBody",
      "alias": "",
      "desc": "Asynchronously creates a control in the body",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlParams",
        "type": ["Array.<*>"],
        "desc": "the control's render method mandatory parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlOptions",
        "type": ["Object.<string, *>"],
        "desc": "the control's render method optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlInContainer",
      "alias": "",
      "desc": "Asynchronously creates a control in a container",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlParams",
        "type": ["Array.<*>"],
        "desc": "the control's render method mandatory parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlOptions",
        "type": ["Object.<string, *>"],
        "desc": "the control's render method optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "icon",
        "type": ["string"],
        "desc": "the icon",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "title",
        "type": ["string"],
        "desc": "the title",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlFromWebLink",
      "alias": "",
      "desc": "Asynchronously creates a control in a container from a WEB link",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "el",
        "type": ["Element"],
        "desc": "the HTML element",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }]
  }, {
    "name": "ami.SubApp",
    "alias": "",
    "desc": "The basic AMI sub-application",
    "implements": ["ami.ISubApp"],
    "inherits": [],
    "konstructor": {
      "name": "SubApp",
      "params": []
    },
    "functions": [{
      "name": "onReady",
      "alias": "",
      "desc": "Called when the sub-application is ready to run",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onExit",
      "alias": "",
      "desc": "Called when the sub-application is about to exit",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onLogin",
      "alias": "",
      "desc": "Called when logging in",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "onLogout",
      "alias": "",
      "desc": "Called when logging out",
      "params": [{
        "name": "userdata",
        "type": ["*"],
        "desc": "the user data",
        "default": "",
        "optional": "",
        "nullable": true
      }],
      "returns": [{
        "type": ["$.Promise", "$.Deferred", "undefined"],
        "desc": "A JQuery promise object, deferred object or nothing"
      }]
    }, {
      "name": "setupCtx",
      "alias": "",
      "desc": "Sets up the application's context",
      "params": [{
        "name": "immutables",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of immutable parameters in the application's context",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "defaults",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of default values for optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of values for optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }],
      "returns": [{
        "type": ["Object.<string, *>"],
        "desc": "The resulting application's context"
      }]
    }, {
      "name": "createControl",
      "alias": "",
      "desc": "Asynchronously creates a control",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "params",
        "type": ["Array.<*>"],
        "desc": "the control's parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlInBody",
      "alias": "",
      "desc": "Asynchronously creates a control in the body",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlParams",
        "type": ["Array.<*>"],
        "desc": "the control's render method mandatory parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlOptions",
        "type": ["Object.<string, *>"],
        "desc": "the control's render method optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlInContainer",
      "alias": "",
      "desc": "Asynchronously creates a control in a container",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "control",
        "type": ["string"],
        "desc": "the control name",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlParams",
        "type": ["Array.<*>"],
        "desc": "the control's render method mandatory parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "controlOptions",
        "type": ["Object.<string, *>"],
        "desc": "the control's render method optional parameters",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "icon",
        "type": ["string"],
        "desc": "the icon",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "title",
        "type": ["string"],
        "desc": "the title",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }, {
      "name": "createControlFromWebLink",
      "alias": "",
      "desc": "Asynchronously creates a control in a container from a WEB link",
      "params": [{
        "name": "parent",
        "type": ["*"],
        "desc": "the parent entity",
        "default": "",
        "optional": "",
        "nullable": true
      }, {
        "name": "el",
        "type": ["Element"],
        "desc": "the HTML element",
        "default": "",
        "optional": "",
        "nullable": ""
      }, {
        "name": "options",
        "type": ["Object.<string, *>"],
        "desc": "dictionary of optional parameters (context, cache)",
        "default": "{}",
        "optional": true,
        "nullable": ""
      }],
      "returns": [{
        "type": ["$.Promise"],
        "desc": "A JQuery promise object"
      }]
    }]
  }],
  "functions": [{
    "name": "$AMINamespace",
    "alias": "",
    "desc": "Creates a new namespace",
    "params": [{
      "name": "$name",
      "type": ["string"],
      "desc": "the namespace name",
      "default": "",
      "optional": "",
      "nullable": ""
    }, {
      "name": "$descr",
      "type": ["Object.<string, *>"],
      "desc": "the namespace body",
      "default": "{}",
      "optional": true,
      "nullable": ""
    }]
  }, {
    "name": "$AMIInterface",
    "alias": "",
    "desc": "Creates a new interface",
    "params": [{
      "name": "$name",
      "type": ["string"],
      "desc": "the interface name",
      "default": "",
      "optional": "",
      "nullable": ""
    }, {
      "name": "$descr",
      "type": ["Object.<string, *>"],
      "desc": "the interface body",
      "default": "{}",
      "optional": true,
      "nullable": ""
    }]
  }, {
    "name": "$AMIClass",
    "alias": "",
    "desc": "Creates a new class",
    "params": [{
      "name": "$name",
      "type": ["string"],
      "desc": "the class name",
      "default": "",
      "optional": "",
      "nullable": ""
    }, {
      "name": "$descr",
      "type": ["Object.<string, *>"],
      "desc": "the class body",
      "default": "{}",
      "optional": true,
      "nullable": ""
    }]
  }]
});
;// ./index.js






window.$AMIClass = $AMIClass;
window.$AMINamespace = $AMINamespace;
window.$AMIInterface = $AMIInterface;
window.amiCommand = js_AMICommand;
window.amiRouter = js_AMIRouter;
window.amiWebApp = js_AMIWebApp;
window.amiLogin = js_AMIAuth;
window.amiAuth = js_AMIAuth;
window.amiDoc = AMIDoc;
})();

/******/ })()
;